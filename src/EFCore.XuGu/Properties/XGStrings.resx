<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TwoDataSourcesInSameServiceProvider" xml:space="preserve">
    <value>Using two distinct data sources within a service provider is not supported, and Entity Framework is not building its own internal service provider. Either allow Entity Framework to build the service provider by removing the call to '{useInternalServiceProvider}', or ensure that the same data source is used for all uses of a given service provider passed to '{useInternalServiceProvider}'.</value>
  </data>
  <data name="IdentityBadType" xml:space="preserve">
    <value>Identity value generation cannot be used for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Identity value generation can only be used with integer, DateTime, and DateTimeOffset properties.</value>
  </data>
  <data name="UnqualifiedDataType" xml:space="preserve">
    <value>Data type '{dataType}' is not supported in this form. Either specify the length explicitly in the type name, for example as '{dataType}(16)', or remove the data type and use APIs such as HasMaxLength to allow EF choose the data type.</value>
  </data>
  <data name="UnqualifiedDataTypeOnProperty" xml:space="preserve">
    <value>Data type '{dataType}' for property '{property}' is not supported in this form. Either specify the length explicitly in the type name, for example as '{dataType}(16)', or remove the data type and use APIs such as HasMaxLength to allow EF choose the data type.</value>
  </data>
  <data name="SequenceBadType" xml:space="preserve">
    <value>XG sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.</value>
  </data>
  <data name="IndexTableRequired" xml:space="preserve">
    <value>XG requires the table name to be specified for index operations. Specify table name in calls to 'MigrationBuilder.RenameIndex' and 'DropIndex'.</value>
  </data>
  <data name="AlterMemoryOptimizedTable" xml:space="preserve">
    <value>To set memory-optimized on a table on or off the table needs to be dropped and recreated.</value>
  </data>
  <data name="AlterIdentityColumn" xml:space="preserve">
    <value>To change the IDENTITY property of a column, the column needs to be dropped and recreated.</value>
  </data>
  <data name="TransientExceptionDetected" xml:space="preserve">
    <value>An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding 'EnableRetryOnFailure()' to the 'UseXG' call.</value>
  </data>
  <data name="LogDefaultDecimalTypeColumn" xml:space="preserve">
    <value>No type was specified for the decimal column '{property}' on entity type '{entityType}'. This will cause values to be silently truncated if they do not fit in the default precision and scale. Explicitly specify the SQL server column type that can accommodate all the values using 'ForHasColumnType()'.</value>
    <comment>Warning XGEventId.DecimalTypeDefaultWarning string string</comment>
  </data>
  <data name="LogByteIdentityColumn" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is of type 'byte', but is set up to use a XG identity column. This requires that values starting at 255 and counting down will be used for temporary key values. A temporary key value is needed for every entity inserted in a single call to 'SaveChanges'. Care must be taken that these values do not collide with real key values.</value>
    <comment>Warning XGEventId.ByteIdentityColumnWarning string string</comment>
  </data>
  <data name="NonKeyValueGeneration" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is configured to use 'SequenceHiLo' value generator, which is only intended for keys. If this was intentional configure an alternate key on the property, otherwise call 'ValueGeneratedNever' or configure store generation for this property.</value>
  </data>
  <data name="MultipleIdentityColumns" xml:space="preserve">
    <value>The properties {properties} are configured to use 'Identity' value generator and are mapped to the same table '{table}'. Only one column per table can be configured as 'Identity'. Call 'ValueGeneratedNever' for properties that should not use 'Identity'.</value>
  </data>
  <data name="IncompatibleTableMemoryOptimizedMismatch" xml:space="preserve">
    <value>Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and entity type '{memoryOptimizedEntityType}' is marked as memory-optimized, but entity type '{nonMemoryOptimizedEntityType}' is not.</value>
  </data>
  <data name="LogFoundDefaultSchema" xml:space="preserve">
    <value>Found default schema {defaultSchema}.</value>
    <comment>Debug XGEventId.DefaultSchemaFound string</comment>
  </data>
  <data name="LogFoundTypeAlias" xml:space="preserve">
    <value>Found type alias with name: {alias} which maps to underlying data type {dataType}.</value>
    <comment>Debug XGEventId.TypeAliasFound string string</comment>
  </data>
  <data name="LogFoundColumn" xml:space="preserve">
    <value>Found column with table: {tableName}, column name: {columnName}, ordinal: {ordinal}, data type: {dataType}, maximum length: {maxLength}, precision: {precision}, scale: {scale}, nullable: {isNullable}, identity: {isIdentity}, default value: {defaultValue}, computed value: {computedValue}</value>
    <comment>Debug XGEventId.ColumnFound string string int string int int int bool bool string string</comment>
  </data>
  <data name="LogFoundForeignKey" xml:space="preserve">
    <value>Found foreign key on table: {tableName}, name: {foreignKeyName}, principal table: {principalTableName}, delete action: {deleteAction}.</value>
    <comment>Debug XGEventId.ForeignKeyFound string string string string</comment>
  </data>
  <data name="LogPrincipalTableNotInSelectionSet" xml:space="preserve">
    <value>For foreign key {fkName} on table {tableName}, unable to model the end of the foreign key on principal table {principaltableName}. This is usually because the principal table was not included in the selection set.</value>
    <comment>Warning XGEventId.ForeignKeyReferencesMissingPrincipalTableWarning string string string</comment>
  </data>
  <data name="LogMissingSchema" xml:space="preserve">
    <value>Unable to find a schema in the database matching the selected schema {schema}.</value>
    <comment>Warning XGEventId.MissingSchemaWarning string</comment>
  </data>
  <data name="LogMissingTable" xml:space="preserve">
    <value>Unable to find a table in the database matching the selected table {table}.</value>
    <comment>Warning XGEventId.MissingTableWarning string</comment>
  </data>
  <data name="LogFoundSequence" xml:space="preserve">
    <value>Found sequence name: {name}, data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.</value>
    <comment>Debug XGEventId.SequenceFound string string bool int long long long</comment>
  </data>
  <data name="LogFoundTable" xml:space="preserve">
    <value>Found table with name: {name}.</value>
    <comment>Debug XGEventId.TableFound string</comment>
  </data>
  <data name="NoInitialCatalog" xml:space="preserve">
    <value>The database name could not be determined. To use EnsureDeleted, the connection string must specify Initial Catalog.</value>
  </data>
  <data name="DuplicateColumnNameValueGenerationStrategyMismatch" xml:space="preserve">
    <value>'{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different value generation strategies.</value>
  </data>
  <data name="LogFoundIndex" xml:space="preserve">
    <value>Found index with name: {indexName}, table: {tableName}, is unique: {isUnique}.</value>
    <comment>Debug XGEventId.IndexFound string string bool</comment>
  </data>
  <data name="LogFoundPrimaryKey" xml:space="preserve">
    <value>Found primary key with name: {primaryKeyName}, table: {tableName}.</value>
    <comment>Debug XGEventId.PrimaryKeyFound string string</comment>
  </data>
  <data name="LogFoundUniqueConstraint" xml:space="preserve">
    <value>Found unique constraint with name: {uniqueConstraintName}, table: {tableName}.</value>
    <comment>Debug XGEventId.UniqueConstraintFound string string</comment>
  </data>
  <data name="LogPrincipalColumnNotFound" xml:space="preserve">
    <value>For foreign key {foreignKeyName} on table {tableName}, unable to find the column called {principalColumnName} on the foreign key's principal table, {principaltableName}. Skipping foreign key.</value>
    <comment>Warning XGEventId.ForeignKeyPrincipalColumnMissingWarning string string string string</comment>
  </data>
  <data name="InvalidTableToIncludeInScaffolding" xml:space="preserve">
    <value>The specified table '{table}' is not valid. Specify tables using the format '[schema].[table]'.</value>
  </data>
  <data name="FunctionOnClient" xml:space="preserve">
    <value>The '{methodName}' method is not supported because the query has switched to client-evaluation. Inspect the log to determine which query expressions are triggering client-evaluation.</value>
  </data>
  <data name="ComputedBadType" xml:space="preserve">
    <value>Computed value generation cannot be used for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Computed value generation can only be used with DateTime and DateTimeOffset properties.</value>
  </data>
  <data name="ExpressionTypeMismatch" xml:space="preserve">
    <value>The specified expression does not have the correct Type.</value>
  </data>
  <data name="QueryUnableToTranslateMethodWithStringComparison" xml:space="preserve">
    <value>Translation of the '{declaringTypeName}.{methodName}' overload with a 'StringComparison' parameter is not supported by default. To opt-in to translations of methods with a 'StringComparison' parameter, call `{optionName}` on your XG specific 'DbContext' options. For general EF Core information about this error, see https://go.microsoft.com/fwlink/?linkid=2129535 for more information.</value>
  </data>
  <data name="LogDefaultValueNotSupported" xml:space="preserve">
    <value>The default value '{defaultValue}' is being ignored, because the database server version {version} does not support constant default values for type '{type}' and does not support default value expressions in general.</value>
  </data>
  <data name="StoredProcedureResultColumnsNotSupported" xml:space="preserve">
    <value>The entity type '{entityType}' is mapped to the stored procedure '{sproc}', which is configured with result columns. XG stored procedures do not support result columns; use output parameters instead.</value>
  </data>
  <data name="StoredProcedureReturnValueNotSupported" xml:space="preserve">
    <value>The entity type '{entityType}' is mapped to the stored procedure '{sproc}', which is configured with a return value. XG stored procedures do not support return values; use an output parameter instead.</value>
  </data>
  <data name="Ef7CoreJsonMappingNotSupported" xml:space="preserve">
    <value>The EF Core 7.0 JSON support isn't currently implemented. Instead, there is support for a more extensive implementation. See https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.XG for more information on how to map JSON.</value>
  </data>
</root>
