// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Text;
using JetBrains.Annotations;
using Microsoft.Data.Entity.Infrastructure;
using Microsoft.Data.Entity.Metadata;
using Microsoft.Data.Entity.Utilities;

namespace Microsoft.Data.Entity.Relational.Migrations.Infrastructure
{
    public class HistoryRepository
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly DbContextService<IDbContextOptions> _options;
        private readonly DbContextService<DbContext> _context;
        private IModel _historyModel;
        private DbContextOptions _contextOptions;

        /// <summary>
        ///     This constructor is intended only for use when creating test doubles that will override members
        ///     with mocked or faked behavior. Use of this constructor for other purposes may result in unexpected
        ///     behavior including but not limited to throwing <see cref="NullReferenceException" />.
        /// </summary>
        protected HistoryRepository()
        {
        }

        public HistoryRepository(
            [NotNull] IServiceProvider serviceProvider,
            [NotNull] DbContextService<IDbContextOptions> options,
            [NotNull] DbContextService<DbContext> context)
        {
            Check.NotNull(serviceProvider, "serviceProvider");

            _serviceProvider = serviceProvider;
            _options = options;
            _context = context;
        }

        public virtual SchemaQualifiedName TableName
        {
            get { return "__MigrationHistory"; }
        }

        public virtual IModel HistoryModel
        {
            get { return _historyModel ?? (_historyModel = CreateHistoryModel()); }
        }

        public virtual IReadOnlyList<HistoryRow> Rows
        {
            get
            {
                bool historyTableExists;
                return GetRows(out historyTableExists);
            }
        }

        public virtual IReadOnlyList<HistoryRow> GetRows([NotNull] out bool historyTableExists)
        {
            IReadOnlyList<HistoryRow> rows;

            try
            {
                rows = GetRows();
                historyTableExists = true;
            }
            catch (DbException)
            {
                // TODO: Log the exception message.
                rows = new HistoryRow[0];
                historyTableExists = false;
            }

            return rows;
        }

        protected virtual IReadOnlyList<HistoryRow> GetRows()
        {
            using (var historyContext = CreateHistoryContext())
            {
                return GetMigrationsQuery(historyContext).ToArray();
            }
        }

        protected virtual DbContextOptions HistoryContextOptions
        {
            get { return _contextOptions ?? (_contextOptions = CreateHistoryContextOptions()); }
        }

        public virtual DbContext CreateHistoryContext()
        {
            return new DbContext(_serviceProvider, HistoryContextOptions);
        }

        public virtual IQueryable<HistoryRow> GetMigrationsQuery([NotNull] DbContext historyContext)
        {
            Check.NotNull(historyContext, "historyContext");

            return
                historyContext.Set<HistoryRow>()
                    .Where(h => h.ContextKey == GetContextKey())
                    .OrderBy(h => h.MigrationId);
        }

        public virtual IReadOnlyList<SqlBatch> GenerateInsertMigrationSql(
            [NotNull] IMigrationMetadata migration, [NotNull] SqlGenerator sqlGenerator)
        {
            Check.NotNull(migration, "migration");
            Check.NotNull(sqlGenerator, "sqlGenerator");

            // TODO: Implement a mechanism to capture the SQL generated by 
            // the update pipeline (context.Add, context.SaveChanges) and use here.

            var stringBuilder = new StringBuilder();
            stringBuilder
                .Append("INSERT INTO ")
                .Append(sqlGenerator.DelimitIdentifier(TableName))
                .Append(" (")
                .Append(sqlGenerator.DelimitIdentifier("MigrationId"))
                .Append(", ")
                .Append(sqlGenerator.DelimitIdentifier("ContextKey"))
                .Append(", ")
                .Append(sqlGenerator.DelimitIdentifier("ProductVersion"))
                .Append(") VALUES (")
                .Append(sqlGenerator.GenerateLiteral(migration.MigrationId))
                .Append(", ")
                .Append(sqlGenerator.GenerateLiteral(GetContextKey()))
                .Append(", ")
                .Append(sqlGenerator.GenerateLiteral(migration.ProductVersion))
                .Append(")");

            return new[] { new SqlBatch(stringBuilder.ToString()) };
        }

        public virtual IReadOnlyList<SqlBatch> GenerateDeleteMigrationSql(
            [NotNull] IMigrationMetadata migration, [NotNull] SqlGenerator sqlGenerator)
        {
            Check.NotNull(migration, "migration");
            Check.NotNull(sqlGenerator, "sqlGenerator");

            // TODO: Implement a mechanism to capture the SQL generated by 
            // the update pipeline (context.Remove, context.SaveChanges) and use here.

            var stringBuilder = new StringBuilder();
            stringBuilder
                .Append("DELETE FROM ")
                .Append(sqlGenerator.DelimitIdentifier(TableName))
                .Append(" WHERE ")
                .Append(sqlGenerator.DelimitIdentifier("MigrationId"))
                .Append(" = ")
                .Append(sqlGenerator.GenerateLiteral(migration.MigrationId))
                .Append(" AND ")
                .Append(sqlGenerator.DelimitIdentifier("ContextKey"))
                .Append(" = ")
                .Append(sqlGenerator.GenerateLiteral(GetContextKey()));

            return new[] { new SqlBatch(stringBuilder.ToString()) };
        }

        protected virtual IModel CreateHistoryModel()
        {
            var builder = new BasicModelBuilder();

            builder.Entity<HistoryRow>(b =>
                {
                    b.Key(e => new { e.MigrationId, e.ContextKey });
                    b.Property(e => e.MigrationId).Required().MaxLength(150);
                    b.Property(e => e.ContextKey).Required().MaxLength(300);
                    b.Property(e => e.ProductVersion).Required().MaxLength(32);
                    b.ForRelational().Table(TableName);
                });

            return builder.Model;
        }

        protected virtual DbContextOptions CreateHistoryContextOptions()
        {
            IDbContextOptions contextOptions = new DbContextOptions().UseModel(HistoryModel);

            // TODO: Figure out whether it is ok to reuse all the extensions
            // from the user context configuration for the history context.
            foreach (var item in _options.Service.Extensions)
            {
                var extension = item;
                contextOptions.AddExtension(extension);
            }

            return (DbContextOptions)contextOptions;
        }

        protected virtual string GetContextKey()
        {
            return _context.Service.GetType().FullName;
        }
    }
}
