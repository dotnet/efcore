<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AnalyticalTTLMismatch" xml:space="preserve">
    <value>The time to live for analytical store was configured to '{ttl1}' on '{entityType1}', but on '{entityType2}' it was configured to '{ttl2}'. All entity types mapped to the same container '{container}' must be configured with the same time to live for analytical store.</value>
  </data>
  <data name="CanConnectNotSupported" xml:space="preserve">
    <value>The Cosmos database does not support 'CanConnect' or 'CanConnectAsync'.</value>
  </data>
  <data name="CannotTranslateNonConstantNewArrayExpression" xml:space="preserve">
    <value>The query contained a new array expression containing non-constant elements, which could not be translated: '{newArrayExpression}'.</value>
  </data>
  <data name="ConnectionInfoMissing" xml:space="preserve">
    <value>None of connection string, CredentialToken, account key or account endpoint were specified. Specify a set of connection details.</value>
  </data>
  <data name="ContainerContainingPropertyConflict" xml:space="preserve">
    <value>The entity type '{entityType}' is mapped to the container '{container}' but it is also configured as being contained in property '{property}'.</value>
  </data>
  <data name="CosmosNotInUse" xml:space="preserve">
    <value>Cosmos-specific methods can only be used when the context is using the Cosmos provider.</value>
  </data>
  <data name="DefaultTTLMismatch" xml:space="preserve">
    <value>The default time to live was configured to '{ttl1}' on '{entityType1}', but on '{entityType2}' it was configured to '{ttl2}'. All entity types mapped to the same container '{container}' must be configured with the same default time to live.</value>
  </data>
  <data name="DuplicateDiscriminatorValue" xml:space="preserve">
    <value>The discriminator value for '{entityType1}' is '{discriminatorValue}' which is the same for '{entityType2}'. Every concrete entity type mapped to the container '{container}' must have a unique discriminator value.</value>
  </data>
  <data name="ETagNonStringStoreType" xml:space="preserve">
    <value>The type of the etag property '{property}' on '{entityType}' is '{propertyType}'. All etag properties must be strings or have a string value converter.</value>
  </data>
  <data name="IdNonStringStoreType" xml:space="preserve">
    <value>The type of the '{idProperty}' property on '{entityType}' is '{propertyType}'. All 'id' properties must be strings or have a string value converter.</value>
  </data>
  <data name="InvalidDerivedTypeInEntityProjection" xml:space="preserve">
    <value>The specified entity type '{derivedType}' is not derived from '{entityType}'.</value>
  </data>
  <data name="InvalidFromSqlArguments" xml:space="preserve">
    <value>A FromSqlExpression has an invalid arguments expression type '{expressionType}' or value type '{valueType}'.</value>
  </data>
  <data name="InvalidResourceId" xml:space="preserve">
    <value>Unable to generate a valid 'id' value to execute a 'ReadItem' query. This usually happens when the value provided for one of the properties is 'null' or an empty string. Please supply a value that's not 'null' or an empty string.</value>
  </data>
  <data name="JsonPropertyCollision" xml:space="preserve">
    <value>Both properties '{property1}' and '{property2}' on entity type '{entityType}' are mapped to '{storeName}'. Map one of the properties to a different JSON property.</value>
  </data>
  <data name="LogExecutedCreateItem" xml:space="preserve">
    <value>Executed CreateItem ({elapsed} ms, {charge} RU) ActivityId='{activityId}', Container='{container}', Id='{id}', Partition='{partitionKey}'</value>
    <comment>Information CosmosEventId.ExecutedCreateItem string string string string string string?</comment>
  </data>
  <data name="LogExecutedDeleteItem" xml:space="preserve">
    <value>Executed DeleteItem ({elapsed} ms, {charge} RU) ActivityId='{activityId}', Container='{container}', Id='{id}', Partition='{partitionKey}'</value>
    <comment>Information CosmosEventId.ExecutedDeleteItem string string string string string string?</comment>
  </data>
  <data name="LogExecutedReadItem" xml:space="preserve">
    <value>Executed ReadItem ({elapsed} ms, {charge} RU) ActivityId='{activityId}', Container='{container}', Id='{id}', Partition='{partitionKey}'</value>
    <comment>Information CosmosEventId.ExecutedReadItem string string string string string string?</comment>
  </data>
  <data name="LogExecutedReadNext" xml:space="preserve">
    <value>Executed ReadNext ({elapsed} ms, {charge} RU) ActivityId='{activityId}', Container='{container}', Partition='{partitionKey}', Parameters=[{parameters}]{newLine}{sql}</value>
    <comment>Information CosmosEventId.ExecutedReadNext string string string string string? string string string string</comment>
  </data>
  <data name="LogExecutedReplaceItem" xml:space="preserve">
    <value>Executed ReplaceItem ({elapsed} ms, {charge} RU) ActivityId='{activityId}', Container='{container}', Id='{id}', Partition='{partitionKey}'</value>
    <comment>Information CosmosEventId.ExecutedReplaceItem string string string string string string?</comment>
  </data>
  <data name="LogExecutingReadItem" xml:space="preserve">
    <value>Reading resource '{resourceId}' item from container '{containerId}' in partition '{partitionKey}'.</value>
    <comment>Information CosmosEventId.ExecutingReadItem string string string?</comment>
  </data>
  <data name="LogExecutingSqlQuery" xml:space="preserve">
    <value>Executing SQL query for container '{containerId}' in partition '{partitionKey}' [Parameters=[{parameters}]]{newLine}{commandText}</value>
    <comment>Information CosmosEventId.ExecutingSqlQuery string string? string string string</comment>
  </data>
  <data name="LogSyncNotSupported" xml:space="preserve">
    <value>Azure Cosmos DB does not support synchronous I/O. Make sure to use and correctly await only async methods when using Entity Framework Core to access Azure Cosmos DB. See https://aka.ms/ef-cosmos-nosync for more information.</value>
    <comment>Error CosmosEventId.SyncNotSupported</comment>
  </data>
  <data name="MissingOrderingInSelectExpression" xml:space="preserve">
    <value>'Reverse' could not be translated to the server because there is no ordering on the server side.</value>
  </data>
  <data name="NavigationPropertyIsNotAnEmbeddedEntity" xml:space="preserve">
    <value>Navigation '{entityType}.{navigationName}' doesn't point to an embedded entity.</value>
  </data>
  <data name="NoDiscriminatorProperty" xml:space="preserve">
    <value>The entity type '{entityType}' is sharing the container '{container}' with other types, but does not have a discriminator property configured. Configure a discriminator property and assign a unique value for this entity type.</value>
  </data>
  <data name="NoDiscriminatorValue" xml:space="preserve">
    <value>The entity type '{entityType}' is sharing the container '{container}' with other types, but does not have a discriminator value configured. Configure a unique discriminator value for this entity type.</value>
  </data>
  <data name="NoIdKey" xml:space="preserve">
    <value>The entity type '{entityType}' does not have a key declared on the '{idProperty}' property. Add a key to '{entityType}' that contains '{idProperty}'.</value>
  </data>
  <data name="NoIdProperty" xml:space="preserve">
    <value>The entity type '{entityType}' does not have a property mapped to the 'id' property in the database. Add a property mapped to 'id'.</value>
  </data>
  <data name="NonEmbeddedIncludeNotSupported" xml:space="preserve">
    <value>Including navigation '{navigation}' is not supported as the navigation is not embedded in same resource.</value>
  </data>
  <data name="NonETagConcurrencyToken" xml:space="preserve">
    <value>The entity type '{entityType}' has property '{property}' configured as a concurrency token, but only a property mapped to '_etag' is supported as a concurrency token. Consider using 'PropertyBuilder.IsETagConcurrency'.</value>
  </data>
  <data name="NoPartitionKey" xml:space="preserve">
    <value>The entity type '{entityType}' does not have a partition key set, but is mapped to the container '{container}' shared by entity types with partition keys. Configure a compatible partition key on '{entityType}'.</value>
  </data>
  <data name="NoPartitionKeyKey" xml:space="preserve">
    <value>The entity type '{entityType}' does not have a key declared on '{partitionKey}' and '{idProperty}' properties. Add a key to '{entityType}' that contains '{partitionKey}' and '{idProperty}'.</value>
  </data>
  <data name="NoReadItemQueryString" xml:space="preserve">
    <value>There is no string-based representation of this query as it's executed using 'ReadItemQueryAsync({resourceId}, {partitionKey})'.</value>
  </data>
  <data name="NoSubqueryPushdown" xml:space="preserve">
    <value>Azure Cosmos DB does not have an appropriate subquery for this translation.</value>
  </data>
  <data name="NullTypeMappingInSqlTree" xml:space="preserve">
    <value>The expression '{sqlExpression}' in the SQL tree does not have a type mapping assigned.</value>
  </data>
  <data name="OffsetRequiresLimit" xml:space="preserve">
    <value>Cosmos SQL does not allow Offset without Limit. Consider specifying a 'Take' operation on the query.</value>
  </data>
  <data name="OneOfTwoValuesMustBeSet" xml:space="preserve">
    <value>Exactly one of '{param1}' or '{param2}' must be set.</value>
  </data>
  <data name="OnlyConstantsAndParametersAllowedInContains" xml:space="preserve">
    <value>Only constants or parameters are currently allowed in Contains.</value>
  </data>
  <data name="OrphanedNestedDocument" xml:space="preserve">
    <value>The entity of type '{entityType}' is mapped as a part of the document mapped to '{missingEntityType}', but there is no tracked entity of this type with the corresponding key value. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values.</value>
  </data>
  <data name="OrphanedNestedDocumentSensitive" xml:space="preserve">
    <value>The entity of type '{entityType}' is mapped as part of the document mapped to '{missingEntityType}', but there is no tracked entity of this type with the key value '{keyValue}'.</value>
  </data>
  <data name="OwnedTypeDifferentContainer" xml:space="preserve">
    <value>The entity type '{entityType}' is owned by the entity type '{owner}', but is mapped to the container '{container}'. Owned types mapped to a container directly are not supported, remove this configuration to allow the owned type to be embedded in the same document as the owner.</value>
  </data>
  <data name="PartitionKeyMismatch" xml:space="preserve">
    <value>The partition key specified in the 'WithPartitionKey' call '{partitionKey1}' and the partition key specified in the 'Where' predicate '{partitionKey2}' must be identical to return any results. Remove one of them.</value>
  </data>
  <data name="PartitionKeyMissing" xml:space="preserve">
    <value>Unable to execute a 'ReadItem' query since the partition key value is missing. Consider using the 'WithPartitionKey' method on the query to specify partition key to use.</value>
  </data>
  <data name="PartitionKeyMissingProperty" xml:space="preserve">
    <value>The partition key for entity type '{entityType}' is set to '{property}', but there is no property with that name.</value>
  </data>
  <data name="PartitionKeyNonStringStoreType" xml:space="preserve">
    <value>The type of the partition key property '{property}' on '{entityType}' is '{propertyType}'. All partition key properties need to be strings or have a string value converter.</value>
  </data>
  <data name="PartitionKeyStoreNameMismatch" xml:space="preserve">
    <value>The partition key property '{property1}' on '{entityType1}' is mapped as '{storeName1}', but the partition key property '{property2}' on '{entityType2}' is mapped as '{storeName2}'. All partition key properties need to be mapped to the same store property for entity types mapped to the same container.</value>
  </data>
  <data name="PrimitiveCollectionsNotSupported" xml:space="preserve">
    <value>The property '{entityType}.{property}' is configured as an EF8 primitive collection. Primitive collections in a Cosmos model are discovered by convention.</value>
  </data>
  <data name="ResourceIdMissing" xml:space="preserve">
    <value>Unable to execute a 'ReadItem' query since the 'id' value is missing and cannot be generated.</value>
  </data>
  <data name="ReverseAfterSkipTakeNotSupported" xml:space="preserve">
    <value>Reversing the ordering is not supported when limit or offset are already applied.</value>
  </data>
  <data name="ThroughputMismatch" xml:space="preserve">
    <value>The provisioned throughput was configured to '{throughput1}' on '{entityType1}', but on '{entityType2}' it was configured to '{throughput2}'. All entity types mapped to the same container '{container}' must be configured with the same provisioned throughput.</value>
  </data>
  <data name="ThroughputTypeMismatch" xml:space="preserve">
    <value>The provisioned throughput was configured as manual on '{manualEntityType}', but on '{autoscaleEntityType}' it was configured as autoscale. All entity types mapped to the same container '{container}' must be configured with the same provisioned throughput type.</value>
  </data>
  <data name="TransactionsNotSupported" xml:space="preserve">
    <value>The Cosmos database provider does not support transactions.</value>
  </data>
  <data name="UnableToBindMemberToEntityProjection" xml:space="preserve">
    <value>Unable to bind '{memberType}' '{member}' to an entity projection of '{entityType}'.</value>
  </data>
  <data name="UnsupportedOperatorForSqlExpression" xml:space="preserve">
    <value>Unsupported operator '{nodeType}' specified for expression of type '{expressionType}'.</value>
  </data>
  <data name="UpdateConflict" xml:space="preserve">
    <value>Conflicts were detected for item with id '{itemId}'.</value>
  </data>
  <data name="UpdateStoreException" xml:space="preserve">
    <value>An error occurred while saving the item with id '{itemId}'. See the inner exception for details.</value>
  </data>
  <data name="VisitChildrenMustBeOverridden" xml:space="preserve">
    <value>'VisitChildren' must be overridden in the class deriving from 'SqlExpression'.</value>
  </data>
</root>