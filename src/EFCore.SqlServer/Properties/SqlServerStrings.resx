<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="IdentityBadType" xml:space="preserve">
    <value>Identity value generation cannot be used for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Identity value generation can only be used with signed integer properties.</value>
  </data>
  <data name="UnqualifiedDataType" xml:space="preserve">
    <value>Data type '{dataType}' is not supported in this form. Either specify the length explicitly in the type name, for example as '{dataType}(16)', or remove the data type and use APIs such as HasMaxLength to allow EF choose the data type.</value>
  </data>
  <data name="UnqualifiedDataTypeOnProperty" xml:space="preserve">
    <value>Data type '{dataType}' for property '{property}' is not supported in this form. Either specify the length explicitly in the type name, for example as '{dataType}(16)', or remove the data type and use APIs such as HasMaxLength to allow EF choose the data type.</value>
  </data>
  <data name="SequenceBadType" xml:space="preserve">
    <value>SQL Server sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.</value>
  </data>
  <data name="IndexTableRequired" xml:space="preserve">
    <value>SQL Server requires the table name to be specified for rename index operations. Specify table name in the call to MigrationBuilder.RenameIndex.</value>
  </data>
  <data name="AlterMemoryOptimizedTable" xml:space="preserve">
    <value>To set memory-optimized on a table on or off the table needs to be dropped and recreated.</value>
  </data>
  <data name="AlterIdentityColumn" xml:space="preserve">
    <value>To change the IDENTITY property of a column, the column needs to be dropped and recreated.</value>
  </data>
  <data name="TransientExceptionDetected" xml:space="preserve">
    <value>An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding 'EnableRetryOnFailure()' to the 'UseSqlServer' call.</value>
  </data>
  <data name="LogDefaultDecimalTypeColumn" xml:space="preserve">
    <value>No type was specified for the decimal column '{property}' on entity type '{entityType}'. This will cause values to be silently truncated if they do not fit in the default precision and scale. Explicitly specify the SQL server column type that can accommodate all the values using 'HasColumnType()'.</value>
    <comment>Warning SqlServerEventId.DecimalTypeDefaultWarning string string</comment>
  </data>
  <data name="LogByteIdentityColumn" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is of type 'byte', but is set up to use a SQL Server identity column. This requires that values starting at 255 and counting down will be used for temporary key values. A temporary key value is needed for every entity inserted in a single call to 'SaveChanges'. Care must be taken that these values do not collide with real key values.</value>
    <comment>Warning SqlServerEventId.ByteIdentityColumnWarning string string</comment>
  </data>
  <data name="NonKeyValueGeneration" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is configured to use 'SequenceHiLo' value generator, which is only intended for keys. If this was intentional configure an alternate key on the property, otherwise call 'ValueGeneratedNever' or configure store generation for this property.</value>
  </data>
  <data name="MultipleIdentityColumns" xml:space="preserve">
    <value>The properties {properties} are configured to use 'Identity' value generator and are mapped to the same table '{table}'. Only one column per table can be configured as 'Identity'. Call 'ValueGeneratedNever' for properties that should not use 'Identity'.</value>
  </data>
  <data name="IncompatibleTableMemoryOptimizedMismatch" xml:space="preserve">
    <value>Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and entity type '{memoryOptimizedEntityType}' is marked as memory-optimized, but entity type '{nonMemoryOptimizedEntityType}' is not.</value>
  </data>
  <data name="LogFoundDefaultSchema" xml:space="preserve">
    <value>Found default schema {defaultSchema}.</value>
    <comment>Debug SqlServerEventId.DefaultSchemaFound string</comment>
  </data>
  <data name="LogFoundTypeAlias" xml:space="preserve">
    <value>Found type alias with name: {alias} which maps to underlying data type {dataType}.</value>
    <comment>Debug SqlServerEventId.TypeAliasFound string string</comment>
  </data>
  <data name="LogFoundColumn" xml:space="preserve">
    <value>Found column with table: {tableName}, column name: {columnName}, ordinal: {ordinal}, data type: {dataType}, maximum length: {maxLength}, precision: {precision}, scale: {scale}, nullable: {isNullable}, identity: {isIdentity}, default value: {defaultValue}, computed value: {computedValue}</value>
    <comment>Debug SqlServerEventId.ColumnFound string string int string int int int bool bool string string</comment>
  </data>
  <data name="LogFoundForeignKey" xml:space="preserve">
    <value>Found foreign key on table: {tableName}, name: {foreignKeyName}, principal table: {principalTableName}, delete action: {deleteAction}.</value>
    <comment>Debug SqlServerEventId.ForeignKeyFound string string string string</comment>
  </data>
  <data name="LogPrincipalTableNotInSelectionSet" xml:space="preserve">
    <value>For foreign key {fkName} on table {tableName}, unable to model the end of the foreign key on principal table {principaltableName}. This is usually because the principal table was not included in the selection set.</value>
    <comment>Warning SqlServerEventId.ForeignKeyReferencesMissingPrincipalTableWarning string string string</comment>
  </data>
  <data name="LogMissingSchema" xml:space="preserve">
    <value>Unable to find a schema in the database matching the selected schema {schema}.</value>
    <comment>Warning SqlServerEventId.MissingSchemaWarning string</comment>
  </data>
  <data name="LogMissingTable" xml:space="preserve">
    <value>Unable to find a table in the database matching the selected table {table}.</value>
    <comment>Warning SqlServerEventId.MissingTableWarning string</comment>
  </data>
  <data name="LogFoundSequence" xml:space="preserve">
    <value>Found sequence name: {name}, data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.</value>
    <comment>Debug SqlServerEventId.SequenceFound string string bool int long long long</comment>
  </data>
  <data name="LogFoundTable" xml:space="preserve">
    <value>Found table with name: {name}.</value>
    <comment>Debug SqlServerEventId.TableFound string</comment>
  </data>
  <data name="NoInitialCatalog" xml:space="preserve">
    <value>The database name could not be determined. To use EnsureDeleted, the connection string must specify Initial Catalog.</value>
  </data>
  <data name="DuplicateColumnNameValueGenerationStrategyMismatch" xml:space="preserve">
    <value>'{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different value generation strategies.</value>
  </data>
  <data name="LogFoundIndex" xml:space="preserve">
    <value>Found index with name: {indexName}, table: {tableName}, is unique: {isUnique}.</value>
    <comment>Debug SqlServerEventId.IndexFound string string bool</comment>
  </data>
  <data name="LogFoundPrimaryKey" xml:space="preserve">
    <value>Found primary key with name: {primaryKeyName}, table: {tableName}.</value>
    <comment>Debug SqlServerEventId.PrimaryKeyFound string string</comment>
  </data>
  <data name="LogFoundUniqueConstraint" xml:space="preserve">
    <value>Found unique constraint with name: {uniqueConstraintName}, table: {tableName}.</value>
    <comment>Debug SqlServerEventId.UniqueConstraintFound string string</comment>
  </data>
  <data name="LogPrincipalColumnNotFound" xml:space="preserve">
    <value>For foreign key {foreignKeyName} on table {tableName}, unable to find the column called {principalColumnName} on the foreign key's principal table, {principaltableName}. Skipping foreign key.</value>
    <comment>Warning SqlServerEventId.ForeignKeyPrincipalColumnMissingWarning string string string string</comment>
  </data>
  <data name="InvalidTableToIncludeInScaffolding" xml:space="preserve">
    <value>The specified table '{table}' is not valid. Specify tables using the format '[schema].[table]'.</value>
  </data>
  <data name="FreeTextFunctionOnClient" xml:space="preserve">
    <value>The 'FreeText' method is not supported because the query has switched to client-evaluation. Inspect the log to determine which query expressions are triggering client-evaluation.</value>
  </data>
  <data name="InvalidColumnNameForFreeText" xml:space="preserve">
    <value>The expression passed to the 'propertyReference' parameter of the 'FreeText' method is not a valid reference to a property. The expression should represent a reference to a full-text indexed property on the object referenced in the from clause: 'from e in context.Entities where EF.Functions.FreeText(e.SomeProperty, textToSearchFor) select e'</value>
  </data>
  <data name="IncludePropertyDuplicated" xml:space="preserve">
    <value>Include property '{entityType}.{property}' cannot be defined multiple times</value>
  </data>
  <data name="IncludePropertyInIndex" xml:space="preserve">
    <value>Include property '{entityType}.{property}' is already included in the index</value>
  </data>
  <data name="IncludePropertyNotFound" xml:space="preserve">
    <value>Include property '{entityType}.{property}' not found</value>
  </data>
  <data name="ContainsFunctionOnClient" xml:space="preserve">
    <value>The 'Contains' method is not supported because the query has switched to client-evaluation. Inspect the log to determine which query expressions are triggering client-evaluation.</value>
  </data>
  <data name="LogReflexiveConstraintIgnored" xml:space="preserve">
    <value>Skipping foreign key '{foreignKeyName}' on table '{tableName}' since all of its columns reference themselves.</value>
    <comment>Debug SqlServerEventId.ReflexiveConstraintIgnored string string</comment>
  </data>
  <data name="DuplicateKeyMismatchedClustering" xml:space="preserve">
    <value>The keys {key1} on '{entityType1}' and {key2} on '{entityType2}' are both mapped to '{table}.{keyName}' but with different clustering.</value>
  </data>
</root>