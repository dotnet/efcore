<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// <auto-generated />

namespace Microsoft.EntityFrameworkCore.Query.Internal;

/// <summary>
///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
///     the same compatibility standards as public APIs. It may be changed or removed without notice in
///     any release. You should only use it directly in your code with extreme caution and knowing that
///     doing so can result in application failures when updating to a new Entity Framework Core release.
/// </summary>
public class CompiledQuery<TContext, TResult> : CompiledQueryBase<TContext, TResult>
    where TContext : DbContext
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public CompiledQuery(LambdaExpression queryExpression)
        : base(queryExpression)
    {
    }

<#
    const int maxParameters = 15;

    for (var parameterCount = 0; parameterCount <= maxParameters; parameterCount++)
    {
        var typeArgumentsList = parameterCount == 0
            ? ""
            : "<" + string.Join(", ", Enumerable.Range(1, parameterCount).Select(e => "TParam" + e)) + ">";
        var parameterList = string.Join("", Enumerable.Range(1, parameterCount).Select(e => $", TParam{e} param{e}"));
        var argumentList = string.Join("", Enumerable.Range(1, parameterCount).Select(e => $", param{e}"));
#>
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public virtual TResult Execute<#= typeArgumentsList #>(
        TContext context<#= parameterList #>)
        => ExecuteCore(context<#= argumentList #>);

<#
    }
#>
    /// <inheritdoc />
    protected override Func<QueryContext, TResult> CreateCompiledQuery(
        IQueryCompiler queryCompiler, Expression expression)
        => queryCompiler.CreateCompiledQuery<TResult>(expression);
}
