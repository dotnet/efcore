<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgumentIsEmpty" xml:space="preserve">
    <value>The string argument '{argumentName}' cannot be empty.</value>
  </data>
  <data name="CircularDependency" xml:space="preserve">
    <value>Unable to save changes because a circular dependency was detected in the data to be saved: '{cycle}'.</value>
  </data>
  <data name="InvalidEnumValue" xml:space="preserve">
    <value>The value provided for argument '{argumentName}' must be a valid value of enum type '{enumType}'.</value>
  </data>
  <data name="InvalidPropertiesExpression" xml:space="preserve">
    <value>The properties expression '{expression}' is not valid. The expression should represent a property access: 't =&gt; t.MyProperty'. When specifying multiple properties use an anonymous type: 't =&gt; new {{ t.MyProperty1, t.MyProperty2 }}'.</value>
  </data>
  <data name="InvalidPropertyExpression" xml:space="preserve">
    <value>The expression '{expression}' is not a valid property expression. The expression should represent a property access: 't =&gt; t.MyProperty'.</value>
  </data>
  <data name="IdentityConflict" xml:space="preserve">
    <value>The instance of entity type '{entityType}' cannot be tracked because another instance with the same key value for {keyProperties} is already being tracked. When attaching existing entities, ensure that only one entity instance with a given key value is attached. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting key values.</value>
  </data>
  <data name="IdentityConflictSensitive" xml:space="preserve">
    <value>The instance of entity type '{entityType}' cannot be tracked because another instance with the key value '{keyValue}' is already being tracked. When attaching existing entities, ensure that only one entity instance with a given key value is attached.</value>
  </data>
  <data name="WrongStateManager" xml:space="preserve">
    <value>Cannot start tracking InternalEntityEntry for entity type '{entityType}' because it was created by a different StateManager instance.</value>
  </data>
  <data name="MultipleEntries" xml:space="preserve">
    <value>Cannot start tracking InternalEntityEntry for entity type '{entityType}' because another InternalEntityEntry is already tracking the same entity.</value>
  </data>
  <data name="PropertyNotFound" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' could not be found. Ensure that the property exists and has been included in the model.</value>
  </data>
  <data name="PropertyIsNavigation" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is being accessed using the '{PropertyMethod}' method, but is defined in the model as a navigation property. Use either the '{ReferenceMethod}' or '{CollectionMethod}' method to access navigation properties.</value>
  </data>
  <data name="NavigationIsProperty" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is being accessed using the '{ReferenceMethod}' or '{CollectionMethod}' method, but is defined in the model as a non-navigation property. Use the '{PropertyMethod}' method to access non-navigation properties.</value>
  </data>
  <data name="ReferenceIsCollection" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is being accessed using the '{ReferenceMethod}' method, but is defined in the model as a collection navigation property. Use the '{CollectionMethod}' method to access collection navigation properties.</value>
  </data>
  <data name="CollectionIsReference" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is being accessed using the '{CollectionMethod}' method, but is defined in the model as a non-collection, reference navigation property. Use the '{ReferenceMethod}' method to access reference navigation properties.</value>
  </data>
  <data name="ReferenceMustBeLoaded" xml:space="preserve">
    <value>Navigation property '{navigation}' on entity type '{entityType}' cannot have 'IsLoaded' set to false because the referenced entity is non-null and therefore is loaded.</value>
  </data>
  <data name="CannotLoadDetached" xml:space="preserve">
    <value>Navigation property '{navigation}' on entity of type '{entityType}' cannot be loaded because the entity is not being tracked. Navigation properties can only be loaded for tracked entities.</value>
  </data>
  <data name="CollectionArgumentIsEmpty" xml:space="preserve">
    <value>The collection argument '{argumentName}' must contain at least one element.</value>
  </data>
  <data name="EntityRequiresKey" xml:space="preserve">
    <value>The entity type '{entityType}' requires a primary key to be defined.</value>
  </data>
  <data name="KeyPropertiesWrongEntity" xml:space="preserve">
    <value>The specified key properties {key} are not declared on the entity type '{entityType}'. Ensure key properties are declared on the target entity type.</value>
  </data>
  <data name="ForeignKeyPropertiesWrongEntity" xml:space="preserve">
    <value>The specified foreign key properties {foreignKey} are not declared on the entity type '{entityType}'. Ensure foreign key properties are declared on the target entity type.</value>
  </data>
  <data name="IndexPropertiesWrongEntity" xml:space="preserve">
    <value>The specified index properties {index} are not declared on the entity type '{entityType}'. Ensure index properties are declared on the target entity type.</value>
  </data>
  <data name="IQueryableNotAsync" xml:space="preserve">
    <value>The source IQueryable doesn't implement IAsyncEnumerable&lt;{genericParameter}&gt;. Only sources that implement IAsyncEnumerable can be used for Entity Framework asynchronous operations.</value>
  </data>
  <data name="IQueryableProviderNotAsync" xml:space="preserve">
    <value>The provider for the source IQueryable doesn't implement IAsyncQueryProvider. Only providers that implement IEntityQueryProvider can be used for Entity Framework asynchronous operations.</value>
  </data>
  <data name="ChangeTrackingInterfaceMissing" xml:space="preserve">
    <value>The entity type '{entityType}' is configured to use the '{changeTrackingStrategy}' change tracking strategy but does not implement the required '{notificationInterface}' interface.</value>
  </data>
  <data name="NonNotifyingCollection" xml:space="preserve">
    <value>The collection type being used for navigation property '{navigation}' on entity type '{entityType}' does not implement 'INotifyCollectionChanged'. Any entity type configured to use the '{changeTrackingStrategy}' change tracking strategy must use collections that implement 'INotifyCollectionChanged'. Consider using 'ObservableCollection&lt;T&gt;' for this.</value>
  </data>
  <data name="ResetNotSupported" xml:space="preserve">
    <value>'ObservableCollection&lt;T&gt;.Clear()' is not supported because it uses the 'INotifyCollectionChanged' 'Reset' operation, which does not supply the items removed. Either use multiple calls to 'Remove' or use a notifying collection that supports 'Clear', such as 'Microsoft.EntityFrameworkCore.ChangeTracking.ObservableHashSet&lt;T&gt;'.</value>
  </data>
  <data name="OriginalValueNotTracked" xml:space="preserve">
    <value>The original value for property '{property}' of entity type '{entityType}' cannot be accessed because it is not being tracked. Original values are not recorded for most properties of entities when the 'ChangingAndChangedNotifications' strategy is used. To access all original values use a different change tracking strategy such as 'ChangingAndChangedNotificationsWithOriginalValues'.</value>
  </data>
  <data name="ValueCannotBeNull" xml:space="preserve">
    <value>The value for property '{property}' of entity type '{entityType}' cannot be set to null because its type is '{propertyType}' which is not a nullable type.</value>
  </data>
  <data name="InvalidType" xml:space="preserve">
    <value>The value for property '{property}' of entity type '{entityType}' cannot be set to a value of type '{valueType}' because its type is '{propertyType}'.</value>
  </data>
  <data name="PropertyDoesNotBelong" xml:space="preserve">
    <value>The property '{property}' belongs to entity type '{entityType}' but is being used with an instance of entity type '{expectedType}'.</value>
  </data>
  <data name="MissingBackingField" xml:space="preserve">
    <value>The specified field '{field}' could not be found for property '{property}' on entity type '{entityType}'.</value>
  </data>
  <data name="BadBackingFieldType" xml:space="preserve">
    <value>The specified field '{field}' of type '{fieldType}' cannot be used for the property '{entityType}.{property}' of type '{propertyType}'. Only backing fields of types that are assignable from the property type can be used.</value>
  </data>
  <data name="NoBackingField" xml:space="preserve">
    <value>No field was found backing property '{property}' of entity type '{entity}'. Either configure a backing field or use a different '{pam}'.</value>
  </data>
  <data name="NoFieldOrSetter" xml:space="preserve">
    <value>No backing field could be found for property '{property}' of entity type '{entity}' and the property does not have a setter.</value>
  </data>
  <data name="NoFieldOrGetter" xml:space="preserve">
    <value>No backing field could be found for property '{property}' of entity type '{entity}' and the property does not have a getter.</value>
  </data>
  <data name="ReadonlyField" xml:space="preserve">
    <value>Field '{field}' of entity type '{entity}' is readonly and so cannot be set.</value>
  </data>
  <data name="NoProperty" xml:space="preserve">
    <value>No property was associated with field '{field}' of entity type '{entity}'. Either configure a property or use a different '{pam}'.</value>
  </data>
  <data name="NoSetter" xml:space="preserve">
    <value>The property '{property}' of entity type '{entity}' does not have a setter. Either make the property writable or use a different '{pam}'.</value>
  </data>
  <data name="NoGetter" xml:space="preserve">
    <value>The property '{property}' of entity type '{entity}' does not have a getter. Either make the property readable or use a different '{pam}'.</value>
  </data>
  <data name="NoClrType" xml:space="preserve">
    <value>The CLR entity materializer cannot be used for entity type '{entityType}' because it is a shadow state entity type.  Materialization to a CLR type is only possible for entity types that have a corresponding CLR type.</value>
  </data>
  <data name="MultipleProvidersConfigured" xml:space="preserve">
    <value>Services for database providers {storeNames} have been registered in the service provider. Only a single database provider can be registered in a service provider. If possible, ensure that Entity Framework is managing its service provider by removing the call to UseInternalServiceProvider. Otherwise, consider conditionally registering the database provider, or maintaining one service provider per database provider.</value>
  </data>
  <data name="DbContextMissingConstructor" xml:space="preserve">
    <value>AddDbContext was called with configuration, but the context type '{contextType}' only declares a parameterless constructor. This means that the configuration passed to AddDbContext will never be used. If configuration is passed to AddDbContext, then '{contextType}' should declare a constructor that accepts a DbContextOptions&lt;{contextType}&gt; and must pass it to the base constructor for DbContext.</value>
  </data>
  <data name="NoProviderConfigured" xml:space="preserve">
    <value>No database provider has been configured for this DbContext. A provider can be configured by overriding the DbContext.OnConfiguring method or by using AddDbContext on the application service provider. If AddDbContext is used, then also ensure that your DbContext type accepts a DbContextOptions&lt;TContext&gt; object in its constructor and passes it to the base constructor for DbContext.</value>
  </data>
  <data name="NoEfServices" xml:space="preserve">
    <value>Entity Framework services have not been added to the internal service provider. Either remove the call to UseInternalServiceProvider so that EF will manage its own internal services, or use the method from your database provider to add the required services to the service provider (e.g. AddEntityFrameworkSqlServer).</value>
  </data>
  <data name="InvalidReplaceService" xml:space="preserve">
    <value>A call was made to '{replaceService}', but Entity Framework is not building its own internal service provider. Either allow EF to build the service provider by removing the call to '{useInternalServiceProvider}', or build replacement services into the service provider before passing it to '{useInternalServiceProvider}'.</value>
  </data>
  <data name="InvalidUseService" xml:space="preserve">
    <value>A call was made to '{useService}', but Entity Framework is not building its own internal service provider. Either allow EF to build the service provider by removing the call to '{useInternalServiceProvider}', or build the '{service}' services to use into the service provider before passing it to '{useInternalServiceProvider}'.</value>
  </data>
  <data name="SingletonOptionChanged" xml:space="preserve">
    <value>A call was made to '{optionCall}' that changed an option that must be constant within a service provider, but Entity Framework is not building its own internal service provider. Either allow EF to build the service provider by removing the call to '{useInternalServiceProvider}', or ensure that the configuration for '{optionCall}' does not change for all uses of a given service provider passed to '{useInternalServiceProvider}'.</value>
  </data>
  <data name="LogServiceProviderCreated" xml:space="preserve">
    <value>An 'IServiceProvider' was created for internal use by Entity Framework.</value>
    <comment>Debug CoreEventId.ServiceProviderCreated</comment>
  </data>
  <data name="LogManyServiceProvidersCreated" xml:space="preserve">
    <value>More than twenty 'IServiceProvider' instances have been created for internal use by Entity Framework. Consider reviewing calls on 'DbContextOptionsBuilder' that may require new service providers to be built.</value>
    <comment>Warning CoreEventId.ManyServiceProvidersCreatedWarning</comment>
  </data>
  <data name="LogContextInitialized" xml:space="preserve">
    <value>Entity Framework Core {version} initialized '{contextType}' using provider '{provider}' with options: {options}</value>
    <comment>Information CoreEventId.ContextInitialized string string string string</comment>
  </data>
  <data name="NotAnEFService" xml:space="preserve">
    <value>The database provider attempted to register an implementation of the '{service}' service. This is not a service defined by EF and as such must be registered as a provider-specific service using the 'TryAddProviderSpecificServices' method.</value>
  </data>
  <data name="ImplementationTypeRequired" xml:space="preserve">
    <value>The implementation type for the registration of the '{service}' service could not be determined. Specific implementation types must be used for services that expect multiple registrations so as to avoid duplicates.</value>
  </data>
  <data name="SingletonRequired" xml:space="preserve">
    <value>An attempt was made to register an instance for the '{scope}' service '{service}'. Instances can only be registered for 'Singleton' services.</value>
  </data>
  <data name="NoValueGenerator" xml:space="preserve">
    <value>The '{property}' on entity type '{entityType}' does not have a value set and no value generator is available for properties of type '{propertyType}'. Either set a value for the property before adding the entity or configure a value generator for properties of type '{propertyType}'.</value>
  </data>
  <data name="BadDependencyRegistration" xml:space="preserve">
    <value>The service dependencies type '{dependenciesType}' has been registered innapropriately in the service collection. Service dependencies types must only be registered by Entity Framework, or in rare cases by database providers and then only to change the service lifetime.</value>
  </data>
  <data name="BadValueGeneratorType" xml:space="preserve">
    <value>The type '{givenType}' cannot be used a a value generator because it does not inherit from '{expectedType}'.</value>
  </data>
  <data name="CannotCreateValueGenerator" xml:space="preserve">
    <value>Cannot create instance of value generator type '{generatorType}'. Ensure that the type is instantiable and has a parameterless constructor, or use the overload of HasValueGenerator that accepts a delegate.</value>
  </data>
  <data name="TempValuePersists" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' has a temporary value while attempting to change the entity's state to '{state}'. Either set a permanent value explicitly or ensure that the database is configured to generate values for this property.</value>
  </data>
  <data name="LogExceptionDuringQueryIteration" xml:space="preserve">
    <value>An exception occurred in the database while iterating the results of a query for context type '{contextType}'.{newline}{error}</value>
    <comment>Error CoreEventId.QueryIterationFailed Type string Exception</comment>
  </data>
  <data name="LogExceptionDuringSaveChanges" xml:space="preserve">
    <value>An exception occurred in the database while saving changes for context type '{contextType}'.{newline}{error}</value>
    <comment>Error CoreEventId.SaveChangesFailed Type string Exception</comment>
  </data>
  <data name="PropertyMethodInvoked" xml:space="preserve">
    <value>The EF.Property&lt;T&gt; method may only be used within LINQ queries.</value>
  </data>
  <data name="DuplicateProperty" xml:space="preserve">
    <value>The property '{property}' cannot be added to the entity type '{entityType}' because a property with the same name already exists on entity type '{duplicateEntityType}'.</value>
  </data>
  <data name="PropertyWrongClrType" xml:space="preserve">
    <value>The property '{property}' cannot be added to type '{entityType}' because the type of the corresponding CLR property or field '{clrType}' does not match the specified type '{propertyType}'.</value>
  </data>
  <data name="ClrPropertyOnShadowEntity" xml:space="preserve">
    <value>The property '{property}' cannot exist on type '{entityType}' because the type is marked as shadow state while the property is not. Shadow state types can only contain shadow state properties.</value>
  </data>
  <data name="PropertyInUseKey" xml:space="preserve">
    <value>The property '{property}' cannot be removed from entity type '{entityType}' because it is being used in the key {key}. All containing keys must be removed or redefined before the property can be removed.</value>
  </data>
  <data name="KeyInUse" xml:space="preserve">
    <value>Cannot remove key {key} from entity type '{entityType}' because it is referenced by a foreign key in entity type '{dependentType}'. All foreign keys must be removed or redefined before the referenced key can be removed.</value>
  </data>
  <data name="DuplicateNavigation" xml:space="preserve">
    <value>The navigation property '{navigation}' cannot be added to the entity type '{entityType}' because a navigation property with the same name already exists on entity type '{duplicateEntityType}'.</value>
  </data>
  <data name="NoClrNavigation" xml:space="preserve">
    <value>The navigation property '{navigation}' cannot be added to the entity type '{entityType}' because there is no corresponding CLR property on the underlying type and navigations properties cannot be added to shadow state.</value>
  </data>
  <data name="NavigationSingleWrongClrType" xml:space="preserve">
    <value>The navigation property '{navigation}' cannot be added to the entity type '{entityType}' because its CLR type '{clrType}' does not match the expected CLR type '{targetType}'.</value>
  </data>
  <data name="NavigationCollectionWrongClrType" xml:space="preserve">
    <value>The collection navigation property '{navigation}' cannot be added to the entity type '{entityType}' because its CLR type '{clrType}' does not implement 'IEnumerable&lt;{targetType}&gt;'. Collection navigation properties must implement IEnumerable&lt;&gt; of the related entity.</value>
  </data>
  <data name="ForeignKeyCountMismatch" xml:space="preserve">
    <value>The number of properties specified for the foreign key {foreignKey} on entity type '{dependentType}' does not match the number of properties in the principal key {principalKey} on entity type '{principalType}'.</value>
  </data>
  <data name="ForeignKeyTypeMismatch" xml:space="preserve">
    <value>The types of the properties specified for the foreign key {foreignKey} on entity type '{dependentType}' do not match the types of the properties in the principal key {principalKey} on entity type '{principalType}'.</value>
  </data>
  <data name="NavigationBadType" xml:space="preserve">
    <value>The type of navigation property '{navigation}' on the entity type '{entityType}' is '{foundType}' which does not implement ICollection&lt;{targetType}&gt;. Collection navigation properties must implement ICollection&lt;&gt; of the target type.</value>
  </data>
  <data name="NavigationArray" xml:space="preserve">
    <value>The type of navigation property '{navigation}' on the entity type '{entityType}' is '{foundType}' which is an array type.. Collection navigation properties cannot be arrays.</value>
  </data>
  <data name="NavigationNoSetter" xml:space="preserve">
    <value>The navigation property '{navigation}' on the entity type '{entityType}' does not have a setter and no writable backing field was found or specified. Read-only collection navigation properties must be initialized before use.</value>
  </data>
  <data name="NavigationCannotCreateType" xml:space="preserve">
    <value>The type of navigation property '{navigation}' on the entity type '{entityType}' is '{foundType}' for which it was not possible to create a concrete instance. Either initialize the property before use, add a public parameterless constructor to the type, or use a type which can be assigned a HashSet&lt;&gt; or List&lt;&gt;.</value>
  </data>
  <data name="KeyReadOnly" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is part of a key and so cannot be modified or marked as modified. To change the principal of an existing entity with an identifying foreign key first delete the dependent and invoke 'SaveChanges' then associate the dependent with the new principal.</value>
  </data>
  <data name="PropertyReadOnlyAfterSave" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is defined to be read-only after it has been saved, but its value has been modified or marked as modified.</value>
  </data>
  <data name="PropertyReadOnlyBeforeSave" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is defined to be read-only before it is saved, but its value has been set to something other than a temporary or default value.</value>
  </data>
  <data name="KeyPropertyMustBeReadOnly" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' must be marked as read-only after it has been saved because it is part of a key. Key properties are always read-only once an entity has been saved for the first time.</value>
  </data>
  <data name="RelationshipConceptualNull" xml:space="preserve">
    <value>The association between entity types '{firstType}' and '{secondType}' has been severed but the foreign key for this relationship cannot be set to null. If the dependent entity should be deleted, then setup the relationship to use cascade deletes.</value>
  </data>
  <data name="PropertyConceptualNull" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' is marked as null, but this cannot be saved because the property is marked as required.</value>
  </data>
  <data name="DuplicateForeignKey" xml:space="preserve">
    <value>The foreign key {foreignKey} cannot be added to the entity type '{entityType}' because a foreign key on the same properties already exists on entity type '{duplicateEntityType}' and also targets the key {key} on '{principalType}'.</value>
  </data>
  <data name="DuplicateIndex" xml:space="preserve">
    <value>The index {index} cannot be added to the entity type '{entityType}' because an index on the same properties already exists on entity type '{duplicateEntityType}'.</value>
  </data>
  <data name="DuplicateKey" xml:space="preserve">
    <value>The key {key} cannot be added to the entity type '{entityType}' because a key on the same properties already exists on entity type '{duplicateEntityType}'.</value>
  </data>
  <data name="NavigationToShadowEntity" xml:space="preserve">
    <value>The navigation property '{navigation}' cannot be added to the entity type '{entityType}' because the target entity type '{targetType}' is defined in shadow state and navigations properties cannot point to shadow state entities.</value>
  </data>
  <data name="EntityTypeNotInRelationship" xml:space="preserve">
    <value>The specified entity type '{entityType}' is invalid. It should be either the dependent entity type '{dependentType}' or the principal entity type '{principalType}' or an entity type derived from one of them.</value>
  </data>
  <data name="DuplicateEntityType" xml:space="preserve">
    <value>The entity type '{entityType}' cannot be added to the model because an entity type with the same name already exists.</value>
  </data>
  <data name="DuplicateAnnotation" xml:space="preserve">
    <value>The annotation '{annotation}' cannot be added because an annotation with the same name already exists.</value>
  </data>
  <data name="AnnotationNotFound" xml:space="preserve">
    <value>The annotation '{annotation}' was not found. Ensure that the annotation has been added.</value>
  </data>
  <data name="IncludeBadNavigation" xml:space="preserve">
    <value>The property '{property}' is not a navigation property of entity type '{entityType}'. The 'Include(string)' method can only be used with a '.' separated list of navigation property names.</value>
  </data>
  <data name="LogCompilingQueryModel" xml:space="preserve">
    <value>Compiling query model: {newline}'{queryModel}'</value>
    <comment>Debug CoreEventId.QueryModelCompiling string string</comment>
  </data>
  <data name="LogOptimizedQueryModel" xml:space="preserve">
    <value>Optimized query model: {newline}'{queryModel}'</value>
    <comment>Debug CoreEventId.QueryModelOptimized string string</comment>
  </data>
  <data name="LogIncludingNavigation" xml:space="preserve">
    <value>Including navigation: '{navigation}'</value>
    <comment>Debug CoreEventId.NavigationIncluded string</comment>
  </data>
  <data name="LogQueryExecutionPlanned" xml:space="preserve">
    <value>{plan}</value>
    <comment>Debug CoreEventId.QueryExecutionPlanned string</comment>
  </data>
  <data name="CannotBeNullable" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' cannot be marked as nullable/optional because the type of the property is '{propertyType}' which is not a nullable type. Any property can be marked as non-nullable/required, but only properties of nullable types and which are not part of primary key can be marked as nullable/optional.</value>
  </data>
  <data name="KeyPropertyCannotBeNullable" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' cannot be marked as nullable/optional because it has been included in a key {key}.</value>
  </data>
  <data name="RecursiveOnModelCreating" xml:space="preserve">
    <value>An attempt was made to use the model while it was being created. A DbContext instance cannot be used inside OnModelCreating in any way that makes use of the model that is being created.</value>
  </data>
  <data name="RecursiveOnConfiguring" xml:space="preserve">
    <value>An attempt was made to use the context while it is being configured. A DbContext instance cannot be used inside OnConfiguring since it is still being configured at this point. This can happen if a second operation is started on this context before a previous operation completed. Any instance members are not guaranteed to be thread safe.</value>
  </data>
  <data name="EntityTypeInUseByReferencingForeignKey" xml:space="preserve">
    <value>The entity type '{entityType}' cannot be removed because it is being referenced by foreign key {foreignKey} on '{referencingEntityType}'. All referencing foreign keys must be removed or redefined before the entity type can be removed.</value>
  </data>
  <data name="ArgumentPropertyNull" xml:space="preserve">
    <value>The property '{property}' of the argument '{argument}' cannot be null.</value>
  </data>
  <data name="RelationshipCannotBeInverted" xml:space="preserve">
    <value>The principal and dependent ends of the relationship cannot be flipped once foreign key or principal key properties have been specified.</value>
  </data>
  <data name="InvalidEntityType" xml:space="preserve">
    <value>The entity type '{type}' provided for the argument '{argumentName}' must be a reference type.</value>
  </data>
  <data name="ReferencedShadowKey" xml:space="preserve">
    <value>The relationship from '{referencingEntityTypeOrNavigation}' to '{referencedEntityTypeOrNavigation}' with foreign key properties {foreignKeyPropertiesWithTypes} cannot target the primary key {primaryKeyPropertiesWithTypes} because it is not compatible. Configure a principal key or a set of compatible foreign key properties for this relationship.</value>
  </data>
  <data name="MutableKeyProperty" xml:space="preserve">
    <value>The property '{keyProperty}' cannot be configured as 'ValueGeneratedOnUpdate' or 'ValueGeneratedOnAddOrUpdate' because the key value cannot be changed after the entity has been added to the store.</value>
  </data>
  <data name="ExpressionParameterizationException" xml:space="preserve">
    <value>An exception was thrown while attempting to evaluate a LINQ query parameter expression. To show additional information call EnableSensitiveDataLogging() when overriding DbContext.OnConfiguring.</value>
  </data>
  <data name="InvalidValueGeneratorFactoryProperty" xml:space="preserve">
    <value>The '{factory}' cannot create a value generator for property '{property}' on entity type '{entityType}'. Only integer properties are supported.</value>
  </data>
  <data name="DerivedEntityTypeKey" xml:space="preserve">
    <value>A key cannot be configured on '{derivedType}' because it is a derived type. The key must be configured on the root type '{rootType}'. If you did not intend for '{rootType}' to be included in the model, ensure that it is not included in a DbSet property on your context, referenced in a configuration call to ModelBuilder, or referenced from a navigation property on a type that is included in the model.</value>
  </data>
  <data name="CircularInheritance" xml:space="preserve">
    <value>The entity type '{entityType}' cannot inherit from '{baseEntityType}' because '{baseEntityType}' is a descendent of '{entityType}'.</value>
  </data>
  <data name="DerivedEntityCannotHaveKeys" xml:space="preserve">
    <value>Unable to set a base type for entity type '{entityType}' because it has one or more keys defined.</value>
  </data>
  <data name="GraphDoesNotContainVertex" xml:space="preserve">
    <value>The edge cannot be added because the graph does not contain vertex '{vertex}'.</value>
  </data>
  <data name="CannotMaterializeAbstractType" xml:space="preserve">
    <value>Unable to create an instance of type entity type '{entityType}' because it is abstract. Either make it non-abstract or consider mapping at least one derived type.</value>
  </data>
  <data name="FindNotCompositeKey" xml:space="preserve">
    <value>Entity type '{entityType}' is defined with a single key property, but {valuesCount} values were passed to the 'DbSet.Find' method.</value>
  </data>
  <data name="FindValueCountMismatch" xml:space="preserve">
    <value>Entity type '{entityType}' is defined with a {propertiesCount}-part composite key, but {valuesCount} values were passed to the 'DbSet.Find' method.</value>
  </data>
  <data name="FindValueTypeMismatch" xml:space="preserve">
    <value>The key value at position {index} of the call to 'DbSet&lt;{entityType}&gt;.Find' was of type '{valueType}', which does not match the property type of '{propertyType}'.</value>
  </data>
  <data name="ForeignKeyReferencedEntityKeyMismatch" xml:space="preserve">
    <value>The provided principal entity key '{principalKey}' is not a key on the entity type '{principalEntityType}'.</value>
  </data>
  <data name="WrongGenericPropertyType" xml:space="preserve">
    <value>Property '{property}' on entity type '{entityType}' is of type '{actualType}' but the generic type provided is of type '{genericType}'.</value>
  </data>
  <data name="NonGenericOptions" xml:space="preserve">
    <value>The DbContextOptions passed to the {contextType} constructor must be a DbContextOptions&lt;{contextType}&gt;. When registering multiple DbContext types make sure that the constructor for each context type has a DbContextOptions&lt;TContext&gt; parameter rather than a non-generic DbContextOptions parameter.</value>
  </data>
  <data name="OptionsExtensionNotFound" xml:space="preserve">
    <value>Options extension of type '{optionsExtension}' not found.</value>
  </data>
  <data name="DuplicatePropertiesOnBase" xml:space="preserve">
    <value>The type '{entityType}' cannot have base type '{baseType}' because the properties '{derivedPropertyType}.{derivedProperty}' and '{basePropertyType}.{baseProperty}' are conflicting.</value>
  </data>
  <data name="CannotBeNullablePK" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' cannot be marked as nullable/optional because the property is a part of a key. Any property can be marked as non-nullable/required, but only properties of nullable types and which are not part of a key can be marked as nullable/optional.</value>
  </data>
  <data name="ForeignKeyCannotBeOptional" xml:space="preserve">
    <value>The foreign key {foreignKey} on entity type '{entityType}' cannot be marked as optional because it does not contain any property of a nullable type. Any foreign key can be marked as required, but only foreign keys with at least one property of a nullable type and which is not part of primary key can be marked as optional.</value>
  </data>
  <data name="ShadowEntity" xml:space="preserve">
    <value>Entity type '{entityType}' is in shadow-state. A valid model requires all entity types to have corresponding CLR type.</value>
  </data>
  <data name="CompositePKWithDataAnnotation" xml:space="preserve">
    <value>Entity type '{entityType}' has composite primary key defined with data annotations. To set composite primary key, use fluent API.</value>
  </data>
  <data name="DuplicateNavigationsOnBase" xml:space="preserve">
    <value>The type '{entityType}' cannot have base type '{baseType}' because both types include the navigations: {navigations}.</value>
  </data>
  <data name="EntityTypeModelMismatch" xml:space="preserve">
    <value>The entity types '{firstEntityType}' and '{secondEntityType}' do not belong to the same model.</value>
  </data>
  <data name="HiLoBadBlockSize" xml:space="preserve">
    <value>The block size used for Hi-Lo value generation must be positive. When the Hi-Lo generator is backed by a SQL sequence this means that the sequence increment must be positive.</value>
  </data>
  <data name="IntraHierarchicalAmbiguousTargetEntityType" xml:space="preserve">
    <value>The entity type related to '{entityType}' cannot be determined because the specified foreign key {foreignKey} references entity type '{principalEntityType}' that it is in the same hierarchy as the entity type that it is declared on '{dependentEntityType}'.</value>
  </data>
  <data name="NonClrBaseType" xml:space="preserve">
    <value>The entity type '{entityType}' cannot inherit from '{baseEntityType}' because '{baseEntityType}' is a shadow state entity type while '{entityType}' is not.</value>
  </data>
  <data name="NonShadowBaseType" xml:space="preserve">
    <value>The entity type '{entityType}' cannot inherit from '{baseEntityType}' because '{entityType}' is a shadow state entity type while '{baseEntityType}' is not.</value>
  </data>
  <data name="NotAssignableClrBaseType" xml:space="preserve">
    <value>The entity type '{entityType}' cannot inherit from '{baseEntityType}' because '{clrType}' is not a descendent of '{baseClrType}'.</value>
  </data>
  <data name="PropertyWrongEntityClrType" xml:space="preserve">
    <value>CLR property '{property}' cannot be added to entity type '{entityType}' because it is declared on the CLR type '{clrType}'.</value>
  </data>
  <data name="InvalidNavigationWithInverseProperty" xml:space="preserve">
    <value>The InversePropertyAttribute on property '{property}' on type '{entityType}' is not valid. The property '{referencedProperty}' is not a valid navigation property on the related type '{referencedEntityType}'. Ensure that the property exists and is a valid reference or collection navigation property.</value>
  </data>
  <data name="SelfReferencingNavigationWithInverseProperty" xml:space="preserve">
    <value>A relationship cannot be established from property '{property}' on type '{entityType}' to property '{referencedProperty}' on type '{referencedEntityType}'. Check the values in the InversePropertyAttribute to ensure relationship definitions are unique and reference from one navigation property to its corresponding inverse navigation property.</value>
  </data>
  <data name="DataBindingWithIListSource" xml:space="preserve">
    <value>Data binding directly to a store query is not supported. Instead populate a DbSet with data, for example by calling Load on the DbSet, and then bind to local data to avoid sending a query to the database each time the databound control iterates the data. For WPF bind to 'DbSet.Local.ToObservableCollection()'. For WinForms bind to 'DbSet.Local.ToBindingList()'. For ASP.NET WebForms bind to 'DbSet.ToList()' or use Model Binding.</value>
  </data>
  <data name="KeyAttributeOnDerivedEntity" xml:space="preserve">
    <value>The derived type '{derivedType}' cannot have KeyAttribute on property '{property}' since primary key can only be declared on the root type.</value>
  </data>
  <data name="InversePropertyMismatch" xml:space="preserve">
    <value>InversePropertyAttributes on navigation '{navigation}' in entity type '{entityType}' and on navigation '{referencedNavigation}' in entity type '{referencedEntityType}' are not pointing to each other.</value>
  </data>
  <data name="CompositeFkOnProperty" xml:space="preserve">
    <value>There are multiple properties pointing to navigation '{navigation}' in entity type '{entityType}'. To define composite foreign key using data annotations, use ForeignKeyAttribute on navigation.</value>
  </data>
  <data name="FkAttributeOnPropertyNavigationMismatch" xml:space="preserve">
    <value>The ForeignKeyAttributes on property '{property}' and navigation '{navigation}' in entity type '{entityType}' do not point at each other. The value of ForeignKeyAttribute on property should be navigation name and the value of ForeignKeyAttribute on navigation should be the foreign key property name.</value>
  </data>
  <data name="InvalidPropertyListOnNavigation" xml:space="preserve">
    <value>The property list specified using ForeignKeyAttribute on navigation '{navigation}' in entity type '{entityType}' is incorrect. The attribute value should be comma-separated list of property names.</value>
  </data>
  <data name="InvalidRelationshipUsingDataAnnotations" xml:space="preserve">
    <value>Invalid relationship has been specified using InverseProperty and ForeignKey. The navigation '{navigation}' in entity type '{entityType}' and the navigation '{referencedNavigation}' in entity type '{referencedEntityType}' are related by InversePropertyAttribute but the ForeignKeyAttribute specified for both navigations have different values.</value>
  </data>
  <data name="ConflictingNavigation" xml:space="preserve">
    <value>The property '{property}' cannot be added to the entity type '{entityType}' because a navigation property with the same name already exists on entity type '{duplicateEntityType}'.</value>
  </data>
  <data name="ConflictingProperty" xml:space="preserve">
    <value>The navigation property '{navigation}' cannot be added to the entity type '{entityType}' because a property with the same name already exists on entity type '{duplicateEntityType}'.</value>
  </data>
  <data name="EntityTypeNotInRelationshipStrict" xml:space="preserve">
    <value>The specified entity type '{entityType}' is invalid. It should be either the dependent entity type '{dependentType}' or the principal entity type '{principalType}'.</value>
  </data>
  <data name="EntityTypeInUseByDerived" xml:space="preserve">
    <value>The entity type '{entityType}' cannot be removed because '{derivedEntityType}' is derived from it. All derived entity types must be removed or redefined before the entity type can be removed.</value>
  </data>
  <data name="NavigationNotAdded" xml:space="preserve">
    <value>Unable to determine the relationship represented by navigation property '{entityType}.{navigation}' of type '{propertyType}'. Either manually configure the relationship, or ignore this property using the '[NotMapped]' attribute or by using 'EntityTypeBuilder.Ignore' in 'OnModelCreating'.</value>
  </data>
  <data name="PropertyNotAdded" xml:space="preserve">
    <value>The property '{entityType}.{property}' could not be mapped, because it is of type '{propertyType}' which is not a supported primitive type or a valid entity type. Either explicitly map this property, or ignore it using the '[NotMapped]' attribute or by using 'EntityTypeBuilder.Ignore' in 'OnModelCreating'.</value>
  </data>
  <data name="PropertyNotMapped" xml:space="preserve">
    <value>The property '{entityType}.{property}' is of type '{propertyType}' which is not supported by current database provider. Either change the property CLR type or ignore the property using the '[NotMapped]' attribute or by using 'EntityTypeBuilder.Ignore' in 'OnModelCreating'.</value>
  </data>
  <data name="InterfacePropertyNotAdded" xml:space="preserve">
    <value>The property '{entityType}.{navigation}' is of an interface type ('{propertyType}'). If it is a navigation property manually configure the relationship for this property by casting it to a mapped entity type, otherwise ignore the property using the '[NotMapped]' attribute or by using 'EntityTypeBuilder.Ignore' in 'OnModelCreating'.</value>
  </data>
  <data name="NavigationForWrongForeignKey" xml:space="preserve">
    <value>The navigation property '{navigation}' on entity type '{entityType}' cannot be associated with foreign key {targetFk} because it was created for foreign key {actualFk}.</value>
  </data>
  <data name="EntityTypeNotFound" xml:space="preserve">
    <value>The entity type '{entityType}' was not found. Ensure that the entity type has been added to the model.</value>
  </data>
  <data name="CustomMetadata" xml:space="preserve">
    <value>The extension method '{method}' is being used with a custom implementation of '{interfaceType}'. Use of custom implementations of the Entity Framework metadata interfaces is not supported. Consider deriving from '{concreteType}' instead. Please contact the Entity Framework team if you have a compelling case for a custom implementation of the metadata interfaces so that we can consider ways to achieve this.</value>
  </data>
  <data name="InvalidMemberInitBinding" xml:space="preserve">
    <value>Unhandled operation: MemberInitExpression binding is not a MemberAssignment</value>
  </data>
  <data name="InvalidKeyValue" xml:space="preserve">
    <value>Unable to track an entity of type '{entityType}' because primary key property '{keyProperty}' is null.</value>
  </data>
  <data name="InvalidAlternateKeyValue" xml:space="preserve">
    <value>Unable to track an entity of type '{entityType}' because alternate key property '{keyProperty}' is null. If the alternate key is not used in a relationship, then consider using a unique index instead. Unique indexes may contain nulls, while alternate keys must not.</value>
  </data>
  <data name="LogSensitiveDataLoggingEnabled" xml:space="preserve">
    <value>Sensitive data logging is enabled. Log entries and exception messages may include sensitive application data, this mode should only be enabled during development.</value>
    <comment>Warning CoreEventId.SensitiveDataLoggingEnabledWarning</comment>
  </data>
  <data name="ExpressionParameterizationExceptionSensitive" xml:space="preserve">
    <value>An exception was thrown while attempting to evaluate the LINQ query parameter expression '{expression}'.</value>
  </data>
  <data name="MultipleNavigationsSameFk" xml:space="preserve">
    <value>There are multiple navigations in entity type '{entityType}' which are pointing to same set of properties - '{propertyList}' using ForeignKeyAttribute.</value>
  </data>
  <data name="InconsistentInheritance" xml:space="preserve">
    <value>The entity type '{entityType}' should derive from '{baseEntityType}' to reflect the hierarchy of the corresponding CLR types.</value>
  </data>
  <data name="DependentEntityTypeNotInRelationship" xml:space="preserve">
    <value>You are configuring a relationship between '{dependentEntityType}' and '{principalEntityType}' but have specified a foreign key on '{entityType}'. The foreign key must be defined on a type that is part of the relationship.</value>
  </data>
  <data name="PrincipalEntityTypeNotInRelationship" xml:space="preserve">
    <value>You are configuring a relationship between '{dependentEntityType}' and '{principalEntityType}' but have specified a foreign key targeting '{entityType}'. The foreign key must be targeting a type that is part of the relationship.</value>
  </data>
  <data name="ForeignKeyPropertyInKey" xml:space="preserve">
    <value>The property '{property}' cannot be part of a foreign key on '{entityType}' because it has value generation enabled and is contained in the key {key} defined on a base entity type '{baseEntityType}'.</value>
  </data>
  <data name="KeyPropertyInForeignKey" xml:space="preserve">
    <value>The property '{property}' cannot be part of a key on '{entityType}' because it is contained in a foreign key defined on a derived entity type.</value>
  </data>
  <data name="NullableKey" xml:space="preserve">
    <value>A key on entity type '{entityType}' cannot contain the property '{property}' because it is nullable/optional. All properties on which a key is declared must be marked as non-nullable/required.</value>
  </data>
  <data name="ConcurrentMethodInvocation" xml:space="preserve">
    <value>A second operation started on this context before a previous operation completed. Any instance members are not guaranteed to be thread safe.</value>
  </data>
  <data name="EntityTypesNotInRelationship" xml:space="preserve">
    <value>The specified entity types '{invalidDependentType}' and '{invalidPrincipalType}' are invalid. They should be '{dependentType}' and '{principalType}' or entity types in the same hierarchy.</value>
  </data>
  <data name="InvalidSetType" xml:space="preserve">
    <value>Cannot create a DbSet for '{typeName}' because this type is not included in the model for the context.</value>
  </data>
  <data name="AmbiguousOneToOneRelationship" xml:space="preserve">
    <value>The child/dependent side could not be determined for the one-to-one relationship that was detected between '{dependentToPrincipalNavigationSpecification}' and '{principalToDependentNavigationSpecification}'. To identify the child/dependent side of the relationship, configure the foreign key property. If these navigations should not be part of the same relationship configure them without specifying the inverse. See http://go.microsoft.com/fwlink/?LinkId=724062 for more details.</value>
  </data>
  <data name="AmbiguousForeignKeyPropertyCandidates" xml:space="preserve">
    <value>Both relationships between '{firstDependentToPrincipalNavigationSpecification}' and '{firstPrincipalToDependentNavigationSpecification}' and between '{secondDependentToPrincipalNavigationSpecification}' and '{secondPrincipalToDependentNavigationSpecification}' could use {foreignKeyProperties} as the foreign key. To resolve this configure the foreign key properties explicitly on at least one of the relationships.</value>
  </data>
  <data name="InvalidComplexPropertyExpression" xml:space="preserve">
    <value>The property expression '{propertyAccessExpression}' is not valid. The expression should represent a property access: 't =&gt; t.MyProperty'. For more information on including related data, see http://go.microsoft.com/fwlink/?LinkID=746393.</value>
  </data>
  <data name="InvalidIncludeLambdaExpression" xml:space="preserve">
    <value>Lambda expression '{includeLambdaExpression}' is not valid for Include/ThenInclude result operator. The expression should represent a property access: 't =&gt; t.MyProperty'. Specify lambda parameter explicitly to access navigations on derived types: '(Derived t) =&gt; t.MyProperty'. For more information on including related data, see http://go.microsoft.com/fwlink/?LinkID=746393.</value>
  </data>
  <data name="AbstractLeafEntityType" xml:space="preserve">
    <value>The corresponding CLR type for entity type '{entityType}' is not instantiable and there is no derived entity type in the model that corresponds to a concrete CLR type.</value>
  </data>
  <data name="NoPropertyType" xml:space="preserve">
    <value>The property '{property}' cannot be added to the type '{entityType}' because there was no property type specified and there is no corresponding CLR property or field. To add a shadow state property the property type must be specified.</value>
  </data>
  <data name="TempValue" xml:space="preserve">
    <value>The property '{property}' on entity type '{entityType}' has a temporary value. Either set a permanent value explicitly or ensure that the database is configured to generate values for this property.</value>
  </data>
  <data name="DatabaseGeneratedNull" xml:space="preserve">
    <value>The database generated a null value for non-nullable property '{property}' of entity type '{entityType}'. Ensure value generation configuration in the database matches the configuration in the model.</value>
  </data>
  <data name="NoParameterlessConstructor" xml:space="preserve">
    <value>A parameterless constructor was not found on entity type '{entityType}'. In order to create an instance of '{entityType}' EF requires that a parameterless constructor be declared.</value>
  </data>
  <data name="LogIgnoredInclude" xml:space="preserve">
    <value>The Include operation for navigation '{include}' is unnecessary and was ignored because the navigation is not reachable in the final query results. See https://go.microsoft.com/fwlink/?linkid=850303 for more information.</value>
    <comment>Warning CoreEventId.IncludeIgnoredWarning string</comment>
  </data>
  <data name="ConflictingRelationshipNavigation" xml:space="preserve">
    <value>Cannot create a relationship between '{newPrincipalEntityType}.{newPrincipalNavigation}' and '{newDependentEntityType}.{newDependentNavigation}', because there already is a relationship between '{existingPrincipalEntityType}.{existingPrincipalNavigation}' and '{existingDependentEntityType}.{existingDependentNavigation}'. Navigation properties can only participate in a single relationship.</value>
  </data>
  <data name="WarningAsErrorTemplate" xml:space="preserve">
    <value>Warning as error exception for warning '{eventId}': {message} To suppress this Exception use the DbContextOptionsBuilder.ConfigureWarnings API. ConfigureWarnings can be used when overriding the DbContext.OnConfiguring method or using AddDbContext on the application service provider.</value>
  </data>
  <data name="ContextDisposed" xml:space="preserve">
    <value>Cannot access a disposed object. A common cause of this error is disposing a context that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling Dispose() on the context, or wrapping the context in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.</value>
  </data>
  <data name="NoProviderConfiguredFailedToResolveService" xml:space="preserve">
    <value>Unable to resolve service for type '{service}'. This is often because no database provider has been configured for this DbContext. A provider can be configured by overriding the DbContext.OnConfiguring method or by using AddDbContext on the application service provider. If AddDbContext is used, then also ensure that your DbContext type accepts a DbContextOptions&lt;TContext&gt; object in its constructor and passes it to the base constructor for DbContext.</value>
  </data>
  <data name="ErrorMaterializingProperty" xml:space="preserve">
    <value>An exception occurred while reading a database value for property '{entityType}.{property}'. See the inner exception for more information.</value>
  </data>
  <data name="ErrorMaterializingPropertyInvalidCast" xml:space="preserve">
    <value>An exception occurred while reading a database value for property '{entityType}.{property}'. The expected type was '{expectedType}' but the actual value was of type '{actualType}'.</value>
  </data>
  <data name="ErrorMaterializingPropertyNullReference" xml:space="preserve">
    <value>An exception occurred while reading a database value for property '{entityType}.{property}'. The expected type was '{expectedType}' but the actual value was null.</value>
  </data>
  <data name="ErrorMaterializingValue" xml:space="preserve">
    <value>An exception occurred while reading a database value. See the inner exception for more information.</value>
  </data>
  <data name="ErrorMaterializingValueInvalidCast" xml:space="preserve">
    <value>An exception occurred while reading a database value. The expected type was '{expectedType}' but the actual value was of type '{actualType}'.</value>
  </data>
  <data name="ErrorMaterializingValueNullReference" xml:space="preserve">
    <value>An exception occurred while reading a database value. The expected type was '{expectedType}' but the actual value was null.</value>
  </data>
  <data name="InheritedPropertyCannotBeIgnored" xml:space="preserve">
    <value>The property '{property}' cannot be ignored on entity type '{entityType}', because it's declared on the base entity type '{baseEntityType}'. To exclude this property from your model, use NotMappedAttribute or Ignore method on the base type.</value>
  </data>
  <data name="RetryLimitExceeded" xml:space="preserve">
    <value>Maximum number of retries ({retryLimit}) exceeded while executing database operations with '{strategy}'. See inner exception for the most recent failure.</value>
  </data>
  <data name="ExecutionStrategyExistingTransaction" xml:space="preserve">
    <value>The configured execution strategy '{strategy}' does not support user initiated transactions. Use the execution strategy returned by '{getExecutionStrategyMethod}' to execute all the operations in the transaction as a retriable unit.</value>
  </data>
  <data name="PropertyCalledOnNavigation" xml:space="preserve">
    <value>Cannot call Property for the property '{property}' on entity type '{entityType}' because it is configured as a navigation property. Property can only be used to configure scalar properties.</value>
  </data>
  <data name="LogRowLimitingOperationWithoutOrderBy" xml:space="preserve">
    <value>Query: '{queryModel}' uses a row limiting operation (Skip/Take) without OrderBy which may lead to unpredictable results.</value>
    <comment>Warning CoreEventId.RowLimitingOperationWithoutOrderByWarning string</comment>
  </data>
  <data name="PropertyInUseForeignKey" xml:space="preserve">
    <value>The property '{property}' cannot be removed from entity type '{entityType}' because it is being used in the foreign key {foreignKey} on '{foreignKeyType}'. All containing foreign keys must be removed or redefined before the property can be removed.</value>
  </data>
  <data name="PropertyInUseIndex" xml:space="preserve">
    <value>The property '{property}' cannot be removed from entity type '{entityType}' because it is being used in the index {index} on '{indexType}'. All containing indexes must be removed or redefined before the property can be removed.</value>
  </data>
  <data name="LogFirstWithoutOrderByAndFilter" xml:space="preserve">
    <value>Query: '{queryModel}' uses First/FirstOrDefault operation without OrderBy and filter which may lead to unpredictable results.</value>
    <comment>Warning CoreEventId.FirstWithoutOrderByAndFilterWarning string</comment>
  </data>
  <data name="InvalidPoolSize" xml:space="preserve">
    <value>The specified poolSize must be greater than 0.</value>
  </data>
  <data name="PoolingContextCtorError" xml:space="preserve">
    <value>The DbContext of type '{contextType}' cannot be pooled because it does not have a single public constructor accepting a single parameter of type DbContextOptions.</value>
  </data>
  <data name="PoolingOptionsModified" xml:space="preserve">
    <value>OnConfiguring cannot be used to modify DbContextOptions when DbContext pooling is enabled.</value>
  </data>
  <data name="ForeignKeySelfReferencingDependentEntityType" xml:space="preserve">
    <value>The foreign keys on entity type '{dependentType}' cannot target the same entity type because it is a dependent entity type.</value>
  </data>
  <data name="EntityTypeInUseByForeignKey" xml:space="preserve">
    <value>The entity type '{entityType}' cannot be removed because it is referencing '{referencedEntityType}' by foreign key {foreignKey}. All foreign keys must be removed before the entity type can be removed.</value>
  </data>
  <data name="ClashingDependentEntityType" xml:space="preserve">
    <value>The entity type '{entityType}' cannot be added to the model because a dependent entity type with the same name already exists.</value>
  </data>
  <data name="ClashingNonDependentEntityType" xml:space="preserve">
    <value>The dependent entity type '{entityType}' cannot be added to the model because an entity type with the same name already exists.</value>
  </data>
  <data name="DependentBaseType" xml:space="preserve">
    <value>The type '{entityType}' cannot have dependent entity type '{baseType}' as the base type.</value>
  </data>
  <data name="DependentDerivedType" xml:space="preserve">
    <value>The dependent entity type '{entityType}' cannot have a base type.</value>
  </data>
  <data name="DuplicatePropertyInList" xml:space="preserve">
    <value>The property list {propertyList} cannot be used, because it contains a duplicate - '{property}'.</value>
  </data>
  <data name="ConventionsInfiniteLoop" xml:space="preserve">
    <value>The convention invocations have reached the recursion limit. This is likely an issue in EF Core, please report it.</value>
  </data>
  <data name="NoDefiningNavigation" xml:space="preserve">
    <value>The navigation '{navigation}' used to define the entity type '{entityType}' is not present on '{definingEntityType}'.</value>
  </data>
  <data name="MultipleOwnerships" xml:space="preserve">
    <value>The entity type '{entityType}' is the target of multiple ownership relationships.</value>
  </data>
  <data name="NonDefiningOwnership" xml:space="preserve">
    <value>The ownership navigation '{ownershipNavigation}' should be the same as the defining navigation '{definingNavigation}' for entity type '{entityType}'</value>
  </data>
  <data name="InconsistentOwnership" xml:space="preserve">
    <value>The entity type '{ownedEntityType}' is configured as owned, but the entity type '{nonOwnedEntityType}' is not. All entity types sharin a CLR type must be configured as owned.</value>
  </data>
  <data name="InverseToOwnedType" xml:space="preserve">
    <value>The navigation '{principalEntityType}.{navigation}' is not supported because it is pointing to an owned entity type '{ownedType}'. Only the owner entity type can declare a navigation to an owned entity type.</value>
  </data>
  <data name="PrincipalOwnedType" xml:space="preserve">
    <value>The relationship from '{referencingEntityTypeOrNavigation}' to '{referencedEntityTypeOrNavigation}' is not supported because the owned entity type '{ownedType}' cannot be on the principal side.</value>
  </data>
  <data name="AmbiguousDependentEntity" xml:space="preserve">
    <value>The entity type '{entityType}' has a defining navigation and the supplied entity is currently referenced from several owner entities. To access the entry for a particular reference call '{targetEntryCall}' on the owner entry.</value>
  </data>
  <data name="UntrackedDependentEntity" xml:space="preserve">
    <value>The entity type '{entityType}' has a defining navigation and the supplied entity is currently not being tracked. To start tracking this entity call '{targetEntryCall}' on the owner entry.</value>
  </data>
  <data name="BadFilterExpression" xml:space="preserve">
    <value>The filter expression '{filter}' specified for entity type '{entityType}' is invalid. The expression must accept a single parameter of type '{clrType}', return bool, and may not contain references to navigation properties.</value>
  </data>
  <data name="BadFilterDerivedType" xml:space="preserve">
    <value>The filter expression '{filter}' cannot be specified for entity type '{entityType}'. A filter may only be applied to the root entity type in a hierarchy.</value>
  </data>
  <data name="IncludeNotSpecifiedDirectlyOnEntityType" xml:space="preserve">
    <value>The Include operation '{include}' is not supported. '{invalidNavigation}' must be a navigation property defined on an entity type.</value>
  </data>
  <data name="LogPossibleUnintendedCollectionNavigationNullComparison" xml:space="preserve">
    <value>Collection navigations are only considered null if their parent entity is null. Use '.Any()' to check whether collection navigation '{navigationPath}' is empty.</value>
    <comment>Warning CoreEventId.PossibleUnintendedCollectionNavigationNullComparisonWarning string</comment>
  </data>
  <data name="LogPossibleUnintendedReferenceComparison" xml:space="preserve">
    <value>Possible unintended reference comparison between '{left}' and '{right}'.</value>
    <comment>Warning CoreEventId.PossibleUnintendedReferenceComparisonWarning object object</comment>
  </data>
  <data name="LogDuplicateDependentEntityTypeInstance" xml:space="preserve">
    <value>The same entity is being tracked as different dependent entity types '{dependent1}' and '{dependent2}'. If a property value changes it will result in two store changes, which might not be the desired outcome.</value>
    <comment>Warning CoreEventId.DuplicateDependentEntityTypeInstanceWarning string string</comment>
  </data>
</root>