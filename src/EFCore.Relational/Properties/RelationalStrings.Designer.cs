// <auto-generated />

using System.Resources;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.Extensions.Logging;

#nullable enable

namespace Microsoft.EntityFrameworkCore.Diagnostics
{
    /// <summary>
    ///     <para>
    ///		    String resources used in EF exceptions, etc.
    ///     </para>
    ///     <para>
    ///		    These strings are exposed publicly for use by database providers and extensions.
    ///         It is unusual for application code to need these strings.
    ///     </para>
    /// </summary>
    public static class RelationalStrings
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalStrings", typeof(RelationalStrings).Assembly);

        /// <summary>
        ///     Unable to deserialize a sequence from model metadata. See inner exception for details.
        /// </summary>
        [Obsolete]
        public static string BadSequenceString
            => GetString("BadSequenceString");

        /// <summary>
        ///     Invalid type for sequence. Valid types are long (the default), int, short, byte and decimal.
        /// </summary>
        public static string BadSequenceType
            => GetString("BadSequenceType");

        /// <summary>
        ///     The instance of DbConnection is currently in use. The connection can only be changed when the existing connection is not being used.
        /// </summary>
        public static string CannotChangeWhenOpen
            => GetString("CannotChangeWhenOpen");

        /// <summary>
        ///     Unable to translate the given 'GroupBy' pattern. Call 'AsEnumerable' before 'GroupBy' to evaluate it client-side.
        /// </summary>
        public static string ClientGroupByNotSupported
            => GetString("ClientGroupByNotSupported");

        /// <summary>
        ///     The function parameter '{function}({parameter})' has a custom type mapping configured. Configure it in '{customize}' in a partial '{className}' class instead.
        /// </summary>
        public static string CompiledModelFunctionParameterTypeMapping(object? function, object? parameter, object? customize, object? className)
            => string.Format(
                GetString("CompiledModelFunctionParameterTypeMapping", nameof(function), nameof(parameter), nameof(customize), nameof(className)),
                function, parameter, customize, className);

        /// <summary>
        ///     The function '{function}' has a custom translation. Compiled model can't be generated, because custom function translations are not supported.
        /// </summary>
        public static string CompiledModelFunctionTranslation(object? function)
            => string.Format(
                GetString("CompiledModelFunctionTranslation", nameof(function)),
                function);

        /// <summary>
        ///     The function '{function}' has a custom type mapping configured. Configure it in '{customize}' in a partial '{className}' class instead.
        /// </summary>
        public static string CompiledModelFunctionTypeMapping(object? function, object? customize, object? className)
            => string.Format(
                GetString("CompiledModelFunctionTypeMapping", nameof(function), nameof(customize), nameof(className)),
                function, customize, className);

        /// <summary>
        ///     The computed column SQL has not been specified for the column '{table}.{column}'. Specify the SQL before using Entity Framework to create the database schema.
        /// </summary>
        public static string ComputedColumnSqlUnspecified(object? table, object? column)
            => string.Format(
                GetString("ComputedColumnSqlUnspecified", nameof(table), nameof(column)),
                table, column);

        /// <summary>
        ///     An ambient transaction has been detected. The ambient transaction needs to be completed before starting a new transaction on this connection.
        /// </summary>
        public static string ConflictingAmbientTransaction
            => GetString("ConflictingAmbientTransaction");

        /// <summary>
        ///     {conflictingConfiguration} cannot be set for '{property}' at the same time as {existingConfiguration}. Remove one of these configurations.
        /// </summary>
        public static string ConflictingColumnServerGeneration(object? conflictingConfiguration, object? property, object? existingConfiguration)
            => string.Format(
                GetString("ConflictingColumnServerGeneration", nameof(conflictingConfiguration), nameof(property), nameof(existingConfiguration)),
                conflictingConfiguration, property, existingConfiguration);

        /// <summary>
        ///     The connection is currently enlisted in a transaction. The enlisted transaction needs to be completed before starting a new transaction.
        /// </summary>
        public static string ConflictingEnlistedTransaction
            => GetString("ConflictingEnlistedTransaction");

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' and an instance of entity type '{secondEntityType}' are mapped to the same row, but have different original property values for the properties {firstProperty} and {secondProperty} mapped to '{column}'. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting values.
        /// </summary>
        public static string ConflictingOriginalRowValues(object? firstEntityType, object? secondEntityType, object? firstProperty, object? secondProperty, object? column)
            => string.Format(
                GetString("ConflictingOriginalRowValues", nameof(firstEntityType), nameof(secondEntityType), nameof(firstProperty), nameof(secondProperty), nameof(column)),
                firstEntityType, secondEntityType, firstProperty, secondProperty, column);

        /// <summary>
        ///     Instances of entity types '{firstEntityType}' and '{secondEntityType}' are mapped to the same row with the key value '{keyValue}', but have different original property values {firstConflictingValues} and {secondConflictingValues} for the column '{column}'.
        /// </summary>
        public static string ConflictingOriginalRowValuesSensitive(object? firstEntityType, object? secondEntityType, object? keyValue, object? firstConflictingValues, object? secondConflictingValues, object? column)
            => string.Format(
                GetString("ConflictingOriginalRowValuesSensitive", nameof(firstEntityType), nameof(secondEntityType), nameof(keyValue), nameof(firstConflictingValues), nameof(secondConflictingValues), nameof(column)),
                firstEntityType, secondEntityType, keyValue, firstConflictingValues, secondConflictingValues, column);

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' is marked as '{firstState}', but an instance of entity type '{secondEntityType}' is marked as '{secondState}' and both are mapped to the same row. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values.
        /// </summary>
        public static string ConflictingRowUpdateTypes(object? firstEntityType, object? firstState, object? secondEntityType, object? secondState)
            => string.Format(
                GetString("ConflictingRowUpdateTypes", nameof(firstEntityType), nameof(firstState), nameof(secondEntityType), nameof(secondState)),
                firstEntityType, firstState, secondEntityType, secondState);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' with the key value '{firstKeyValue}' is marked as '{firstState}', but the instance of entity type '{secondEntityType}' with the key value '{secondKeyValue}' is marked as '{secondState}' and both are mapped to the same row.
        /// </summary>
        public static string ConflictingRowUpdateTypesSensitive(object? firstEntityType, object? firstKeyValue, object? firstState, object? secondEntityType, object? secondKeyValue, object? secondState)
            => string.Format(
                GetString("ConflictingRowUpdateTypesSensitive", nameof(firstEntityType), nameof(firstKeyValue), nameof(firstState), nameof(secondEntityType), nameof(secondKeyValue), nameof(secondState)),
                firstEntityType, firstKeyValue, firstState, secondEntityType, secondKeyValue, secondState);

        /// <summary>
        ///     Instances of entity types '{firstEntityType}' and '{secondEntityType}' are mapped to the same row, but have different property values for the properties {firstProperty} and {secondProperty} mapped to '{column}'. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting values.
        /// </summary>
        public static string ConflictingRowValues(object? firstEntityType, object? secondEntityType, object? firstProperty, object? secondProperty, object? column)
            => string.Format(
                GetString("ConflictingRowValues", nameof(firstEntityType), nameof(secondEntityType), nameof(firstProperty), nameof(secondProperty), nameof(column)),
                firstEntityType, secondEntityType, firstProperty, secondProperty, column);

        /// <summary>
        ///     Instances of entity types '{firstEntityType}' and '{secondEntityType}' are mapped to the same row with the key value '{keyValue}', but have different property values '{firstConflictingValue}' and '{secondConflictingValue}' for the column '{column}'.
        /// </summary>
        public static string ConflictingRowValuesSensitive(object? firstEntityType, object? secondEntityType, object? keyValue, object? firstConflictingValue, object? secondConflictingValue, object? column)
            => string.Format(
                GetString("ConflictingRowValuesSensitive", nameof(firstEntityType), nameof(secondEntityType), nameof(keyValue), nameof(firstConflictingValue), nameof(secondConflictingValue), nameof(column)),
                firstEntityType, secondEntityType, keyValue, firstConflictingValue, secondConflictingValue, column);

        /// <summary>
        ///     The database model hasn't been initialized. The model needs to be finalized and processed with 'RelationalModelConvention' before the database model can be accessed.
        /// </summary>
        [Obsolete]
        public static string DatabaseModelMissing
            => GetString("DatabaseModelMissing");

        /// <summary>
        ///     There is no property mapped to the column '{table}.{column}' which is used in a data operation. Either add a property mapped to this column, or specify the column types in the data operation.
        /// </summary>
        public static string DataOperationNoProperty(object? table, object? column)
            => string.Format(
                GetString("DataOperationNoProperty", nameof(table), nameof(column)),
                table, column);

        /// <summary>
        ///     There is no entity type mapped to the table '{table}' which is used in a data operation. Either add the corresponding entity type to the model, or specify the column types in the data operation.
        /// </summary>
        public static string DataOperationNoTable(object? table)
            => string.Format(
                GetString("DataOperationNoTable", nameof(table)),
                table);

        /// <summary>
        ///     The provided DbFunction expression '{expression}' is invalid. The expression must be a lambda expression containing a single method call to the target static method. Default values can be provided as arguments if required, e.g. '() =&gt; SomeClass.SomeMethod(null, 0)'
        /// </summary>
        public static string DbFunctionExpressionIsNotMethodCall(object? expression)
            => string.Format(
                GetString("DbFunctionExpressionIsNotMethodCall", nameof(expression)),
                expression);

        /// <summary>
        ///     The DbFunction '{function}' is generic. Mapping generic methods as a DbFunction is not supported.
        /// </summary>
        public static string DbFunctionGenericMethodNotSupported(object? function)
            => string.Format(
                GetString("DbFunctionGenericMethodNotSupported", nameof(function)),
                function);

        /// <summary>
        ///     The DbFunction '{function}' defined on type '{type}' must be either a static method or an instance method defined on a DbContext subclass. Instance methods on other types are not supported.
        /// </summary>
        public static string DbFunctionInvalidInstanceType(object? function, object? type)
            => string.Format(
                GetString("DbFunctionInvalidInstanceType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     The DbFunction '{function}' has an invalid return type '{type}'. Owned entity types cannot be used as the return type of a DbFunction.
        /// </summary>
        public static string DbFunctionInvalidIQueryableOwnedReturnType(object? function, object? type)
            => string.Format(
                GetString("DbFunctionInvalidIQueryableOwnedReturnType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     The DbFunction '{function}' has an invalid return type '{type}'. Non-scalar functions must return 'IQueryable' of a valid entity type.
        /// </summary>
        public static string DbFunctionInvalidIQueryableReturnType(object? function, object? type)
            => string.Format(
                GetString("DbFunctionInvalidIQueryableReturnType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     The DbFunction '{function}' does not have a parameter named '{parameter}'.
        /// </summary>
        public static string DbFunctionInvalidParameterName(object? function, object? parameter)
            => string.Format(
                GetString("DbFunctionInvalidParameterName", nameof(function), nameof(parameter)),
                function, parameter);

        /// <summary>
        ///     The parameter '{parameter}' for the DbFunction '{function}' has an invalid type '{type}'. Ensure the parameter type can be mapped by the current provider.
        /// </summary>
        public static string DbFunctionInvalidParameterType(object? parameter, object? function, object? type)
            => string.Format(
                GetString("DbFunctionInvalidParameterType", nameof(parameter), nameof(function), nameof(type)),
                parameter, function, type);

        /// <summary>
        ///     The DbFunction '{function}' returns '{type}', but '{elementType}' is not a mapped entity type. Ensure that '{elementType}' is included in the model.
        /// </summary>
        public static string DbFunctionInvalidReturnEntityType(object? function, object? type, object? elementType)
            => string.Format(
                GetString("DbFunctionInvalidReturnEntityType", nameof(function), nameof(type), nameof(elementType)),
                function, type, elementType);

        /// <summary>
        ///     The DbFunction '{function}' has an invalid return type '{type}'. Ensure that the return type can be mapped by the current provider.
        /// </summary>
        public static string DbFunctionInvalidReturnType(object? function, object? type)
            => string.Format(
                GetString("DbFunctionInvalidReturnType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     Cannot set custom translation on the DbFunction '{function}' since it is not a scalar function.
        /// </summary>
        public static string DbFunctionNonScalarCustomTranslation(object? function)
            => string.Format(
                GetString("DbFunctionNonScalarCustomTranslation", nameof(function)),
                function);

        /// <summary>
        ///     The default value SQL has not been specified for the column '{table}.{column}'. Specify the SQL before using Entity Framework to create the database schema.
        /// </summary>
        public static string DefaultValueSqlUnspecified(object? table, object? column)
            => string.Format(
                GetString("DefaultValueSqlUnspecified", nameof(table), nameof(column)),
                table, column);

        /// <summary>
        ///     The default value has not been specified for the column '{table}.{column}'. Specify a value before using Entity Framework to create the database schema.
        /// </summary>
        public static string DefaultValueUnspecified(object? table, object? column)
            => string.Format(
                GetString("DefaultValueUnspecified", nameof(table), nameof(column)),
                table, column);

        /// <summary>
        ///     The data deletion operation on '{table}' is not associated with a model. Either add a model to the migration, or specify the column types in all data operations.
        /// </summary>
        public static string DeleteDataOperationNoModel(object? table)
            => string.Format(
                GetString("DeleteDataOperationNoModel", nameof(table)),
                table);

        /// <summary>
        ///     The number of key column types ({typesCount}) doesn't match the number of key columns ({columnsCount}) for the data deletion operation on '{table}'. Provide the same number of key column types and key columns.
        /// </summary>
        public static string DeleteDataOperationTypesCountMismatch(object? typesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("DeleteDataOperationTypesCountMismatch", nameof(typesCount), nameof(columnsCount), nameof(table)),
                typesCount, columnsCount, table);

        /// <summary>
        ///     The number of key values ({valuesCount}) doesn't match the number of key columns ({columnsCount}) for the data deletion operation on '{table}'. Provide the same number of key values and key columns.
        /// </summary>
        public static string DeleteDataOperationValuesCountMismatch(object? valuesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("DeleteDataOperationValuesCountMismatch", nameof(valuesCount), nameof(columnsCount), nameof(table)),
                valuesCount, columnsCount, table);

        /// <summary>
        ///     The entity type '{entityType}' cannot be mapped to a table because it is derived from '{baseType}'. Only base entity types can be mapped to a table.
        /// </summary>
        [Obsolete]
        public static string DerivedTypeTable(object? entityType, object? baseType)
            => string.Format(
                GetString("DerivedTypeTable", nameof(entityType), nameof(baseType)),
                entityType, baseType);

        /// <summary>
        ///     Using 'Distinct' operation on a projection containing a collection is not supported.
        /// </summary>
        public static string DistinctOnCollectionNotSupported
            => GetString("DistinctOnCollectionNotSupported");

        /// <summary>
        ///     The check constraint '{checkConstraint}' cannot be added to the entity type '{entityType}' because another check constraint with the same name already exists on entity type '{conflictingEntityType}'.
        /// </summary>
        public static string DuplicateCheckConstraint(object? checkConstraint, object? entityType, object? conflictingEntityType)
            => string.Format(
                GetString("DuplicateCheckConstraint", nameof(checkConstraint), nameof(entityType), nameof(conflictingEntityType)),
                checkConstraint, entityType, conflictingEntityType);

        /// <summary>
        ///     The check constraints '{checkConstraint1}' on '{entityType1}' and '{checkConstraint2}' on '{entityType2}' are both mapped to '{checkConstraintName}', but with different defining SQL.
        /// </summary>
        public static string DuplicateCheckConstraintSqlMismatch(object? checkConstraint1, object? entityType1, object? checkConstraint2, object? entityType2, object? checkConstraintName)
            => string.Format(
                GetString("DuplicateCheckConstraintSqlMismatch", nameof(checkConstraint1), nameof(entityType1), nameof(checkConstraint2), nameof(entityType2), nameof(checkConstraintName)),
                checkConstraint1, entityType1, checkConstraint2, entityType2, checkConstraintName);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured to use different collations ('{collation1}' and '{collation2}').
        /// </summary>
        public static string DuplicateColumnNameCollationMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? collation1, object? collation2)
            => string.Format(
                GetString("DuplicateColumnNameCollationMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(collation1), nameof(collation2)),
                entityType1, property1, entityType2, property2, columnName, table, collation1, collation2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different comments ('{comment1}' and '{comment2}').
        /// </summary>
        public static string DuplicateColumnNameCommentMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? comment1, object? comment2)
            => string.Format(
                GetString("DuplicateColumnNameCommentMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(comment1), nameof(comment2)),
                entityType1, property1, entityType2, property2, columnName, table, comment1, comment2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured to use different computed values ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameComputedSqlMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? value1, object? value2)
            => string.Format(
                GetString("DuplicateColumnNameComputedSqlMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but have different concurrency token configurations.
        /// </summary>
        public static string DuplicateColumnNameConcurrencyTokenMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnNameConcurrencyTokenMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured to use different data types ('{dataType1}' and '{dataType2}').
        /// </summary>
        public static string DuplicateColumnNameDataTypeMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? dataType1, object? dataType2)
            => string.Format(
                GetString("DuplicateColumnNameDataTypeMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(dataType1), nameof(dataType2)),
                entityType1, property1, entityType2, property2, columnName, table, dataType1, dataType2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured to use different default values ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameDefaultSqlMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? value1, object? value2)
            => string.Format(
                GetString("DuplicateColumnNameDefaultSqlMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but have different fixed length configuration.
        /// </summary>
        public static string DuplicateColumnNameFixedLengthMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnNameFixedLengthMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured to use different stored computed column settings ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameIsStoredMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? value1, object? value2)
            => string.Format(
                GetString("DuplicateColumnNameIsStoredMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different maximum lengths ('{maxLength1}' and '{maxLength2}').
        /// </summary>
        public static string DuplicateColumnNameMaxLengthMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? maxLength1, object? maxLength2)
            => string.Format(
                GetString("DuplicateColumnNameMaxLengthMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(maxLength1), nameof(maxLength2)),
                entityType1, property1, entityType2, property2, columnName, table, maxLength1, maxLength2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different nullability settings.
        /// </summary>
        public static string DuplicateColumnNameNullabilityMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnNameNullabilityMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different precisions ('{precision1}' and '{precision2}').
        /// </summary>
        public static string DuplicateColumnNamePrecisionMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? precision1, object? precision2)
            => string.Format(
                GetString("DuplicateColumnNamePrecisionMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(precision1), nameof(precision2)),
                entityType1, property1, entityType2, property2, columnName, table, precision1, precision2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but are configured with different scales ('{scale1}' and '{scale2}').
        /// </summary>
        public static string DuplicateColumnNameScaleMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table, object? scale1, object? scale2)
            => string.Format(
                GetString("DuplicateColumnNameScaleMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(scale1), nameof(scale2)),
                entityType1, property1, entityType2, property2, columnName, table, scale1, scale2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}', but have different unicode configurations.
        /// </summary>
        public static string DuplicateColumnNameUnicodenessMismatch(object? entityType1, object? property1, object? entityType2, object? property2, object? columnName, object? table)
            => string.Format(
                GetString("DuplicateColumnNameUnicodenessMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     The foreign keys {foreignKeyProperties1} on '{entityType1}' and {foreignKeyProperties2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}', but use different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateForeignKeyColumnMismatch(object? foreignKeyProperties1, object? entityType1, object? foreignKeyProperties2, object? entityType2, object? table, object? foreignKeyName, object? columnNames1, object? columnNames2)
            => string.Format(
                GetString("DuplicateForeignKeyColumnMismatch", nameof(foreignKeyProperties1), nameof(entityType1), nameof(foreignKeyProperties2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(columnNames1), nameof(columnNames2)),
                foreignKeyProperties1, entityType1, foreignKeyProperties2, entityType2, table, foreignKeyName, columnNames1, columnNames2);

        /// <summary>
        ///     The foreign keys {foreignKeyProperties1} on '{entityType1}' and {foreignKeyProperties2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}', but configured with different delete behavior ('{deleteBehavior1}' and '{deleteBehavior2}').
        /// </summary>
        public static string DuplicateForeignKeyDeleteBehaviorMismatch(object? foreignKeyProperties1, object? entityType1, object? foreignKeyProperties2, object? entityType2, object? table, object? foreignKeyName, object? deleteBehavior1, object? deleteBehavior2)
            => string.Format(
                GetString("DuplicateForeignKeyDeleteBehaviorMismatch", nameof(foreignKeyProperties1), nameof(entityType1), nameof(foreignKeyProperties2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(deleteBehavior1), nameof(deleteBehavior2)),
                foreignKeyProperties1, entityType1, foreignKeyProperties2, entityType2, table, foreignKeyName, deleteBehavior1, deleteBehavior2);

        /// <summary>
        ///     The foreign keys {foreignKeyProperties1} on '{entityType1}' and {foreignKeyProperties2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}', but referencing different principal columns ({principalColumnNames1} and {principalColumnNames2}).
        /// </summary>
        public static string DuplicateForeignKeyPrincipalColumnMismatch(object? foreignKeyProperties1, object? entityType1, object? foreignKeyProperties2, object? entityType2, object? table, object? foreignKeyName, object? principalColumnNames1, object? principalColumnNames2)
            => string.Format(
                GetString("DuplicateForeignKeyPrincipalColumnMismatch", nameof(foreignKeyProperties1), nameof(entityType1), nameof(foreignKeyProperties2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(principalColumnNames1), nameof(principalColumnNames2)),
                foreignKeyProperties1, entityType1, foreignKeyProperties2, entityType2, table, foreignKeyName, principalColumnNames1, principalColumnNames2);

        /// <summary>
        ///     The foreign keys {foreignKeyProperties1} on '{entityType1}' and {foreignKeyProperties2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}', but referencing different principal tables ('{principalTable1}' and '{principalTable2}').
        /// </summary>
        public static string DuplicateForeignKeyPrincipalTableMismatch(object? foreignKeyProperties1, object? entityType1, object? foreignKeyProperties2, object? entityType2, object? table, object? foreignKeyName, object? principalTable1, object? principalTable2)
            => string.Format(
                GetString("DuplicateForeignKeyPrincipalTableMismatch", nameof(foreignKeyProperties1), nameof(entityType1), nameof(foreignKeyProperties2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(principalTable1), nameof(principalTable2)),
                foreignKeyProperties1, entityType1, foreignKeyProperties2, entityType2, table, foreignKeyName, principalTable1, principalTable2);

        /// <summary>
        ///     The foreign keys {foreignKeyProperties1} on '{entityType1}' and {foreignKeyProperties2} on '{entityType2}' are both mapped to '{foreignKeyName}', but are declared on different tables ('{table1}' and '{table2}').
        /// </summary>
        public static string DuplicateForeignKeyTableMismatch(object? foreignKeyProperties1, object? entityType1, object? foreignKeyProperties2, object? entityType2, object? foreignKeyName, object? table1, object? table2)
            => string.Format(
                GetString("DuplicateForeignKeyTableMismatch", nameof(foreignKeyProperties1), nameof(entityType1), nameof(foreignKeyProperties2), nameof(entityType2), nameof(foreignKeyName), nameof(table1), nameof(table2)),
                foreignKeyProperties1, entityType1, foreignKeyProperties2, entityType2, foreignKeyName, table1, table2);

        /// <summary>
        ///     The foreign keys {foreignKeyProperties1} on '{entityType1}' and {foreignKeyProperties2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}', but with different uniqueness configurations.
        /// </summary>
        public static string DuplicateForeignKeyUniquenessMismatch(object? foreignKeyProperties1, object? entityType1, object? foreignKeyProperties2, object? entityType2, object? table, object? foreignKeyName)
            => string.Format(
                GetString("DuplicateForeignKeyUniquenessMismatch", nameof(foreignKeyProperties1), nameof(entityType1), nameof(foreignKeyProperties2), nameof(entityType2), nameof(table), nameof(foreignKeyName)),
                foreignKeyProperties1, entityType1, foreignKeyProperties2, entityType2, table, foreignKeyName);

        /// <summary>
        ///     The indexes {indexProperties1} on '{entityType1}' and {indexProperties2} on '{entityType2}' are both mapped to '{table}.{indexName}', but with different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateIndexColumnMismatch(object? indexProperties1, object? entityType1, object? indexProperties2, object? entityType2, object? table, object? indexName, object? columnNames1, object? columnNames2)
            => string.Format(
                GetString("DuplicateIndexColumnMismatch", nameof(indexProperties1), nameof(entityType1), nameof(indexProperties2), nameof(entityType2), nameof(table), nameof(indexName), nameof(columnNames1), nameof(columnNames2)),
                indexProperties1, entityType1, indexProperties2, entityType2, table, indexName, columnNames1, columnNames2);

        /// <summary>
        ///     The indexes {indexProperties1} on '{entityType1}' and {indexProperties2} on '{entityType2}' are both mapped to '{indexName}', but are declared on different tables ('{table1}' and '{table2}').
        /// </summary>
        public static string DuplicateIndexTableMismatch(object? indexProperties1, object? entityType1, object? indexProperties2, object? entityType2, object? indexName, object? table1, object? table2)
            => string.Format(
                GetString("DuplicateIndexTableMismatch", nameof(indexProperties1), nameof(entityType1), nameof(indexProperties2), nameof(entityType2), nameof(indexName), nameof(table1), nameof(table2)),
                indexProperties1, entityType1, indexProperties2, entityType2, indexName, table1, table2);

        /// <summary>
        ///     The indexes {indexProperties1} on '{entityType1}' and {indexProperties2} on '{entityType2}' are both mapped to '{table}.{indexName}', but with different uniqueness configurations.
        /// </summary>
        public static string DuplicateIndexUniquenessMismatch(object? indexProperties1, object? entityType1, object? indexProperties2, object? entityType2, object? table, object? indexName)
            => string.Format(
                GetString("DuplicateIndexUniquenessMismatch", nameof(indexProperties1), nameof(entityType1), nameof(indexProperties2), nameof(entityType2), nameof(table), nameof(indexName)),
                indexProperties1, entityType1, indexProperties2, entityType2, table, indexName);

        /// <summary>
        ///     The keys {keyProperties1} on '{entityType1}' and {keyProperties2} on '{entityType2}' are both mapped to '{table}.{keyName}', but with different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateKeyColumnMismatch(object? keyProperties1, object? entityType1, object? keyProperties2, object? entityType2, object? table, object? keyName, object? columnNames1, object? columnNames2)
            => string.Format(
                GetString("DuplicateKeyColumnMismatch", nameof(keyProperties1), nameof(entityType1), nameof(keyProperties2), nameof(entityType2), nameof(table), nameof(keyName), nameof(columnNames1), nameof(columnNames2)),
                keyProperties1, entityType1, keyProperties2, entityType2, table, keyName, columnNames1, columnNames2);

        /// <summary>
        ///     The keys {keyProperties1} on '{entityType1}' and {keyProperties2} on '{entityType2}' are both mapped to '{keyName}', but on different tables ('{table1}' and '{table2}').
        /// </summary>
        public static string DuplicateKeyTableMismatch(object? keyProperties1, object? entityType1, object? keyProperties2, object? entityType2, object? keyName, object? table1, object? table2)
            => string.Format(
                GetString("DuplicateKeyTableMismatch", nameof(keyProperties1), nameof(entityType1), nameof(keyProperties2), nameof(entityType2), nameof(keyName), nameof(table1), nameof(table2)),
                keyProperties1, entityType1, keyProperties2, entityType2, keyName, table1, table2);

        /// <summary>
        ///     Either {param1} or {param2} must be null.
        /// </summary>
        public static string EitherOfTwoValuesMustBeNull(object? param1, object? param2)
            => string.Format(
                GetString("EitherOfTwoValuesMustBeNull", nameof(param1), nameof(param2)),
                param1, param2);

        /// <summary>
        ///     An error occurred while reading a database value for property '{entityType}.{property}'. See the inner exception for more information.
        /// </summary>
        public static string ErrorMaterializingProperty(object? entityType, object? property)
            => string.Format(
                GetString("ErrorMaterializingProperty", nameof(entityType), nameof(property)),
                entityType, property);

        /// <summary>
        ///     An error occurred while reading a database value for property '{entityType}.{property}'. The expected type was '{expectedType}' but the actual value was null.
        /// </summary>
        public static string ErrorMaterializingPropertyNullReference(object? entityType, object? property, object? expectedType)
            => string.Format(
                GetString("ErrorMaterializingPropertyNullReference", nameof(entityType), nameof(property), nameof(expectedType)),
                entityType, property, expectedType);

        /// <summary>
        ///     An error occurred while reading a database value. See the inner exception for more information.
        /// </summary>
        public static string ErrorMaterializingValue
            => GetString("ErrorMaterializingValue");

        /// <summary>
        ///     An error occurred while reading a database value. The expected type was '{expectedType}' but the actual value was of type '{actualType}'.
        /// </summary>
        public static string ErrorMaterializingValueInvalidCast(object? expectedType, object? actualType)
            => string.Format(
                GetString("ErrorMaterializingValueInvalidCast", nameof(expectedType), nameof(actualType)),
                expectedType, actualType);

        /// <summary>
        ///     An error occurred while reading a database value. The expected type was '{expectedType}' but the actual value was null.
        /// </summary>
        public static string ErrorMaterializingValueNullReference(object? expectedType)
            => string.Format(
                GetString("ErrorMaterializingValueNullReference", nameof(expectedType)),
                expectedType);

        /// <summary>
        ///     The required column '{column}' was not present in the results of a 'FromSql' operation.
        /// </summary>
        public static string FromSqlMissingColumn(object? column)
            => string.Format(
                GetString("FromSqlMissingColumn", nameof(column)),
                column);

        /// <summary>
        ///     'FromSqlRaw' or 'FromSqlInterpolated' was called with non-composable SQL and with a query composing over it. Consider calling 'AsEnumerable' after the method to perform the composition on the client side.
        /// </summary>
        public static string FromSqlNonComposable
            => GetString("FromSqlNonComposable");

        /// <summary>
        ///     The property '{propertySpecification}' has specific configuration for the function '{function}', but it isn't mapped to a column on that function return. Remove the specific configuration, or map an entity type that contains this property to '{function}'.
        /// </summary>
        public static string FunctionOverrideMismatch(object? propertySpecification, object? function)
            => string.Format(
                GetString("FunctionOverrideMismatch", nameof(propertySpecification), nameof(function)),
                propertySpecification, function);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and the comment '{comment}' does not match the comment '{otherComment}'.
        /// </summary>
        public static string IncompatibleTableCommentMismatch(object? table, object? entityType, object? otherEntityType, object? comment, object? otherComment)
            => string.Format(
                GetString("IncompatibleTableCommentMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(comment), nameof(otherComment)),
                table, entityType, otherEntityType, comment, otherComment);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and there is a relationship between their primary keys in which '{entityType}' is the dependent, but '{entityType}' has a base entity type mapped to a different table. Either map '{otherEntityType}' to a different table, or invert the relationship between '{entityType}' and '{otherEntityType}'.
        /// </summary>
        public static string IncompatibleTableDerivedRelationship(object? table, object? entityType, object? otherEntityType)
            => string.Format(
                GetString("IncompatibleTableDerivedRelationship", nameof(table), nameof(entityType), nameof(otherEntityType)),
                table, entityType, otherEntityType);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and is excluded from migrations on one entity type but not on the other. Exclude the table from migrations on all entity types mapped to the table.
        /// </summary>
        public static string IncompatibleTableExcludedMismatch(object? table, object? entityType, object? otherEntityType)
            => string.Format(
                GetString("IncompatibleTableExcludedMismatch", nameof(table), nameof(entityType), nameof(otherEntityType)),
                table, entityType, otherEntityType);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and the name '{keyName}' of the primary key {primaryKey} does not match the name '{otherName}' of the primary key {otherPrimaryKey}.
        /// </summary>
        public static string IncompatibleTableKeyNameMismatch(object? table, object? entityType, object? otherEntityType, object? keyName, object? primaryKey, object? otherName, object? otherPrimaryKey)
            => string.Format(
                GetString("IncompatibleTableKeyNameMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(keyName), nameof(primaryKey), nameof(otherName), nameof(otherPrimaryKey)),
                table, entityType, otherEntityType, keyName, primaryKey, otherName, otherPrimaryKey);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and potentially other entity types, but there is no linking relationship. Add a foreign key to '{entityType}' on the primary key properties and pointing to the primary key on another entity type mapped to '{table}'.
        /// </summary>
        public static string IncompatibleTableNoRelationship(object? table, object? entityType, object? otherEntityType)
            => string.Format(
                GetString("IncompatibleTableNoRelationship", nameof(table), nameof(entityType), nameof(otherEntityType)),
                table, entityType, otherEntityType);

        /// <summary>
        ///     Cannot use view '{view}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and there is a relationship between their primary keys in which '{entityType}' is the dependent, but '{entityType}' has a base entity type mapped to a different view. Either map '{otherEntityType}' to a different view, or invert the relationship between '{entityType}' and '{otherEntityType}'.
        /// </summary>
        public static string IncompatibleViewDerivedRelationship(object? view, object? entityType, object? otherEntityType)
            => string.Format(
                GetString("IncompatibleViewDerivedRelationship", nameof(view), nameof(entityType), nameof(otherEntityType)),
                view, entityType, otherEntityType);

        /// <summary>
        ///     Cannot use view '{view}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and there is no relationship between their primary keys.
        /// </summary>
        public static string IncompatibleViewNoRelationship(object? view, object? entityType, object? otherEntityType)
            => string.Format(
                GetString("IncompatibleViewNoRelationship", nameof(view), nameof(entityType), nameof(otherEntityType)),
                view, entityType, otherEntityType);

        /// <summary>
        ///     Cannot set default value '{value}' of type '{valueType}' on property '{property}' of type '{propertyType}' in entity type '{entityType}'.
        /// </summary>
        public static string IncorrectDefaultValueType(object? value, object? valueType, object? property, object? propertyType, object? entityType)
            => string.Format(
                GetString("IncorrectDefaultValueType", nameof(value), nameof(valueType), nameof(property), nameof(propertyType), nameof(entityType)),
                value, valueType, property, propertyType, entityType);

        /// <summary>
        ///     The data insertion operation on '{table}' is not associated with a model. Either add a model to the migration, or specify the column types in all data operations.
        /// </summary>
        public static string InsertDataOperationNoModel(object? table)
            => string.Format(
                GetString("InsertDataOperationNoModel", nameof(table)),
                table);

        /// <summary>
        ///     The number of column types ({typesCount}) doesn't match the number of columns ({columnsCount}) for the data insertion operation on '{table}'. Provide the same number of column types and columns.
        /// </summary>
        public static string InsertDataOperationTypesCountMismatch(object? typesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("InsertDataOperationTypesCountMismatch", nameof(typesCount), nameof(columnsCount), nameof(table)),
                typesCount, columnsCount, table);

        /// <summary>
        ///     The number of values ({valuesCount}) doesn't match the number of columns ({columnsCount}) for the data insertion operation on '{table}'. Provide the same number of values and columns.
        /// </summary>
        public static string InsertDataOperationValuesCountMismatch(object? valuesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("InsertDataOperationValuesCountMismatch", nameof(valuesCount), nameof(columnsCount), nameof(table)),
                valuesCount, columnsCount, table);

        /// <summary>
        ///     Unable to translate a collection subquery in a projection since the parent query doesn't project the key columns of all tables required to generate results on the client side. This can happen when trying to correlate on keyless entity or when using 'Distinct' or 'GroupBy' operations without projecting all of the key columns.
        /// </summary>
        public static string InsufficientInformationToIdentifyOuterElementOfCollectionJoin
            => GetString("InsufficientInformationToIdentifyOuterElementOfCollectionJoin");

        /// <summary>
        ///     The specified 'CommandTimeout' value '{value}' is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidCommandTimeout(object? value)
            => string.Format(
                GetString("InvalidCommandTimeout", nameof(value)),
                value);

        /// <summary>
        ///     The specified entity type '{derivedType}' is not derived from '{entityType}'.
        /// </summary>
        public static string InvalidDerivedTypeInEntityProjection(object? derivedType, object? entityType)
            => string.Format(
                GetString("InvalidDerivedTypeInEntityProjection", nameof(derivedType), nameof(entityType)),
                derivedType, entityType);

        /// <summary>
        ///     The grouping key '{keySelector}' is of type '{keyType}' which is not valid key.
        /// </summary>
        public static string InvalidKeySelectorForGroupBy(object? keySelector, object? keyType)
            => string.Format(
                GetString("InvalidKeySelectorForGroupBy", nameof(keySelector), nameof(keyType)),
                keySelector, keyType);

        /// <summary>
        ///     The entity type '{entityType}' is mapped to the 'DbFunction' named '{functionName}', but is derived from '{baseEntityType}'. Derived entity types cannot be mapped to a function.
        /// </summary>
        public static string InvalidMappedFunctionDerivedType(object? entityType, object? functionName, object? baseEntityType)
            => string.Format(
                GetString("InvalidMappedFunctionDerivedType", nameof(entityType), nameof(functionName), nameof(baseEntityType)),
                entityType, functionName, baseEntityType);

        /// <summary>
        ///     The entity type '{entityType}' is mapped to the 'DbFunction' named '{functionName}' with return type '{returnType}'. Ensure that the mapped function returns 'IQueryable&lt;{clrType}&gt;'.
        /// </summary>
        public static string InvalidMappedFunctionUnmatchedReturn(object? entityType, object? functionName, object? returnType, object? clrType)
            => string.Format(
                GetString("InvalidMappedFunctionUnmatchedReturn", nameof(entityType), nameof(functionName), nameof(returnType), nameof(clrType)),
                entityType, functionName, returnType, clrType);

        /// <summary>
        ///     The entity type '{entityType}' is mapped to the 'DbFunction' named '{functionName}' with parameters {parameters}. Ensure that the mapped function doesn't have any parameters.
        /// </summary>
        public static string InvalidMappedFunctionWithParameters(object? entityType, object? functionName, object? parameters)
            => string.Format(
                GetString("InvalidMappedFunctionWithParameters", nameof(entityType), nameof(functionName), nameof(parameters)),
                entityType, functionName, parameters);

        /// <summary>
        ///     The entity type '{entityType}' is mapped to a SQL query, but is derived from '{baseEntityType}'. Derived entity types cannot be mapped to a different SQL query than the base entity type.
        /// </summary>
        public static string InvalidMappedSqlQueryDerivedType(object? entityType, object? baseEntityType)
            => string.Format(
                GetString("InvalidMappedSqlQueryDerivedType", nameof(entityType), nameof(baseEntityType)),
                entityType, baseEntityType);

        /// <summary>
        ///     The specified 'MaxBatchSize' value '{value}' is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidMaxBatchSize(object? value)
            => string.Format(
                GetString("InvalidMaxBatchSize", nameof(value)),
                value);

        /// <summary>
        ///     The specified 'MinBatchSize' value '{value}' is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidMinBatchSize(object? value)
            => string.Format(
                GetString("InvalidMinBatchSize", nameof(value)),
                value);

        /// <summary>
        ///     Queries performing '{method}' operation must have a deterministic sort order. Rewrite the query to apply an 'OrderBy' operation on the sequence before calling '{method}'.
        /// </summary>
        public static string LastUsedWithoutOrderBy(object? method)
            => string.Format(
                GetString("LastUsedWithoutOrderBy", nameof(method)),
                method);

        /// <summary>
        ///     The entity type '{entityType}' is mapped to the DbFunction named '{functionName}', but no DbFunction with that name was found in the model. Ensure that the entity type mapping is configured using the model name of a function in the model.
        /// </summary>
        public static string MappedFunctionNotFound(object? entityType, object? functionName)
            => string.Format(
                GetString("MappedFunctionNotFound", nameof(entityType), nameof(functionName)),
                entityType, functionName);

        /// <summary>
        ///     Using '{methodName}' on DbSet of '{entityType}' is not supported since '{entityType}' is part of hierarchy and does not contain a discriminator property.
        /// </summary>
        public static string MethodOnNonTPHRootNotSupported(object? methodName, object? entityType)
            => string.Format(
                GetString("MethodOnNonTPHRootNotSupported", nameof(methodName), nameof(entityType)),
                methodName, entityType);

        /// <summary>
        ///     The 'Down' method for this migration has not been implemented. Both the 'Up' abd 'Down' methods must be implemented to support reverting migrations.
        /// </summary>
        public static string MigrationDownMissing
            => GetString("MigrationDownMissing");

        /// <summary>
        ///     The migration '{migrationName}' was not found.
        /// </summary>
        public static string MigrationNotFound(object? migrationName)
            => string.Format(
                GetString("MigrationNotFound", nameof(migrationName)),
                migrationName);

        /// <summary>
        ///     SQL generation for the operation '{operation}' is not supported by the current database provider. Database providers must implement the appropriate method in 'MigrationsSqlGenerator' to support this operation.
        /// </summary>
        public static string MigrationSqlGenerationMissing(object? operation)
            => string.Format(
                GetString("MigrationSqlGenerationMissing", nameof(operation)),
                operation);

        /// <summary>
        ///     Entity type '{entityType}' doesn't contain a property mapped to the store-generated concurrency token column '{missingColumn}' which is used by another entity type sharing the table '{table}'. Add a store-generated property to '{entityType}' which is mapped to the same column; it may be in shadow state.
        /// </summary>
        public static string MissingConcurrencyColumn(object? entityType, object? missingColumn, object? table)
            => string.Format(
                GetString("MissingConcurrencyColumn", nameof(entityType), nameof(missingColumn), nameof(table)),
                entityType, missingColumn, table);

        /// <summary>
        ///     'Reverse' could not be translated to the server because there is no ordering on the server side.
        /// </summary>
        public static string MissingOrderingInSelectExpression
            => GetString("MissingOrderingInSelectExpression");

        /// <summary>
        ///     No value was provided for the required parameter '{parameter}'.
        /// </summary>
        public static string MissingParameterValue(object? parameter)
            => string.Format(
                GetString("MissingParameterValue", nameof(parameter)),
                parameter);

        /// <summary>
        ///     Cannot save changes for an entity of type '{entityType}' in state '{entityState}'. This may indicate a bug in Entity Framework, please open an issue at https://go.microsoft.com/fwlink/?linkid=2142044. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values of the entity.
        /// </summary>
        public static string ModificationCommandInvalidEntityState(object? entityType, object? entityState)
            => string.Format(
                GetString("ModificationCommandInvalidEntityState", nameof(entityType), nameof(entityState)),
                entityType, entityState);

        /// <summary>
        ///     Cannot save changes for an entity of type '{entityType}' with primary key values {keyValues} in state '{entityState}'. This may indicate a bug in Entity Framework, please open an issue at https://go.microsoft.com/fwlink/?linkid=2142044.
        /// </summary>
        public static string ModificationCommandInvalidEntityStateSensitive(object? entityType, object? keyValues, object? entityState)
            => string.Format(
                GetString("ModificationCommandInvalidEntityStateSensitive", nameof(entityType), nameof(keyValues), nameof(entityState)),
                entityType, keyValues, entityState);

        /// <summary>
        ///     Multiple relational database provider configurations found. A context can only be configured to use a single database provider.
        /// </summary>
        public static string MultipleProvidersConfigured
            => GetString("MultipleProvidersConfigured");

        /// <summary>
        ///     A named connection string was used, but the name '{name}' was not found in the application's configuration. Note that named connection strings are only supported when using 'IConfiguration' and a service provider, such as in a typical ASP.NET Core application. See https://go.microsoft.com/fwlink/?linkid=850912 for more information.
        /// </summary>
        public static string NamedConnectionStringNotFound(object? name)
            => string.Format(
                GetString("NamedConnectionStringNotFound", nameof(name)),
                name);

        /// <summary>
        ///     A root ambient transaction was completed before the nested transaction. The nested transactions should be completed first.
        /// </summary>
        public static string NestedAmbientTransactionError
            => GetString("NestedAmbientTransactionError");

        /// <summary>
        ///     The connection does not have any active transactions.
        /// </summary>
        public static string NoActiveTransaction
            => GetString("NoActiveTransaction");

        /// <summary>
        ///     A relational store has been configured without specifying either the DbConnection or connection string to use.
        /// </summary>
        public static string NoConnectionOrConnectionString
            => GetString("NoConnectionOrConnectionString");

        /// <summary>
        ///     Cannot create a DbCommand for a non-relational query.
        /// </summary>
        public static string NoDbCommand
            => GetString("NoDbCommand");

        /// <summary>
        ///     'FindMapping' was called on a 'RelationalTypeMappingSource' with a non-relational 'TypeMappingInfo'.
        /// </summary>
        public static string NoneRelationalTypeMappingOnARelationalTypeMappingSource
            => GetString("NoneRelationalTypeMappingOnARelationalTypeMappingSource");

        /// <summary>
        ///     Cannot set 'IsNullable' on DbFunction '{functionName}' since the function does not represent a scalar function.
        /// </summary>
        public static string NonScalarFunctionCannotBeNullable(object? functionName)
            => string.Format(
                GetString("NonScalarFunctionCannotBeNullable", nameof(functionName)),
                functionName);

        /// <summary>
        ///     Cannot set 'PropagatesNullability' on parameter '{parameterName}' of DbFunction '{functionName}' since function does not represent a scalar function.
        /// </summary>
        public static string NonScalarFunctionParameterCannotPropagatesNullability(object? parameterName, object? functionName)
            => string.Format(
                GetString("NonScalarFunctionParameterCannotPropagatesNullability", nameof(parameterName), nameof(functionName)),
                parameterName, functionName);

        /// <summary>
        ///     Both '{entityType}' and '{otherEntityType}' are mapped to the table '{table}'. All the entity types in a hierarchy that don't have a discriminator must be mapped to different tables. See https://go.microsoft.com/fwlink/?linkid=2130430 for more information.
        /// </summary>
        public static string NonTPHTableClash(object? entityType, object? otherEntityType, object? table)
            => string.Format(
                GetString("NonTPHTableClash", nameof(entityType), nameof(otherEntityType), nameof(table)),
                entityType, otherEntityType, table);

        /// <summary>
        ///     Both '{entityType}' and '{otherEntityType}' are mapped to the view '{view}'. All the entity types in a hierarchy that don't have a discriminator must be mapped to different views. See https://go.microsoft.com/fwlink/?linkid=2130430 for more information.
        /// </summary>
        public static string NonTPHViewClash(object? entityType, object? otherEntityType, object? view)
            => string.Format(
                GetString("NonTPHViewClash", nameof(entityType), nameof(otherEntityType), nameof(view)),
                entityType, otherEntityType, view);

        /// <summary>
        ///     No relational database providers are configured. Configure a database provider using 'OnConfiguring' or by creating an ImmutableDbContextOptions with a configured database provider and passing it to the context.
        /// </summary>
        public static string NoProviderConfigured
            => GetString("NoProviderConfigured");

        /// <summary>
        ///     Expression '{sqlExpression}' in the SQL tree does not have a type mapping assigned.
        /// </summary>
        public static string NullTypeMappingInSqlTree(object? sqlExpression)
            => string.Format(
                GetString("NullTypeMappingInSqlTree", nameof(sqlExpression)),
                sqlExpression);

        /// <summary>
        ///     Entity type '{entityType}' is an optional dependent using table sharing and containing other dependents without any required non shared property to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query causing nested dependent's values to be lost. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
        /// </summary>
        public static string OptionalDependentWithDependentWithoutIdentifyingProperty(object? entityType)
            => string.Format(
                GetString("OptionalDependentWithDependentWithoutIdentifyingProperty", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Cannot use the value provided for parameter '{parameter}' because it isn't assignable to type object[].
        /// </summary>
        public static string ParameterNotObjectArray(object? parameter)
            => string.Format(
                GetString("ParameterNotObjectArray", nameof(parameter)),
                parameter);

        /// <summary>
        ///     This connection was used with an ambient transaction. The original ambient transaction needs to be completed before this connection can be used outside of it.
        /// </summary>
        public static string PendingAmbientTransaction
            => GetString("PendingAmbientTransaction");

        /// <summary>
        ///     Unable to translate set operations when both sides don't assign values to the same properties in the nominal type. Please make sure that the same properties are included on both sides, and consider assigning default values if a property doesn't require a specific value.
        /// </summary>
        public static string ProjectionMappingCountMismatch
            => GetString("ProjectionMappingCountMismatch");

        /// <summary>
        ///     The property '{property}' on entity type '{entityType}' is not mapped to '{table}'.
        /// </summary>
        public static string PropertyNotMappedToTable(object? property, object? entityType, object? table)
            => string.Format(
                GetString("PropertyNotMappedToTable", nameof(property), nameof(entityType), nameof(table)),
                property, entityType, table);

        /// <summary>
        ///     The entity type '{entityType}' is not mapped to a table, therefore the entities cannot be persisted to the database. Call 'ToTable' in 'OnModelCreating' to map it to a table.
        /// </summary>
        public static string ReadonlyEntitySaved(object? entityType)
            => string.Format(
                GetString("ReadonlyEntitySaved", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Relational-specific methods can only be used when the context is using a relational database provider.
        /// </summary>
        public static string RelationalNotInUse
            => GetString("RelationalNotInUse");

        /// <summary>
        ///     Cannot create a 'SelectExpression' with a custom 'TableExpressionBase' since the result type '{entityType}' is part of a hierarchy and does not contain a discriminator property.
        /// </summary>
        public static string SelectExpressionNonTPHWithCustomTable(object? entityType)
            => string.Format(
                GetString("SelectExpressionNonTPHWithCustomTable", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Unable to translate set operation after client projection has been applied. Consider moving the set operation before the last 'Select' call.
        /// </summary>
        public static string SetOperationsNotAllowedAfterClientEvaluation
            => GetString("SetOperationsNotAllowedAfterClientEvaluation");

        /// <summary>
        ///     Unable to translate set operation when matching columns on both sides have different store types.
        /// </summary>
        public static string SetOperationsOnDifferentStoreTypes
            => GetString("SetOperationsOnDifferentStoreTypes");

        /// <summary>
        ///     This LINQ query is being executed in split-query mode, and the SQL shown is for the first query to be executed. Additional queries may also be executed depending on the results of the first query.
        /// </summary>
        public static string SplitQueryString
            => GetString("SplitQueryString");

        /// <summary>
        ///     The property '{propertySpecification}' has specific configuration for the SQL query '{query}', but isn't mapped to a column on that query. Remove the specific configuration, or map an entity type that contains this property to '{query}'.
        /// </summary>
        public static string SqlQueryOverrideMismatch(object? propertySpecification, object? query)
            => string.Format(
                GetString("SqlQueryOverrideMismatch", nameof(propertySpecification), nameof(query)),
                propertySpecification, query);

        /// <summary>
        ///     The entity type '{entityType}' is not mapped to the store object '{table}'.
        /// </summary>
        public static string TableNotMappedEntityType(object? entityType, object? table)
            => string.Format(
                GetString("TableNotMappedEntityType", nameof(entityType), nameof(table)),
                entityType, table);

        /// <summary>
        ///     The property '{propertySpecification}' has specific configuration for the table '{table}', but isn't mapped to a column on that table. Remove the specific configuration, or map an entity type that contains this property to '{table}'.
        /// </summary>
        public static string TableOverrideMismatch(object? propertySpecification, object? table)
            => string.Format(
                GetString("TableOverrideMismatch", nameof(propertySpecification), nameof(table)),
                propertySpecification, table);

        /// <summary>
        ///     The element type of the result of '{dbFunction}' is mapped to '{entityType}'. This is not supported since '{entityType}' is part of hierarchy and does not contain a discriminator property.
        /// </summary>
        public static string TableValuedFunctionNonTPH(object? dbFunction, object? entityType)
            => string.Format(
                GetString("TableValuedFunctionNonTPH", nameof(dbFunction), nameof(entityType)),
                dbFunction, entityType);

        /// <summary>
        ///     Timeout must be less than or equal to Int32.MaxValue (2147483647) seconds. Provided timeout: {seconds} seconds.
        /// </summary>
        public static string TimeoutTooBig(object? seconds)
            => string.Format(
                GetString("TimeoutTooBig", nameof(seconds)),
                seconds);

        /// <summary>
        ///     Timeout must be greater than or equal to zero. Provided timeout: {seconds} seconds.
        /// </summary>
        public static string TimeoutTooSmall(object? seconds)
            => string.Format(
                GetString("TimeoutTooSmall", nameof(seconds)),
                seconds);

        /// <summary>
        ///     The underlying reader doesn't have as many fields as expected. Expected: {expected}, actual: {actual}.
        /// </summary>
        public static string TooFewReaderFields(object? expected, object? actual)
            => string.Format(
                GetString("TooFewReaderFields", nameof(expected), nameof(actual)),
                expected, actual);

        /// <summary>
        ///     '{entityType}' is mapped to the table '{table}' while '{otherEntityType}' is mapped to the table '{otherTable}'. Map all the entity types in the hierarchy to the same table, or remove the discriminator and map them all to different tables. See https://go.microsoft.com/fwlink/?linkid=2130430 for more information.
        /// </summary>
        public static string TPHTableMismatch(object? entityType, object? table, object? otherEntityType, object? otherTable)
            => string.Format(
                GetString("TPHTableMismatch", nameof(entityType), nameof(table), nameof(otherEntityType), nameof(otherTable)),
                entityType, table, otherEntityType, otherTable);

        /// <summary>
        ///     '{entityType}' is mapped to the view '{view}' while '{otherEntityType}' is mapped to the view '{otherView}'. Map all the entity types in the hierarchy to the same view, or remove the discriminator and map them all to different views. See https://go.microsoft.com/fwlink/?linkid=2130430 for more information.
        /// </summary>
        public static string TPHViewMismatch(object? entityType, object? view, object? otherEntityType, object? otherView)
            => string.Format(
                GetString("TPHViewMismatch", nameof(entityType), nameof(view), nameof(otherEntityType), nameof(otherView)),
                entityType, view, otherEntityType, otherView);

        /// <summary>
        ///     The connection is already in a transaction and cannot participate in another transaction.
        /// </summary>
        public static string TransactionAlreadyStarted
            => GetString("TransactionAlreadyStarted");

        /// <summary>
        ///     The specified transaction is not associated with the current connection. Only transactions associated with the current connection may be used.
        /// </summary>
        public static string TransactionAssociatedWithDifferentConnection
            => GetString("TransactionAssociatedWithDifferentConnection");

        /// <summary>
        ///     User transaction is not supported with a TransactionSuppressed migrations.
        /// </summary>
        public static string TransactionSuppressedMigrationInUserTransaction
            => GetString("TransactionSuppressedMigrationInUserTransaction");

        /// <summary>
        ///     Unable to bind '{memberType}.{member}' to an entity projection of '{entityType}'.
        /// </summary>
        public static string UnableToBindMemberToEntityProjection(object? memberType, object? member, object? entityType)
            => string.Format(
                GetString("UnableToBindMemberToEntityProjection", nameof(memberType), nameof(member), nameof(entityType)),
                memberType, member, entityType);

        /// <summary>
        ///     Unhandled expression '{expression}' of type '{expressionType}' encountered in '{visitor}'.
        /// </summary>
        public static string UnhandledExpressionInVisitor(object? expression, object? expressionType, object? visitor)
            => string.Format(
                GetString("UnhandledExpressionInVisitor", nameof(expression), nameof(expressionType), nameof(visitor)),
                expression, expressionType, visitor);

        /// <summary>
        ///     The current migration SQL generator '{sqlGeneratorType}' is unable to generate SQL for operations of type '{operationType}'.
        /// </summary>
        public static string UnknownOperation(object? sqlGeneratorType, object? operationType)
            => string.Format(
                GetString("UnknownOperation", nameof(sqlGeneratorType), nameof(operationType)),
                sqlGeneratorType, operationType);

        /// <summary>
        ///     The store type '{type}' used for the column '{column}' in a migration data operation is not supported by the current provider.
        /// </summary>
        public static string UnsupportedDataOperationStoreType(object? type, object? column)
            => string.Format(
                GetString("UnsupportedDataOperationStoreType", nameof(type), nameof(column)),
                type, column);

        /// <summary>
        ///     Unsupported operator '{nodeType}' specified for expression of type '{expressionType}'.
        /// </summary>
        public static string UnsupportedOperatorForSqlExpression(object? nodeType, object? expressionType)
            => string.Format(
                GetString("UnsupportedOperatorForSqlExpression", nameof(nodeType), nameof(expressionType)),
                nodeType, expressionType);

        /// <summary>
        ///     No relational type mapping can be found for property '{entity}.{property}' and the current provider doesn't specify a default store type for the properties of type '{clrType}'. 
        /// </summary>
        public static string UnsupportedPropertyType(object? entity, object? property, object? clrType)
            => string.Format(
                GetString("UnsupportedPropertyType", nameof(entity), nameof(property), nameof(clrType)),
                entity, property, clrType);

        /// <summary>
        ///     The store type '{type}' is not supported by the current provider.
        /// </summary>
        public static string UnsupportedStoreType(object? type)
            => string.Format(
                GetString("UnsupportedStoreType", nameof(type)),
                type);

        /// <summary>
        ///     The current provider doesn't have a store type mapping for properties of type '{clrType}'.
        /// </summary>
        public static string UnsupportedType(object? clrType)
            => string.Format(
                GetString("UnsupportedType", nameof(clrType)),
                clrType);

        /// <summary>
        ///     The database operation was expected to affect {expectedRows} row(s), but actually affected {actualRows} row(s); data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
        /// </summary>
        public static string UpdateConcurrencyException(object? expectedRows, object? actualRows)
            => string.Format(
                GetString("UpdateConcurrencyException", nameof(expectedRows), nameof(actualRows)),
                expectedRows, actualRows);

        /// <summary>
        ///     The number of key column types ({typesCount}) doesn't match the number of key columns ({columnsCount}) for the data modification operation on '{table}'. Provide the same number of key column types and key columns.
        /// </summary>
        public static string UpdateDataOperationKeyTypesCountMismatch(object? typesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("UpdateDataOperationKeyTypesCountMismatch", nameof(typesCount), nameof(columnsCount), nameof(table)),
                typesCount, columnsCount, table);

        /// <summary>
        ///     The number of key values ({valuesCount}) doesn't match the number of key columns ({columnsCount}) for the data modification operation on '{table}'. Provide the same number of key values and key columns.
        /// </summary>
        public static string UpdateDataOperationKeyValuesCountMismatch(object? valuesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("UpdateDataOperationKeyValuesCountMismatch", nameof(valuesCount), nameof(columnsCount), nameof(table)),
                valuesCount, columnsCount, table);

        /// <summary>
        ///     The data modification operation on '{table}' is not associated with a model. Either add a model to the migration, or specify the column types in all data operations.
        /// </summary>
        public static string UpdateDataOperationNoModel(object? table)
            => string.Format(
                GetString("UpdateDataOperationNoModel", nameof(table)),
                table);

        /// <summary>
        ///     The number of value rows ({valuesCount}) doesn't match the number of key rows ({keyCount}) for the data modification operation on '{table}'. Provide the same number of value rows and key rows.
        /// </summary>
        public static string UpdateDataOperationRowCountMismatch(object? valuesCount, object? keyCount, object? table)
            => string.Format(
                GetString("UpdateDataOperationRowCountMismatch", nameof(valuesCount), nameof(keyCount), nameof(table)),
                valuesCount, keyCount, table);

        /// <summary>
        ///     The number of column types ({typesCount}) doesn't match the number of columns ({columnsCount}) for the data modification operation on '{table}'. Provide the same number of column types and columns.
        /// </summary>
        public static string UpdateDataOperationTypesCountMismatch(object? typesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("UpdateDataOperationTypesCountMismatch", nameof(typesCount), nameof(columnsCount), nameof(table)),
                typesCount, columnsCount, table);

        /// <summary>
        ///     The number of values ({valuesCount}) doesn't match the number of columns ({columnsCount}) for the data modification operation on '{table}'. Provide the same number of values and columns.
        /// </summary>
        public static string UpdateDataOperationValuesCountMismatch(object? valuesCount, object? columnsCount, object? table)
            => string.Format(
                GetString("UpdateDataOperationValuesCountMismatch", nameof(valuesCount), nameof(columnsCount), nameof(table)),
                valuesCount, columnsCount, table);

        /// <summary>
        ///     An error occurred while saving the entity changes. See the inner exception for details.
        /// </summary>
        public static string UpdateStoreException
            => GetString("UpdateStoreException");

        /// <summary>
        ///     The property '{propertySpecification}' has specific configuration for the view '{view}', however it isn't mapped to a column on that view. Remove the specific configuration or map an entity type that contains this property to '{view}'.
        /// </summary>
        public static string ViewOverrideMismatch(object? propertySpecification, object? view)
            => string.Format(
                GetString("ViewOverrideMismatch", nameof(propertySpecification), nameof(view)),
                propertySpecification, view);

        /// <summary>
        ///     'VisitChildren' must be overridden in the class deriving from 'SqlExpression'.
        /// </summary>
        public static string VisitChildrenMustBeOverridden
            => GetString("VisitChildrenMustBeOverridden");

        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name)!;
            for (var i = 0; i < formatterNames.Length; i++)
            {
                value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
            }

            return value;
        }
    }
}

namespace Microsoft.EntityFrameworkCore.Diagnostics.Internal
{
    /// <summary>
    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
    ///     any release. You should only use it directly in your code with extreme caution and knowing that
    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
    /// </summary>
    public static class RelationalResources
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalStrings", typeof(RelationalResources).Assembly);

        /// <summary>
        ///     An ambient transaction has been detected, but the current provider does not support ambient transactions. See http://go.microsoft.com/fwlink/?LinkId=800142
        /// </summary>
        public static EventDefinition LogAmbientTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransaction,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.AmbientTransactionWarning,
                        LogLevel.Warning,
                        "RelationalEventId.AmbientTransactionWarning",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.AmbientTransactionWarning,
                            _resourceManager.GetString("LogAmbientTransaction")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Enlisted in an ambient transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogAmbientTransactionEnlisted(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransactionEnlisted;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogAmbientTransactionEnlisted,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.AmbientTransactionEnlisted,
                        LogLevel.Debug,
                        "RelationalEventId.AmbientTransactionEnlisted",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.AmbientTransactionEnlisted,
                            _resourceManager.GetString("LogAmbientTransactionEnlisted")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Applying migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogApplyingMigration(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogApplyingMigration;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogApplyingMigration,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationApplying,
                        LogLevel.Information,
                        "RelationalEventId.MigrationApplying",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationApplying,
                            _resourceManager.GetString("LogApplyingMigration")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     An error occurred while releasing a transaction savepoint during `SaveChanges`.
        /// </summary>
        public static EventDefinition LogBatchExecutorFailedToReleaseSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBatchExecutorFailedToReleaseSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBatchExecutorFailedToReleaseSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.BatchExecutorFailedToReleaseSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.BatchExecutorFailedToReleaseSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.BatchExecutorFailedToReleaseSavepoint,
                            _resourceManager.GetString("LogBatchExecutorFailedToReleaseSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     An error occurred while rolling back the transaction to a savepoint, after an exception occured during `SaveChanges`.
        /// </summary>
        public static EventDefinition LogBatchExecutorFailedToRollbackToSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBatchExecutorFailedToRollbackToSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBatchExecutorFailedToRollbackToSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.BatchExecutorFailedToRollbackToSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.BatchExecutorFailedToRollbackToSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.BatchExecutorFailedToRollbackToSavepoint,
                            _resourceManager.GetString("LogBatchExecutorFailedToRollbackToSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Executing {batchCommandsCount} update commands as a batch.
        /// </summary>
        public static EventDefinition<int> LogBatchReadyForExecution(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBatchReadyForExecution;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBatchReadyForExecution,
                    logger,
                    static logger => new EventDefinition<int>(
                        logger.Options,
                        RelationalEventId.BatchReadyForExecution,
                        LogLevel.Debug,
                        "RelationalEventId.BatchReadyForExecution",
                        level => LoggerMessage.Define<int>(
                            level,
                            RelationalEventId.BatchReadyForExecution,
                            _resourceManager.GetString("LogBatchReadyForExecution")!)));
            }

            return (EventDefinition<int>)definition;
        }

        /// <summary>
        ///     Executing update commands individually as the number of batchable commands ({batchableCommandsCount}) is smaller than the minimum batch size ({minBatchSize}).
        /// </summary>
        public static EventDefinition<int, int> LogBatchSmallerThanMinBatchSize(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBatchSmallerThanMinBatchSize;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBatchSmallerThanMinBatchSize,
                    logger,
                    static logger => new EventDefinition<int, int>(
                        logger.Options,
                        RelationalEventId.BatchSmallerThanMinBatchSize,
                        LogLevel.Debug,
                        "RelationalEventId.BatchSmallerThanMinBatchSize",
                        level => LoggerMessage.Define<int, int>(
                            level,
                            RelationalEventId.BatchSmallerThanMinBatchSize,
                            _resourceManager.GetString("LogBatchSmallerThanMinBatchSize")!)));
            }

            return (EventDefinition<int, int>)definition;
        }

        /// <summary>
        ///     Began transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogBeganTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBeganTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBeganTransaction,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.TransactionStarted,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionStarted",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.TransactionStarted,
                            _resourceManager.GetString("LogBeganTransaction")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Beginning transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogBeginningTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBeginningTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBeginningTransaction,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.TransactionStarting,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionStarting",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.TransactionStarting,
                            _resourceManager.GetString("LogBeginningTransaction")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     The 'bool' property '{property}' on entity type '{entityType}' is configured with a database-generated default. This default will always be used for inserts when the property has the value 'false', since this is the CLR default for the 'bool' type. Consider using the nullable 'bool?' type instead, so that the default will only be used for inserts when the property value is 'null'.
        /// </summary>
        public static EventDefinition<string, string> LogBoolWithDefaultWarning(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogBoolWithDefaultWarning;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogBoolWithDefaultWarning,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.BoolWithDefaultWarning,
                        LogLevel.Warning,
                        "RelationalEventId.BoolWithDefaultWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.BoolWithDefaultWarning,
                            _resourceManager.GetString("LogBoolWithDefaultWarning")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Closed connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogClosedConnection(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogClosedConnection;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogClosedConnection,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionClosed,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionClosed",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionClosed,
                            _resourceManager.GetString("LogClosedConnection")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Closing connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogClosingConnection(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogClosingConnection;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogClosingConnection,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionClosing,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionClosing",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionClosing,
                            _resourceManager.GetString("LogClosingConnection")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Created DbCommand for '{executionType}' ({elapsed}ms).
        /// </summary>
        public static EventDefinition<string, int> LogCommandCreated(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommandCreated;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommandCreated,
                    logger,
                    static logger => new EventDefinition<string, int>(
                        logger.Options,
                        RelationalEventId.CommandCreated,
                        LogLevel.Debug,
                        "RelationalEventId.CommandCreated",
                        level => LoggerMessage.Define<string, int>(
                            level,
                            RelationalEventId.CommandCreated,
                            _resourceManager.GetString("LogCommandCreated")!)));
            }

            return (EventDefinition<string, int>)definition;
        }

        /// <summary>
        ///     Creating DbCommand for '{executionType}'.
        /// </summary>
        public static EventDefinition<string> LogCommandCreating(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommandCreating;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommandCreating,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.CommandCreating,
                        LogLevel.Debug,
                        "RelationalEventId.CommandCreating",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.CommandCreating,
                            _resourceManager.GetString("LogCommandCreating")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Failed executing DbCommand ({elapsed}ms) [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static EventDefinition<string, string, System.Data.CommandType, int, string, string> LogCommandFailed(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommandFailed;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommandFailed,
                    logger,
                    static logger => new EventDefinition<string, string, System.Data.CommandType, int, string, string>(
                        logger.Options,
                        RelationalEventId.CommandError,
                        LogLevel.Error,
                        "RelationalEventId.CommandError",
                        level => LoggerMessage.Define<string, string, System.Data.CommandType, int, string, string>(
                            level,
                            RelationalEventId.CommandError,
                            _resourceManager.GetString("LogCommandFailed")!)));
            }

            return (EventDefinition<string, string, System.Data.CommandType, int, string, string>)definition;
        }

        /// <summary>
        ///     Committed transaction.
        /// </summary>
        public static EventDefinition LogCommittedTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommittedTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommittedTransaction,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionCommitted,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionCommitted",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionCommitted,
                            _resourceManager.GetString("LogCommittedTransaction")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Committing transaction.
        /// </summary>
        public static EventDefinition LogCommittingTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCommittingTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCommittingTransaction,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionCommitting,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionCommitting",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionCommitting,
                            _resourceManager.GetString("LogCommittingTransaction")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     An error occurred using the connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogConnectionError(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionError;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionError,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionError,
                        LogLevel.Error,
                        "RelationalEventId.ConnectionError",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionError,
                            _resourceManager.GetString("LogConnectionError")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     An error occurred using the connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogConnectionErrorAsDebug(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionErrorAsDebug;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogConnectionErrorAsDebug,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionError,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionError",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionError,
                            _resourceManager.GetString("LogConnectionErrorAsDebug")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Created transaction savepoint.
        /// </summary>
        public static EventDefinition LogCreatedTransactionSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCreatedTransactionSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCreatedTransactionSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.CreatedTransactionSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.CreatedTransactionSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.CreatedTransactionSavepoint,
                            _resourceManager.GetString("LogCreatedTransactionSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Creating transaction savepoint.
        /// </summary>
        public static EventDefinition LogCreatingTransactionSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogCreatingTransactionSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogCreatingTransactionSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.CreatingTransactionSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.CreatingTransactionSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.CreatingTransactionSavepoint,
                            _resourceManager.GetString("LogCreatingTransactionSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     A data reader was disposed.
        /// </summary>
        public static EventDefinition LogDisposingDataReader(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingDataReader;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingDataReader,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.DataReaderDisposing,
                        LogLevel.Debug,
                        "RelationalEventId.DataReaderDisposing",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.DataReaderDisposing,
                            _resourceManager.GetString("LogDisposingDataReader")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Disposing transaction.
        /// </summary>
        public static EventDefinition LogDisposingTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogDisposingTransaction,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionDisposed,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionDisposed",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionDisposed,
                            _resourceManager.GetString("LogDisposingTransaction")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Executed DbCommand ({elapsed}ms) [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static EventDefinition<string, string, System.Data.CommandType, int, string, string> LogExecutedCommand(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogExecutedCommand;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogExecutedCommand,
                    logger,
                    static logger => new EventDefinition<string, string, System.Data.CommandType, int, string, string>(
                        logger.Options,
                        RelationalEventId.CommandExecuted,
                        LogLevel.Information,
                        "RelationalEventId.CommandExecuted",
                        level => LoggerMessage.Define<string, string, System.Data.CommandType, int, string, string>(
                            level,
                            RelationalEventId.CommandExecuted,
                            _resourceManager.GetString("LogExecutedCommand")!)));
            }

            return (EventDefinition<string, string, System.Data.CommandType, int, string, string>)definition;
        }

        /// <summary>
        ///     Executing DbCommand [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static EventDefinition<string, System.Data.CommandType, int, string, string> LogExecutingCommand(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogExecutingCommand;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogExecutingCommand,
                    logger,
                    static logger => new EventDefinition<string, System.Data.CommandType, int, string, string>(
                        logger.Options,
                        RelationalEventId.CommandExecuting,
                        LogLevel.Debug,
                        "RelationalEventId.CommandExecuting",
                        level => LoggerMessage.Define<string, System.Data.CommandType, int, string, string>(
                            level,
                            RelationalEventId.CommandExecuting,
                            _resourceManager.GetString("LogExecutingCommand")!)));
            }

            return (EventDefinition<string, System.Data.CommandType, int, string, string>)definition;
        }

        /// <summary>
        ///     Enlisted in an explicit transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogExplicitTransactionEnlisted(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogExplicitTransactionEnlisted;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogExplicitTransactionEnlisted,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.ExplicitTransactionEnlisted,
                        LogLevel.Debug,
                        "RelationalEventId.ExplicitTransactionEnlisted",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.ExplicitTransactionEnlisted,
                            _resourceManager.GetString("LogExplicitTransactionEnlisted")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     The foreign key {foreignKeyProperties} on the entity type '{entityType}' targeting '{principalEntityType}' cannot be represented in the database. Either the properties {foreignKeyProperties} aren't mapped to table '{table}', or the principal properties {principalProperties} aren't mapped to table '{principalTable}'. All foreign key properties must map to the table to which the dependent type is mapped, and all principal properties must map to a single table to which the principal type is mapped.
        /// </summary>
        public static FallbackEventDefinition LogForeignKeyPropertiesMappedToUnrelatedTables(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogForeignKeyPropertiesMappedToUnrelatedTables;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogForeignKeyPropertiesMappedToUnrelatedTables,
                    logger,
                    static logger => new FallbackEventDefinition(
                        logger.Options,
                        RelationalEventId.ForeignKeyPropertiesMappedToUnrelatedTables,
                        LogLevel.Error,
                        "RelationalEventId.ForeignKeyPropertiesMappedToUnrelatedTables",
                        _resourceManager.GetString("LogForeignKeyPropertiesMappedToUnrelatedTables")!));
            }

            return (FallbackEventDefinition)definition;
        }

        /// <summary>
        ///     Generating down script for migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogGeneratingDown(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingDown;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingDown,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationGeneratingDownScript,
                        LogLevel.Debug,
                        "RelationalEventId.MigrationGeneratingDownScript",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationGeneratingDownScript,
                            _resourceManager.GetString("LogGeneratingDown")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Generating up script for migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogGeneratingUp(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingUp;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogGeneratingUp,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationGeneratingUpScript,
                        LogLevel.Debug,
                        "RelationalEventId.MigrationGeneratingUpScript",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationGeneratingUpScript,
                            _resourceManager.GetString("LogGeneratingUp")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Property '{property}' on entity type '{entityType}' is part of a primary or alternate key, but has a constant default value set. Constant default values are not useful for primary or alternate keys since these properties must always have non-null unique values.
        /// </summary>
        public static EventDefinition<string, string> LogKeyHasDefaultValue(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogKeyHasDefaultValue;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogKeyHasDefaultValue,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ModelValidationKeyDefaultValueWarning,
                        LogLevel.Warning,
                        "RelationalEventId.ModelValidationKeyDefaultValueWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ModelValidationKeyDefaultValueWarning,
                            _resourceManager.GetString("LogKeyHasDefaultValue")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Migrating using database '{database}' on server '{dataSource}'.
        /// </summary>
        public static EventDefinition<string, string> LogMigrating(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogMigrating;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogMigrating,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.MigrateUsingConnection,
                        LogLevel.Debug,
                        "RelationalEventId.MigrateUsingConnection",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.MigrateUsingConnection,
                            _resourceManager.GetString("LogMigrating")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     A [Migration] attribute isn't specified on the '{class}' class.
        /// </summary>
        public static EventDefinition<string> LogMigrationAttributeMissingWarning(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogMigrationAttributeMissingWarning;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogMigrationAttributeMissingWarning,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationAttributeMissingWarning,
                        LogLevel.Warning,
                        "RelationalEventId.MigrationAttributeMissingWarning",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationAttributeMissingWarning,
                            _resourceManager.GetString("LogMigrationAttributeMissingWarning")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Compiling a query which loads related collections for more than one collection navigation, either via 'Include' or through projection, but no 'QuerySplittingBehavior' has been configured. By default, Entity Framework will use 'QuerySplittingBehavior.SingleQuery', which can potentially result in slow query performance. See https://go.microsoft.com/fwlink/?linkid=2134277 for more information. To identify the query that's triggering this warning call 'ConfigureWarnings(w =&gt; w.Throw(RelationalEventId.MultipleCollectionIncludeWarning))'.
        /// </summary>
        public static EventDefinition LogMultipleCollectionIncludeWarning(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogMultipleCollectionIncludeWarning;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogMultipleCollectionIncludeWarning,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.MultipleCollectionIncludeWarning,
                        LogLevel.Warning,
                        "RelationalEventId.MultipleCollectionIncludeWarning",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.MultipleCollectionIncludeWarning,
                            _resourceManager.GetString("LogMultipleCollectionIncludeWarning")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     The index named '{indexName}' on the entity type '{entityType}' specifies properties {indexProperties}, but none of these properties are mapped to a column in any table. This index will not be created in the database.
        /// </summary>
        public static EventDefinition<string?, string, string> LogNamedIndexAllPropertiesNotToMappedToAnyTable(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNamedIndexAllPropertiesNotToMappedToAnyTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNamedIndexAllPropertiesNotToMappedToAnyTable,
                    logger,
                    static logger => new EventDefinition<string?, string, string>(
                        logger.Options,
                        RelationalEventId.AllIndexPropertiesNotToMappedToAnyTable,
                        LogLevel.Information,
                        "RelationalEventId.AllIndexPropertiesNotToMappedToAnyTable",
                        level => LoggerMessage.Define<string?, string, string>(
                            level,
                            RelationalEventId.AllIndexPropertiesNotToMappedToAnyTable,
                            _resourceManager.GetString("LogNamedIndexAllPropertiesNotToMappedToAnyTable")!)));
            }

            return (EventDefinition<string?, string, string>)definition;
        }

        /// <summary>
        ///     The index named '{indexName}' on the entity type '{entityType}' specifies properties {indexProperties}. Some properties are mapped to a column in a table, but the property '{propertyName}' is not. All of the properties must be mapped for the index to be created in the database.
        /// </summary>
        public static EventDefinition<string?, string, string, string> LogNamedIndexPropertiesBothMappedAndNotMappedToTable(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNamedIndexPropertiesBothMappedAndNotMappedToTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNamedIndexPropertiesBothMappedAndNotMappedToTable,
                    logger,
                    static logger => new EventDefinition<string?, string, string, string>(
                        logger.Options,
                        RelationalEventId.IndexPropertiesBothMappedAndNotMappedToTable,
                        LogLevel.Error,
                        "RelationalEventId.IndexPropertiesBothMappedAndNotMappedToTable",
                        level => LoggerMessage.Define<string?, string, string, string>(
                            level,
                            RelationalEventId.IndexPropertiesBothMappedAndNotMappedToTable,
                            _resourceManager.GetString("LogNamedIndexPropertiesBothMappedAndNotMappedToTable")!)));
            }

            return (EventDefinition<string?, string, string, string>)definition;
        }

        /// <summary>
        ///     The index named '{indexName}' on the entity type '{entityType}' specifies properties {indexProperties}. The property '{propertyName1}' is mapped to table(s) {tables1}, whereas the property '{propertyName2}' is mapped to table(s) {tables2}. All index properties must map to at least one common table.
        /// </summary>
        public static FallbackEventDefinition LogNamedIndexPropertiesMappedToNonOverlappingTables(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNamedIndexPropertiesMappedToNonOverlappingTables;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNamedIndexPropertiesMappedToNonOverlappingTables,
                    logger,
                    static logger => new FallbackEventDefinition(
                        logger.Options,
                        RelationalEventId.IndexPropertiesMappedToNonOverlappingTables,
                        LogLevel.Error,
                        "RelationalEventId.IndexPropertiesMappedToNonOverlappingTables",
                        _resourceManager.GetString("LogNamedIndexPropertiesMappedToNonOverlappingTables")!));
            }

            return (FallbackEventDefinition)definition;
        }

        /// <summary>
        ///     No migrations were applied. The database is already up to date.
        /// </summary>
        public static EventDefinition LogNoMigrationsApplied(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsApplied;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsApplied,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.MigrationsNotApplied,
                        LogLevel.Information,
                        "RelationalEventId.MigrationsNotApplied",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.MigrationsNotApplied,
                            _resourceManager.GetString("LogNoMigrationsApplied")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     No migrations were found in assembly '{migrationsAssembly}'.
        /// </summary>
        public static EventDefinition<string> LogNoMigrationsFound(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsFound;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogNoMigrationsFound,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationsNotFound,
                        LogLevel.Debug,
                        "RelationalEventId.MigrationsNotFound",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationsNotFound,
                            _resourceManager.GetString("LogNoMigrationsFound")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Opened connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogOpenedConnection(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOpenedConnection;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOpenedConnection,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionOpened,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionOpened",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionOpened,
                            _resourceManager.GetString("LogOpenedConnection")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Opening connection to database '{database}' on server '{server}'.
        /// </summary>
        public static EventDefinition<string, string> LogOpeningConnection(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOpeningConnection;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOpeningConnection,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.ConnectionOpening,
                        LogLevel.Debug,
                        "RelationalEventId.ConnectionOpening",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.ConnectionOpening,
                            _resourceManager.GetString("LogOpeningConnection")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     The entity of type '{entityType}' is an optional dependent using table sharing. The entity does not have any property with a non-default value to identify whether the entity exists. This means that when it is queried no object instance will be created instead of an instance with all properties set to default values. Any nested dependents will also be lost. Either don't save any instance with only default values or mark the incoming navigation as required in the model. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values of the entity.
        /// </summary>
        public static EventDefinition<string> LogOptionalDependentWithAllNullProperties(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOptionalDependentWithAllNullProperties;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOptionalDependentWithAllNullProperties,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.OptionalDependentWithAllNullPropertiesWarning,
                        LogLevel.Warning,
                        "RelationalEventId.OptionalDependentWithAllNullPropertiesWarning",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.OptionalDependentWithAllNullPropertiesWarning,
                            _resourceManager.GetString("LogOptionalDependentWithAllNullProperties")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     The entity of type '{entityType}' with primary key values {keyValues} is an optional dependent using table sharing. The entity does not have any property with a non-default value to identify whether the entity exists. This means that when it is queried no object instance will be created instead of an instance with all properties set to default values. Any nested dependents will also be lost. Either don't save any instance with only default values or mark the incoming navigation as required in the model.
        /// </summary>
        public static EventDefinition<string, string> LogOptionalDependentWithAllNullPropertiesSensitive(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOptionalDependentWithAllNullPropertiesSensitive;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOptionalDependentWithAllNullPropertiesSensitive,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.OptionalDependentWithAllNullPropertiesWarning,
                        LogLevel.Warning,
                        "RelationalEventId.OptionalDependentWithAllNullPropertiesWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.OptionalDependentWithAllNullPropertiesWarning,
                            _resourceManager.GetString("LogOptionalDependentWithAllNullPropertiesSensitive")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     The entity type '{entityType}' is an optional dependent using table sharing without any required non shared property that could be used to identify whether the entity exists. If all nullable properties contain a null value in database then an object instance won't be created in the query. Add a required property to create instances with null values for other properties or mark the incoming navigation as required to always create an instance.
        /// </summary>
        public static EventDefinition<string> LogOptionalDependentWithoutIdentifyingProperty(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogOptionalDependentWithoutIdentifyingProperty;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogOptionalDependentWithoutIdentifyingProperty,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.OptionalDependentWithoutIdentifyingPropertyWarning,
                        LogLevel.Warning,
                        "RelationalEventId.OptionalDependentWithoutIdentifyingPropertyWarning",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.OptionalDependentWithoutIdentifyingPropertyWarning,
                            _resourceManager.GetString("LogOptionalDependentWithoutIdentifyingProperty")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Possible unintended use of method 'Equals' for arguments '{left}' and '{right}' of different types in a query. This comparison will always return false.
        /// </summary>
        public static EventDefinition<string, string> LogPossibleUnintendedUseOfEquals(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogPossibleUnintendedUseOfEquals;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogPossibleUnintendedUseOfEquals,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning,
                        LogLevel.Warning,
                        "RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning,
                            _resourceManager.GetString("LogPossibleUnintendedUseOfEquals")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     Possible unintended use of a potentially throwing aggregate operator ('Min', 'Max', 'Average') in a subquery. Client evaluation will be used and the operator will throw if no data exists. Changing the subquery result type to a nullable type will allow the operator to be translated.
        /// </summary>
        [Obsolete]
        public static EventDefinition LogQueryPossibleExceptionWithAggregateOperatorWarning(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogQueryPossibleExceptionWithAggregateOperatorWarning;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogQueryPossibleExceptionWithAggregateOperatorWarning,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.QueryPossibleExceptionWithAggregateOperatorWarning,
                        LogLevel.Warning,
                        "RelationalEventId.QueryPossibleExceptionWithAggregateOperatorWarning",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.QueryPossibleExceptionWithAggregateOperatorWarning,
                            _resourceManager.GetString("LogQueryPossibleExceptionWithAggregateOperatorWarning")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Released transaction savepoint.
        /// </summary>
        public static EventDefinition LogReleasedTransactionSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogReleasedTransactionSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogReleasedTransactionSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.ReleasedTransactionSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.ReleasedTransactionSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.ReleasedTransactionSavepoint,
                            _resourceManager.GetString("LogReleasedTransactionSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Releasing transaction savepoint.
        /// </summary>
        public static EventDefinition LogReleasingTransactionSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogReleasingTransactionSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogReleasingTransactionSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.ReleasingTransactionSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.ReleasingTransactionSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.ReleasingTransactionSavepoint,
                            _resourceManager.GetString("LogReleasingTransactionSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Reverting migration '{migration}'.
        /// </summary>
        public static EventDefinition<string> LogRevertingMigration(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRevertingMigration;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRevertingMigration,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.MigrationReverting,
                        LogLevel.Information,
                        "RelationalEventId.MigrationReverting",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.MigrationReverting,
                            _resourceManager.GetString("LogRevertingMigration")!)));
            }

            return (EventDefinition<string>)definition;
        }

        /// <summary>
        ///     Rolled back to transaction savepoint.
        /// </summary>
        public static EventDefinition LogRolledBackToTransactionSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRolledBackToTransactionSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRolledBackToTransactionSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.RolledBackToTransactionSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.RolledBackToTransactionSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.RolledBackToTransactionSavepoint,
                            _resourceManager.GetString("LogRolledBackToTransactionSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Rolled back transaction.
        /// </summary>
        public static EventDefinition LogRolledBackTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRolledBackTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRolledBackTransaction,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionRolledBack,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionRolledBack",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionRolledBack,
                            _resourceManager.GetString("LogRolledBackTransaction")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Rolling back to transaction savepoint.
        /// </summary>
        public static EventDefinition LogRollingBackToTransactionSavepoint(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRollingBackToTransactionSavepoint;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRollingBackToTransactionSavepoint,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.RollingBackToTransactionSavepoint,
                        LogLevel.Debug,
                        "RelationalEventId.RollingBackToTransactionSavepoint",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.RollingBackToTransactionSavepoint,
                            _resourceManager.GetString("LogRollingBackToTransactionSavepoint")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     Rolling back transaction.
        /// </summary>
        public static EventDefinition LogRollingBackTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogRollingBackTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogRollingBackTransaction,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionRollingBack,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionRollingBack",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionRollingBack,
                            _resourceManager.GetString("LogRollingBackTransaction")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     An error occurred using a transaction.
        /// </summary>
        public static EventDefinition LogTransactionError(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogTransactionError;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogTransactionError,
                    logger,
                    static logger => new EventDefinition(
                        logger.Options,
                        RelationalEventId.TransactionError,
                        LogLevel.Error,
                        "RelationalEventId.TransactionError",
                        level => LoggerMessage.Define(
                            level,
                            RelationalEventId.TransactionError,
                            _resourceManager.GetString("LogTransactionError")!)));
            }

            return (EventDefinition)definition;
        }

        /// <summary>
        ///     The unnamed index on the entity type '{entityType}' specifies properties {indexProperties}, but none of these properties are mapped to a column in any table. This index will not be created in the database.
        /// </summary>
        public static EventDefinition<string, string> LogUnnamedIndexAllPropertiesNotToMappedToAnyTable(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogUnnamedIndexAllPropertiesNotToMappedToAnyTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogUnnamedIndexAllPropertiesNotToMappedToAnyTable,
                    logger,
                    static logger => new EventDefinition<string, string>(
                        logger.Options,
                        RelationalEventId.AllIndexPropertiesNotToMappedToAnyTable,
                        LogLevel.Information,
                        "RelationalEventId.AllIndexPropertiesNotToMappedToAnyTable",
                        level => LoggerMessage.Define<string, string>(
                            level,
                            RelationalEventId.AllIndexPropertiesNotToMappedToAnyTable,
                            _resourceManager.GetString("LogUnnamedIndexAllPropertiesNotToMappedToAnyTable")!)));
            }

            return (EventDefinition<string, string>)definition;
        }

        /// <summary>
        ///     The unnamed index on the entity type '{entityType}' specifies properties {indexProperties}. Some properties are mapped to a column in a table, but the property '{propertyName}' is not. All of the properties must be mapped for the index to be created in the database.
        /// </summary>
        public static EventDefinition<string, string, string> LogUnnamedIndexPropertiesBothMappedAndNotMappedToTable(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogUnnamedIndexPropertiesBothMappedAndNotMappedToTable;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogUnnamedIndexPropertiesBothMappedAndNotMappedToTable,
                    logger,
                    static logger => new EventDefinition<string, string, string>(
                        logger.Options,
                        RelationalEventId.IndexPropertiesBothMappedAndNotMappedToTable,
                        LogLevel.Error,
                        "RelationalEventId.IndexPropertiesBothMappedAndNotMappedToTable",
                        level => LoggerMessage.Define<string, string, string>(
                            level,
                            RelationalEventId.IndexPropertiesBothMappedAndNotMappedToTable,
                            _resourceManager.GetString("LogUnnamedIndexPropertiesBothMappedAndNotMappedToTable")!)));
            }

            return (EventDefinition<string, string, string>)definition;
        }

        /// <summary>
        ///     The unnamed index on the entity type '{entityType}' specifies properties {indexProperties}. The property '{propertyName1}' is mapped to table(s) {tableList1}, whereas the property '{propertyName2}' is mapped to table(s) {tableList2}. All index properties must map to at least one common table.
        /// </summary>
        public static EventDefinition<string, string, string, string, string, string> LogUnnamedIndexPropertiesMappedToNonOverlappingTables(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogUnnamedIndexPropertiesMappedToNonOverlappingTables;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogUnnamedIndexPropertiesMappedToNonOverlappingTables,
                    logger,
                    static logger => new EventDefinition<string, string, string, string, string, string>(
                        logger.Options,
                        RelationalEventId.IndexPropertiesMappedToNonOverlappingTables,
                        LogLevel.Error,
                        "RelationalEventId.IndexPropertiesMappedToNonOverlappingTables",
                        level => LoggerMessage.Define<string, string, string, string, string, string>(
                            level,
                            RelationalEventId.IndexPropertiesMappedToNonOverlappingTables,
                            _resourceManager.GetString("LogUnnamedIndexPropertiesMappedToNonOverlappingTables")!)));
            }

            return (EventDefinition<string, string, string, string, string, string>)definition;
        }

        /// <summary>
        ///     Using an existing transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static EventDefinition<string> LogUsingTransaction(IDiagnosticsLogger logger)
        {
            var definition = ((RelationalLoggingDefinitions)logger.Definitions).LogUsingTransaction;
            if (definition == null)
            {
                definition = NonCapturingLazyInitializer.EnsureInitialized(
                    ref ((RelationalLoggingDefinitions)logger.Definitions).LogUsingTransaction,
                    logger,
                    static logger => new EventDefinition<string>(
                        logger.Options,
                        RelationalEventId.TransactionUsed,
                        LogLevel.Debug,
                        "RelationalEventId.TransactionUsed",
                        level => LoggerMessage.Define<string>(
                            level,
                            RelationalEventId.TransactionUsed,
                            _resourceManager.GetString("LogUsingTransaction")!)));
            }

            return (EventDefinition<string>)definition;
        }
    }
}
