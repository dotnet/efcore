// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Json.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class OwnedType0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
                typeof(CompiledModelTestBase.OwnedType),
                baseEntityType,
                sharedClrType: true,
                propertyCount: 13,
                servicePropertyCount: 1,
                foreignKeyCount: 1,
                keyCount: 1);

            var principalDerivedId = runtimeEntityType.AddProperty(
                "PrincipalDerivedId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalDerivedId.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: 0,
                relationshipIndex: 0,
                storeGenerationIndex: 0);
            principalDerivedId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            principalDerivedId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(principalDerivedId));

            var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                "PrincipalDerivedAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalDerivedAlternateId.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: 1,
                relationshipIndex: 1,
                storeGenerationIndex: 1);
            principalDerivedAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;
            principalDerivedAlternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(principalDerivedAlternateId));

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: 2,
                relationshipIndex: 2,
                storeGenerationIndex: 2);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            id.SetCurrentValueComparer(new EntryCurrentValueComparer<int>(id));

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            details.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadDetails(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadDetails(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadDetails(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadDetails(instance) == null);
            details.SetSetter(
                (CompiledModelTestBase.OwnedType entity, string value) => WriteDetails(entity, value));
            details.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, string value) => WriteDetails(entity, value));
            details.SetAccessors(
                (InternalEntityEntry entry) => ReadDetails((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadDetails((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(details, 3),
                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(details),
                (ValueBuffer valueBuffer) => valueBuffer[3]);
            details.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            details.TypeMapping = SqliteStringTypeMapping.Default;

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            number.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadNumber(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadNumber(entity) == 0,
                (CompiledModelTestBase.OwnedType instance) => ReadNumber(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadNumber(instance) == 0);
            number.SetSetter(
                (CompiledModelTestBase.OwnedType entity, int value) => WriteNumber(entity, value));
            number.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, int value) => WriteNumber(entity, value));
            number.SetAccessors(
                (InternalEntityEntry entry) => ReadNumber((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadNumber((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(number, 4),
                (InternalEntityEntry entry) => entry.GetCurrentValue<int>(number),
                (ValueBuffer valueBuffer) => valueBuffer[4]);
            number.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeArray(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeArray(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeArray(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeArray(instance) == null);
            refTypeArray.SetSetter(
                (CompiledModelTestBase.OwnedType entity, IPAddress[] value) => WriteRefTypeArray(entity, value));
            refTypeArray.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, IPAddress[] value) => WriteRefTypeArray(entity, value));
            refTypeArray.SetAccessors(
                (InternalEntityEntry entry) => ReadRefTypeArray((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadRefTypeArray((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress[]>(refTypeArray, 5),
                (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress[]>(refTypeArray),
                (ValueBuffer valueBuffer) => valueBuffer[5]);
            refTypeArray.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeEnumerable(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeEnumerable(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeEnumerable(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeEnumerable(instance) == null);
            refTypeEnumerable.SetSetter(
                (CompiledModelTestBase.OwnedType entity, IEnumerable<string> value) => WriteRefTypeEnumerable(entity, value));
            refTypeEnumerable.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, IEnumerable<string> value) => WriteRefTypeEnumerable(entity, value));
            refTypeEnumerable.SetAccessors(
                (InternalEntityEntry entry) => ReadRefTypeEnumerable((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadRefTypeEnumerable((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<string>>(refTypeEnumerable, 6),
                (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable),
                (ValueBuffer valueBuffer) => valueBuffer[6]);
            refTypeEnumerable.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeIList(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeIList(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeIList(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeIList(instance) == null);
            refTypeIList.SetSetter(
                (CompiledModelTestBase.OwnedType entity, IList<string> value) => WriteRefTypeIList(entity, value));
            refTypeIList.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, IList<string> value) => WriteRefTypeIList(entity, value));
            refTypeIList.SetAccessors(
                (InternalEntityEntry entry) => ReadRefTypeIList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadRefTypeIList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<string>>(refTypeIList, 7),
                (InternalEntityEntry entry) => entry.GetCurrentValue<IList<string>>(refTypeIList),
                (ValueBuffer valueBuffer) => valueBuffer[7]);
            refTypeIList.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeList(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadRefTypeList(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeList(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadRefTypeList(instance) == null);
            refTypeList.SetSetter(
                (CompiledModelTestBase.OwnedType entity, List<IPAddress> value) => WriteRefTypeList(entity, value));
            refTypeList.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, List<IPAddress> value) => WriteRefTypeList(entity, value));
            refTypeList.SetAccessors(
                (InternalEntityEntry entry) => ReadRefTypeList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadRefTypeList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<List<IPAddress>>(refTypeList, 8),
                (InternalEntityEntry entry) => entry.GetCurrentValue<List<IPAddress>>(refTypeList),
                (ValueBuffer valueBuffer) => valueBuffer[8]);
            refTypeList.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeArray(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeArray(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeArray(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeArray(instance) == null);
            valueTypeArray.SetSetter(
                (CompiledModelTestBase.OwnedType entity, DateTime[] value) => WriteValueTypeArray(entity, value));
            valueTypeArray.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, DateTime[] value) => WriteValueTypeArray(entity, value));
            valueTypeArray.SetAccessors(
                (InternalEntityEntry entry) => ReadValueTypeArray((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadValueTypeArray((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime[]>(valueTypeArray, 9),
                (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime[]>(valueTypeArray),
                (ValueBuffer valueBuffer) => valueBuffer[9]);
            valueTypeArray.SetPropertyIndexes(
                index: 9,
                originalValueIndex: 9,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeEnumerable(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeEnumerable(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeEnumerable(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeEnumerable(instance) == null);
            valueTypeEnumerable.SetSetter(
                (CompiledModelTestBase.OwnedType entity, IEnumerable<byte> value) => WriteValueTypeEnumerable(entity, value));
            valueTypeEnumerable.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, IEnumerable<byte> value) => WriteValueTypeEnumerable(entity, value));
            valueTypeEnumerable.SetAccessors(
                (InternalEntityEntry entry) => ReadValueTypeEnumerable((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadValueTypeEnumerable((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<byte>>(valueTypeEnumerable, 10),
                (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable),
                (ValueBuffer valueBuffer) => valueBuffer[10]);
            valueTypeEnumerable.SetPropertyIndexes(
                index: 10,
                originalValueIndex: 10,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeIList(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeIList(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeIList(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeIList(instance) == null);
            valueTypeIList.SetSetter(
                (CompiledModelTestBase.OwnedType entity, IList<byte> value) => WriteValueTypeIList(entity, value));
            valueTypeIList.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, IList<byte> value) => WriteValueTypeIList(entity, value));
            valueTypeIList.SetAccessors(
                (InternalEntityEntry entry) => ReadValueTypeIList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadValueTypeIList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<byte>>(valueTypeIList, 11),
                (InternalEntityEntry entry) => entry.GetCurrentValue<IList<byte>>(valueTypeIList),
                (ValueBuffer valueBuffer) => valueBuffer[11]);
            valueTypeIList.SetPropertyIndexes(
                index: 11,
                originalValueIndex: 11,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.SetGetter(
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeList(entity),
                (CompiledModelTestBase.OwnedType entity) => ReadValueTypeList(entity) == null,
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeList(instance),
                (CompiledModelTestBase.OwnedType instance) => ReadValueTypeList(instance) == null);
            valueTypeList.SetSetter(
                (CompiledModelTestBase.OwnedType entity, List<short> value) => WriteValueTypeList(entity, value));
            valueTypeList.SetMaterializationSetter(
                (CompiledModelTestBase.OwnedType entity, List<short> value) => WriteValueTypeList(entity, value));
            valueTypeList.SetAccessors(
                (InternalEntityEntry entry) => ReadValueTypeList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => ReadValueTypeList((CompiledModelTestBase.OwnedType)entry.Entity),
                (InternalEntityEntry entry) => entry.ReadOriginalValue<List<short>>(valueTypeList, 12),
                (InternalEntityEntry entry) => entry.GetCurrentValue<List<short>>(valueTypeList),
                (ValueBuffer valueBuffer) => valueBuffer[12]);
            valueTypeList.SetPropertyIndexes(
                index: 12,
                originalValueIndex: 12,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalDerivedId, principalDerivedAlternateId, id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalDerivedId"), declaringEntityType.FindProperty("PrincipalDerivedAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var manyOwned = principalEntityType.AddNavigation("ManyOwned",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CompiledModelTestBase.OwnedType>),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>).GetField("ManyOwned", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            manyOwned.SetGetter(
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity) => PrincipalDerivedEntityType.ReadManyOwned(entity),
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity) => PrincipalDerivedEntityType.ReadManyOwned(entity) == null,
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> instance) => PrincipalDerivedEntityType.ReadManyOwned(instance),
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> instance) => PrincipalDerivedEntityType.ReadManyOwned(instance) == null);
            manyOwned.SetSetter(
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity, ICollection<CompiledModelTestBase.OwnedType> value) => PrincipalDerivedEntityType.WriteManyOwned(entity, value));
            manyOwned.SetMaterializationSetter(
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity, ICollection<CompiledModelTestBase.OwnedType> value) => PrincipalDerivedEntityType.WriteManyOwned(entity, value));
            manyOwned.SetAccessors(
                (InternalEntityEntry entry) => PrincipalDerivedEntityType.ReadManyOwned((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>)entry.Entity),
                (InternalEntityEntry entry) => PrincipalDerivedEntityType.ReadManyOwned((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>)entry.Entity),
                null,
                (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.OwnedType>>(manyOwned),
                null);
            manyOwned.SetPropertyIndexes(
                index: 3,
                originalValueIndex: -1,
                shadowIndex: -1,
                relationshipIndex: 5,
                storeGenerationIndex: -1);
            manyOwned.SetCollectionAccessor<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.OwnedType>, CompiledModelTestBase.OwnedType>(
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity) => PrincipalDerivedEntityType.ReadManyOwned(entity),
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity, ICollection<CompiledModelTestBase.OwnedType> collection) => PrincipalDerivedEntityType.WriteManyOwned(entity, (ICollection<CompiledModelTestBase.OwnedType>)collection),
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity, ICollection<CompiledModelTestBase.OwnedType> collection) => PrincipalDerivedEntityType.WriteManyOwned(entity, (ICollection<CompiledModelTestBase.OwnedType>)collection),
                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> entity, Action<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>, ICollection<CompiledModelTestBase.OwnedType>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>, ICollection<CompiledModelTestBase.OwnedType>, CompiledModelTestBase.OwnedType>(entity, setter),
                () => (ICollection<CompiledModelTestBase.OwnedType>)(ICollection<CompiledModelTestBase.OwnedType>)new HashSet<CompiledModelTestBase.OwnedType>(ReferenceEqualityComparer.Instance));
            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var principalDerivedId = runtimeEntityType.FindProperty("PrincipalDerivedId")!;
            var principalDerivedAlternateId = runtimeEntityType.FindProperty("PrincipalDerivedAlternateId")!;
            var id = runtimeEntityType.FindProperty("Id")!;
            var details = runtimeEntityType.FindProperty("Details")!;
            var number = runtimeEntityType.FindProperty("Number")!;
            var refTypeArray = runtimeEntityType.FindProperty("RefTypeArray")!;
            var refTypeEnumerable = runtimeEntityType.FindProperty("RefTypeEnumerable")!;
            var refTypeIList = runtimeEntityType.FindProperty("RefTypeIList")!;
            var refTypeList = runtimeEntityType.FindProperty("RefTypeList")!;
            var valueTypeArray = runtimeEntityType.FindProperty("ValueTypeArray")!;
            var valueTypeEnumerable = runtimeEntityType.FindProperty("ValueTypeEnumerable")!;
            var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
            var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
            runtimeEntityType.SetOriginalValuesFactory(
                (InternalEntityEntry source) =>
                {
                    var entity = (CompiledModelTestBase.OwnedType)source.Entity;
                    return (ISnapshot)new Snapshot<long, Guid, int, string, int, IPAddress[], IEnumerable<string>, IList<string>, List<IPAddress>, DateTime[], IEnumerable<byte>, IList<byte>, List<short>>(((ValueComparer<long>)principalDerivedId.GetValueComparer()).Snapshot(source.GetCurrentValue<long>(principalDerivedId)), ((ValueComparer<Guid>)principalDerivedAlternateId.GetValueComparer()).Snapshot(source.GetCurrentValue<Guid>(principalDerivedAlternateId)), ((ValueComparer<int>)id.GetValueComparer()).Snapshot(source.GetCurrentValue<int>(id)), source.GetCurrentValue<string>(details) == null ? null : ((ValueComparer<string>)details.GetValueComparer()).Snapshot(source.GetCurrentValue<string>(details)), ((ValueComparer<int>)number.GetValueComparer()).Snapshot(source.GetCurrentValue<int>(number)), (IEnumerable<IPAddress>)source.GetCurrentValue<IPAddress[]>(refTypeArray) == null ? null : (IPAddress[])((ValueComparer<IEnumerable<IPAddress>>)refTypeArray.GetValueComparer()).Snapshot((IEnumerable<IPAddress>)source.GetCurrentValue<IPAddress[]>(refTypeArray)), source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable) == null ? null : ((ValueComparer<IEnumerable<string>>)refTypeEnumerable.GetValueComparer()).Snapshot(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable)), (IEnumerable<string>)source.GetCurrentValue<IList<string>>(refTypeIList) == null ? null : (IList<string>)((ValueComparer<IEnumerable<string>>)refTypeIList.GetValueComparer()).Snapshot((IEnumerable<string>)source.GetCurrentValue<IList<string>>(refTypeIList)), (IEnumerable<IPAddress>)source.GetCurrentValue<List<IPAddress>>(refTypeList) == null ? null : (List<IPAddress>)((ValueComparer<IEnumerable<IPAddress>>)refTypeList.GetValueComparer()).Snapshot((IEnumerable<IPAddress>)source.GetCurrentValue<List<IPAddress>>(refTypeList)), (IEnumerable<DateTime>)source.GetCurrentValue<DateTime[]>(valueTypeArray) == null ? null : (DateTime[])((ValueComparer<IEnumerable<DateTime>>)valueTypeArray.GetValueComparer()).Snapshot((IEnumerable<DateTime>)source.GetCurrentValue<DateTime[]>(valueTypeArray)), source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable) == null ? null : ((ValueComparer<IEnumerable<byte>>)valueTypeEnumerable.GetValueComparer()).Snapshot(source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable)), (IEnumerable<byte>)source.GetCurrentValue<IList<byte>>(valueTypeIList) == null ? null : (IList<byte>)((ValueComparer<IEnumerable<byte>>)valueTypeIList.GetValueComparer()).Snapshot((IEnumerable<byte>)source.GetCurrentValue<IList<byte>>(valueTypeIList)), (IEnumerable<short>)source.GetCurrentValue<List<short>>(valueTypeList) == null ? null : (List<short>)((ValueComparer<IEnumerable<short>>)valueTypeList.GetValueComparer()).Snapshot((IEnumerable<short>)source.GetCurrentValue<List<short>>(valueTypeList)));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                () => (ISnapshot)new Snapshot<long, Guid, int>(((ValueComparer<long>)principalDerivedId.GetValueComparer()).Snapshot(default(long)), ((ValueComparer<Guid>)principalDerivedAlternateId.GetValueComparer()).Snapshot(default(Guid)), ((ValueComparer<int>)id.GetValueComparer()).Snapshot(default(int))));
            runtimeEntityType.SetTemporaryValuesFactory(
                (InternalEntityEntry source) => (ISnapshot)new Snapshot<long, Guid, int>(default(long), default(Guid), default(int)));
            runtimeEntityType.SetShadowValuesFactory(
                (IDictionary<string, object> source) => (ISnapshot)new Snapshot<long, Guid, int>(source.ContainsKey("PrincipalDerivedId") ? (long)source["PrincipalDerivedId"] : 0L, source.ContainsKey("PrincipalDerivedAlternateId") ? (Guid)source["PrincipalDerivedAlternateId"] : new Guid("00000000-0000-0000-0000-000000000000"), source.ContainsKey("Id") ? (int)source["Id"] : 0));
            runtimeEntityType.SetEmptyShadowValuesFactory(
                () => (ISnapshot)new Snapshot<long, Guid, int>(default(long), default(Guid), default(int)));
            runtimeEntityType.SetRelationshipSnapshotFactory(
                (InternalEntityEntry source) =>
                {
                    var entity = (CompiledModelTestBase.OwnedType)source.Entity;
                    return (ISnapshot)new Snapshot<long, Guid, int>(((ValueComparer<long>)principalDerivedId.GetKeyValueComparer()).Snapshot(source.GetCurrentValue<long>(principalDerivedId)), ((ValueComparer<Guid>)principalDerivedAlternateId.GetKeyValueComparer()).Snapshot(source.GetCurrentValue<Guid>(principalDerivedAlternateId)), ((ValueComparer<int>)id.GetKeyValueComparer()).Snapshot(source.GetCurrentValue<int>(id)));
                });
            runtimeEntityType.Counts = new PropertyCounts(
                propertyCount: 13,
                navigationCount: 0,
                complexPropertyCount: 0,
                originalValueCount: 13,
                shadowCount: 3,
                relationshipCount: 3,
                storeGeneratedCount: 3);
            runtimeEntityType.AddAnnotation("Relational:ContainerColumnName", "ManyOwned");
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_details")]
        extern static ref string GetDetails(CompiledModelTestBase.OwnedType @this);

        public static string ReadDetails(CompiledModelTestBase.OwnedType @this)
            => GetDetails(@this);

        public static void WriteDetails(CompiledModelTestBase.OwnedType @this, string value)
            => GetDetails(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Number>k__BackingField")]
        extern static ref int GetNumber(CompiledModelTestBase.OwnedType @this);

        public static int ReadNumber(CompiledModelTestBase.OwnedType @this)
            => GetNumber(@this);

        public static void WriteNumber(CompiledModelTestBase.OwnedType @this, int value)
            => GetNumber(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeArray")]
        extern static ref IPAddress[] GetRefTypeArray(CompiledModelTestBase.OwnedType @this);

        public static IPAddress[] ReadRefTypeArray(CompiledModelTestBase.OwnedType @this)
            => GetRefTypeArray(@this);

        public static void WriteRefTypeArray(CompiledModelTestBase.OwnedType @this, IPAddress[] value)
            => GetRefTypeArray(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeEnumerable")]
        extern static ref IEnumerable<string> GetRefTypeEnumerable(CompiledModelTestBase.OwnedType @this);

        public static IEnumerable<string> ReadRefTypeEnumerable(CompiledModelTestBase.OwnedType @this)
            => GetRefTypeEnumerable(@this);

        public static void WriteRefTypeEnumerable(CompiledModelTestBase.OwnedType @this, IEnumerable<string> value)
            => GetRefTypeEnumerable(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeIList")]
        extern static ref IList<string> GetRefTypeIList(CompiledModelTestBase.OwnedType @this);

        public static IList<string> ReadRefTypeIList(CompiledModelTestBase.OwnedType @this)
            => GetRefTypeIList(@this);

        public static void WriteRefTypeIList(CompiledModelTestBase.OwnedType @this, IList<string> value)
            => GetRefTypeIList(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeList")]
        extern static ref List<IPAddress> GetRefTypeList(CompiledModelTestBase.OwnedType @this);

        public static List<IPAddress> ReadRefTypeList(CompiledModelTestBase.OwnedType @this)
            => GetRefTypeList(@this);

        public static void WriteRefTypeList(CompiledModelTestBase.OwnedType @this, List<IPAddress> value)
            => GetRefTypeList(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_valueTypeArray")]
        extern static ref DateTime[] GetValueTypeArray(CompiledModelTestBase.OwnedType @this);

        public static DateTime[] ReadValueTypeArray(CompiledModelTestBase.OwnedType @this)
            => GetValueTypeArray(@this);

        public static void WriteValueTypeArray(CompiledModelTestBase.OwnedType @this, DateTime[] value)
            => GetValueTypeArray(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_valueTypeEnumerable")]
        extern static ref IEnumerable<byte> GetValueTypeEnumerable(CompiledModelTestBase.OwnedType @this);

        public static IEnumerable<byte> ReadValueTypeEnumerable(CompiledModelTestBase.OwnedType @this)
            => GetValueTypeEnumerable(@this);

        public static void WriteValueTypeEnumerable(CompiledModelTestBase.OwnedType @this, IEnumerable<byte> value)
            => GetValueTypeEnumerable(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeIList>k__BackingField")]
        extern static ref IList<byte> GetValueTypeIList(CompiledModelTestBase.OwnedType @this);

        public static IList<byte> ReadValueTypeIList(CompiledModelTestBase.OwnedType @this)
            => GetValueTypeIList(@this);

        public static void WriteValueTypeIList(CompiledModelTestBase.OwnedType @this, IList<byte> value)
            => GetValueTypeIList(@this) = value;

        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_valueTypeList")]
        extern static ref List<short> GetValueTypeList(CompiledModelTestBase.OwnedType @this);

        public static List<short> ReadValueTypeList(CompiledModelTestBase.OwnedType @this)
            => GetValueTypeList(@this);

        public static void WriteValueTypeList(CompiledModelTestBase.OwnedType @this, List<short> value)
            => GetValueTypeList(@this) = value;
    }
}
