// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                typeof(CompiledModelTestBase.PrincipalBase),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalBase",
                derivedTypesCount: 1,
                propertyCount: 15,
                complexPropertyCount: 1,
                navigationCount: 1,
                foreignKeyCount: 1,
                unnamedIndexCount: 1,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                clrType: typeof(long),
                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);

            var discriminator = runtimeEntityType.AddProperty(
                "Discriminator",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            discriminator.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CompiledModelTestBase.AnEnum),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CompiledModelTestBase.AnEnum)0);
            enum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                    (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AnEnum v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                    (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AnEnum v) => v),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                    (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AnEnum v) => v),
                clrType: typeof(CompiledModelTestBase.AnEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CompiledModelTestBase.AnEnum?),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                    (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                    (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                    (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                clrType: typeof(CompiledModelTestBase.AnEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CompiledModelTestBase.AFlagsEnum),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CompiledModelTestBase.AFlagsEnum)0);
            flagsEnum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                clrType: typeof(CompiledModelTestBase.AFlagsEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CompiledModelTestBase.AFlagsEnum),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CompiledModelTestBase.AFlagsEnum)0);
            flagsEnum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                clrType: typeof(CompiledModelTestBase.AFlagsEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long?),
                nullable: true);
            principalBaseId.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                clrType: typeof(long),
                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    clrType: typeof(string),
                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    clrType: typeof(string),
                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    clrType: typeof(DateTime),
                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    clrType: typeof(byte),
                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    clrType: typeof(byte),
                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    clrType: typeof(short),
                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));

            OwnedComplexProperty.Create(runtimeEntityType);
            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalBaseId });

            return runtimeEntityType;
        }

        private static class OwnedComplexProperty
        {
            public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
            {
                var complexProperty = declaringType.AddComplexProperty("Owned",
                    typeof(CompiledModelTestBase.OwnedType),
                    "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
                    typeof(CompiledModelTestBase.OwnedType),
                    propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    propertyAccessMode: PropertyAccessMode.Field,
                    changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                    propertyCount: 10,
                    complexPropertyCount: 1);

                var complexType = complexProperty.ComplexType;
                var details = complexType.AddProperty(
                    "Details",
                    typeof(string),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                    nullable: true,
                    concurrencyToken: true,
                    valueGenerated: ValueGenerated.OnAddOrUpdate,
                    beforeSaveBehavior: PropertySaveBehavior.Ignore,
                    afterSaveBehavior: PropertySaveBehavior.Ignore,
                    maxLength: 64,
                    unicode: false,
                    precision: 3,
                    scale: 2,
                    sentinel: "");
                details.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    clrType: typeof(string),
                    jsonValueReaderWriter: JsonStringReaderWriter.Instance);
                details.AddAnnotation("foo", "bar");

                var number = complexType.AddProperty(
                    "Number",
                    typeof(int),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    sentinel: 0);
                number.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    clrType: typeof(int),
                    jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

                var refTypeArray = complexType.AddProperty(
                    "RefTypeArray",
                    typeof(IPAddress[]),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v))))),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        keyComparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))));

                var refTypeEnumerable = complexType.AddProperty(
                    "RefTypeEnumerable",
                    typeof(IEnumerable<string>),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    keyComparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance)),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        keyComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        clrType: typeof(string),
                        jsonValueReaderWriter: JsonStringReaderWriter.Instance));

                var refTypeIList = complexType.AddProperty(
                    "RefTypeIList",
                    typeof(IList<string>),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    keyComparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance)),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        keyComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        clrType: typeof(string),
                        jsonValueReaderWriter: JsonStringReaderWriter.Instance));

                var refTypeList = complexType.AddProperty(
                    "RefTypeList",
                    typeof(List<IPAddress>),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v))))),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        keyComparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))));

                var valueTypeArray = complexType.AddProperty(
                    "ValueTypeArray",
                    typeof(DateTime[]),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)),
                    keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                        JsonDateTimeReaderWriter.Instance)),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                        JsonDateTimeReaderWriter.Instance),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        keyComparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        providerValueComparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        clrType: typeof(DateTime),
                        jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));

                var valueTypeEnumerable = complexType.AddProperty(
                    "ValueTypeEnumerable",
                    typeof(IEnumerable<byte>),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance)),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        keyComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        providerValueComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        clrType: typeof(byte),
                        jsonValueReaderWriter: JsonByteReaderWriter.Instance));

                var valueTypeIList = complexType.AddProperty(
                    "ValueTypeIList",
                    typeof(IList<byte>),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance)),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        keyComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        providerValueComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        clrType: typeof(byte),
                        jsonValueReaderWriter: JsonByteReaderWriter.Instance));

                var valueTypeList = complexType.AddProperty(
                    "ValueTypeList",
                    typeof(List<short>),
                    propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                    comparer: new ListComparer<short>(new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)),
                    keyComparer: new ListComparer<short>(new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                        JsonInt16ReaderWriter.Instance)),
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                        JsonInt16ReaderWriter.Instance),
                    elementMapping: InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        keyComparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        providerValueComparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        clrType: typeof(short),
                        jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));

                PrincipalComplexProperty.Create(complexType);
                complexType.AddAnnotation("go", "brr");
                complexProperty.AddAnnotation("goo", "ber");
                return complexProperty;
            }

            private static class PrincipalComplexProperty
            {
                public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                {
                    var complexProperty = declaringType.AddComplexProperty("Principal",
                        typeof(CompiledModelTestBase.PrincipalBase),
                        "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType.Principal#PrincipalBase",
                        typeof(CompiledModelTestBase.PrincipalBase),
                        propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        propertyCount: 14);

                    var complexType = complexProperty.ComplexType;
                    var alternateId = complexType.AddProperty(
                        "AlternateId",
                        typeof(Guid),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
                    alternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        keyComparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        providerValueComparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        clrType: typeof(Guid),
                        jsonValueReaderWriter: JsonGuidReaderWriter.Instance);

                    var enum1 = complexType.AddProperty(
                        "Enum1",
                        typeof(CompiledModelTestBase.AnEnum),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: (CompiledModelTestBase.AnEnum)0);
                    enum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                            (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AnEnum v) => v),
                        keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                            (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AnEnum v) => v),
                        providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                            (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AnEnum v) => v),
                        clrType: typeof(CompiledModelTestBase.AnEnum),
                        jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);

                    var enum2 = complexType.AddProperty(
                        "Enum2",
                        typeof(CompiledModelTestBase.AnEnum?),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    enum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                            (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                        keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                            (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                        providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                            (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                        clrType: typeof(CompiledModelTestBase.AnEnum),
                        jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);

                    var flagsEnum1 = complexType.AddProperty(
                        "FlagsEnum1",
                        typeof(CompiledModelTestBase.AFlagsEnum),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: (CompiledModelTestBase.AFlagsEnum)0);
                    flagsEnum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                            (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AFlagsEnum v) => v),
                        keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                            (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AFlagsEnum v) => v),
                        providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                            (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AFlagsEnum v) => v),
                        clrType: typeof(CompiledModelTestBase.AFlagsEnum),
                        jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);

                    var flagsEnum2 = complexType.AddProperty(
                        "FlagsEnum2",
                        typeof(CompiledModelTestBase.AFlagsEnum),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: (CompiledModelTestBase.AFlagsEnum)0);
                    flagsEnum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                            (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AFlagsEnum v) => v),
                        keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                            (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AFlagsEnum v) => v),
                        providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                            (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                            (CompiledModelTestBase.AFlagsEnum v) => v),
                        clrType: typeof(CompiledModelTestBase.AFlagsEnum),
                        jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);

                    var id = complexType.AddProperty(
                        "Id",
                        typeof(long?),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        keyComparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        providerValueComparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        clrType: typeof(long),
                        jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);

                    var refTypeArray = complexType.AddProperty(
                        "RefTypeArray",
                        typeof(IPAddress[]),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v))))),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            keyComparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            converter: new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)),
                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))));

                    var refTypeEnumerable = complexType.AddProperty(
                        "RefTypeEnumerable",
                        typeof(IEnumerable<string>),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        keyComparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance)),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            keyComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            clrType: typeof(string),
                            jsonValueReaderWriter: JsonStringReaderWriter.Instance));

                    var refTypeIList = complexType.AddProperty(
                        "RefTypeIList",
                        typeof(IList<string>),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        keyComparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance)),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            keyComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            clrType: typeof(string),
                            jsonValueReaderWriter: JsonStringReaderWriter.Instance));

                    var refTypeList = complexType.AddProperty(
                        "RefTypeList",
                        typeof(List<IPAddress>),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v))))),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            keyComparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            converter: new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)),
                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))));

                    var valueTypeArray = complexType.AddProperty(
                        "ValueTypeArray",
                        typeof(DateTime[]),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)),
                        keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                            JsonDateTimeReaderWriter.Instance)),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                            JsonDateTimeReaderWriter.Instance),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            keyComparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            providerValueComparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            clrType: typeof(DateTime),
                            jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));

                    var valueTypeEnumerable = complexType.AddProperty(
                        "ValueTypeEnumerable",
                        typeof(IEnumerable<byte>),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance)),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            keyComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            providerValueComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            clrType: typeof(byte),
                            jsonValueReaderWriter: JsonByteReaderWriter.Instance));

                    var valueTypeIList = complexType.AddProperty(
                        "ValueTypeIList",
                        typeof(IList<byte>),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance)),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            keyComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            providerValueComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            clrType: typeof(byte),
                            jsonValueReaderWriter: JsonByteReaderWriter.Instance));

                    var valueTypeList = complexType.AddProperty(
                        "ValueTypeList",
                        typeof(List<short>),
                        propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                        comparer: new ListComparer<short>(new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)),
                        keyComparer: new ListComparer<short>(new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                            JsonInt16ReaderWriter.Instance)),
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                            JsonInt16ReaderWriter.Instance),
                        elementMapping: InMemoryTypeMapping.Default.Clone(
                            comparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            keyComparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            providerValueComparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            clrType: typeof(short),
                            jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));

                    return complexProperty;
                }
            }
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType);

            var deriveds = principalEntityType.AddNavigation("Deriveds",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CompiledModelTestBase.PrincipalBase>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
