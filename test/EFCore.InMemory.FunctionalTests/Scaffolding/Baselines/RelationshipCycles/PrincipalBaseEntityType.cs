// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                typeof(CompiledModelTestBase.PrincipalBase),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalBase",
                derivedTypesCount: 1,
                propertyCount: 15,
                navigationCount: 1,
                foreignKeyCount: 1,
                keyCount: 2);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                clrType: typeof(long),
                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);

            var discriminator = runtimeEntityType.AddProperty(
                "Discriminator",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            discriminator.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CompiledModelTestBase.AnEnum),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CompiledModelTestBase.AnEnum)0);
            enum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                    (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AnEnum v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                    (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AnEnum v) => v),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
                    (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AnEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AnEnum v) => v),
                clrType: typeof(CompiledModelTestBase.AnEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CompiledModelTestBase.AnEnum?),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                    (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                    (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum?>(
                    (Nullable<CompiledModelTestBase.AnEnum> v1, Nullable<CompiledModelTestBase.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.AnEnum)v1, (object)(CompiledModelTestBase.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? ((CompiledModelTestBase.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.AnEnum> v) => v.HasValue ? (Nullable<CompiledModelTestBase.AnEnum>)(CompiledModelTestBase.AnEnum)v : default(Nullable<CompiledModelTestBase.AnEnum>)),
                clrType: typeof(CompiledModelTestBase.AnEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CompiledModelTestBase.AFlagsEnum),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CompiledModelTestBase.AFlagsEnum)0);
            flagsEnum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                clrType: typeof(CompiledModelTestBase.AFlagsEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CompiledModelTestBase.AFlagsEnum),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CompiledModelTestBase.AFlagsEnum)0);
            flagsEnum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
                    (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.AFlagsEnum v) => v.GetHashCode(),
                    (CompiledModelTestBase.AFlagsEnum v) => v),
                clrType: typeof(CompiledModelTestBase.AFlagsEnum),
                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);

            var principalId = runtimeEntityType.AddProperty(
                "PrincipalId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalId.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                clrType: typeof(long),
                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    clrType: typeof(string),
                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    clrType: typeof(string),
                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    clrType: typeof(DateTime),
                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    clrType: typeof(byte),
                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    clrType: typeof(byte),
                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: InMemoryTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    clrType: typeof(short),
                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var key0 = runtimeEntityType.AddKey(
                new[] { principalId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("Id") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("PrincipalId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
