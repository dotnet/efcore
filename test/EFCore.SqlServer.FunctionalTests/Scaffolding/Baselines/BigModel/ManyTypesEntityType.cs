// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using System.Text;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [EntityFrameworkInternal]
    public partial class ManyTypesEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
                typeof(CompiledModelTestBase.ManyTypes),
                baseEntityType,
                propertyCount: 241,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(CompiledModelTestBase.ManyTypesId),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueConverter: new CompiledModelTestBase.ManyTypesIdConverter());
            id.SetGetter(
                CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Id(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Id(instance).Equals(default(CompiledModelTestBase.ManyTypesId)));
            id.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.ManyTypesId value) =>
                {
                    ManyTypesUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.ManyTypesId value) =>
                {
                    ManyTypesUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetAccessors(
                CompiledModelTestBase.ManyTypesId (IInternalEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<CompiledModelTestBase.ManyTypesId>(0) : (entry.FlaggedAsTemporary(0) && ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))).Equals(default(CompiledModelTestBase.ManyTypesId)) ? entry.ReadTemporaryValue<CompiledModelTestBase.ManyTypesId>(0) : ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                CompiledModelTestBase.ManyTypesId (IInternalEntry entry) => ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.ManyTypesId (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.ManyTypesId>(id, 0),
                CompiledModelTestBase.ManyTypesId (IInternalEntry entry) => ((InternalEntityEntry)(entry)).ReadRelationshipSnapshotValue<CompiledModelTestBase.ManyTypesId>(id, 0));
            id.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: -1,
                relationshipIndex: 0,
                storeGenerationIndex: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
                    bool (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
                    int (CompiledModelTestBase.ManyTypesId v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypesId v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
                    bool (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
                    int (CompiledModelTestBase.ManyTypesId v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypesId v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.ManyTypesId, int>(
                    int (CompiledModelTestBase.ManyTypesId v) => v.Id,
                    CompiledModelTestBase.ManyTypesId (int v) => new CompiledModelTestBase.ManyTypesId(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.ManyTypesId, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.ManyTypesId, int>(
                        int (CompiledModelTestBase.ManyTypesId v) => v.Id,
                        CompiledModelTestBase.ManyTypesId (int v) => new CompiledModelTestBase.ManyTypesId(v))));
            id.SetCurrentValueComparer(new CurrentProviderValueComparer<CompiledModelTestBase.ManyTypesId, int>(id));
            id.SetSentinelFromProviderValue(0);
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var @bool = runtimeEntityType.AddProperty(
                "Bool",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            @bool.SetGetter(
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bool(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bool(instance) == false);
            @bool.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.Bool(instance) = value;
                    return instance;
                });
            @bool.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.Bool(instance) = value;
                    return instance;
                });
            @bool.SetAccessors(
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.Bool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.Bool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(@bool, 1),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(@bool));
            @bool.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            @bool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v));
            @bool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolArray = runtimeEntityType.AddProperty(
                "BoolArray",
                typeof(bool[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolArray.SetGetter(
                bool[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolArray(instance) == null);
            boolArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool[] value) =>
                {
                    ManyTypesUnsafeAccessors.BoolArray(instance) = value;
                    return instance;
                });
            boolArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool[] value) =>
                {
                    ManyTypesUnsafeAccessors.BoolArray(instance) = value;
                    return instance;
                });
            boolArray.SetAccessors(
                bool[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool[] (IInternalEntry entry) => entry.ReadOriginalValue<bool[]>(boolArray, 2),
                bool[] (IInternalEntry entry) => entry.GetCurrentValue<bool[]>(boolArray));
            boolArray.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            boolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v)),
                keyComparer: new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionOfStructsReaderWriter<bool[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<bool[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v)));
            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
            boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                "BoolReadOnlyCollection",
                typeof(IReadOnlyCollection<bool>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_boolReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolReadOnlyCollection.SetGetter(
                IReadOnlyCollection<bool> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance)))),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance) == null);
            boolReadOnlyCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<bool> value) =>
                {
                    ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance) = ((List<bool>)(value));
                    return instance;
                });
            boolReadOnlyCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<bool> value) =>
                {
                    ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance) = ((List<bool>)(value));
                    return instance;
                });
            boolReadOnlyCollection.SetAccessors(
                IReadOnlyCollection<bool> (IInternalEntry entry) => ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<bool> (IInternalEntry entry) => ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<bool> (IInternalEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection, 3),
                IReadOnlyCollection<bool> (IInternalEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection));
            boolReadOnlyCollection.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            boolReadOnlyCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<bool>, bool>(new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<bool>, bool>(new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionOfStructsReaderWriter<List<bool>, bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<bool>, bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v)));
            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
            boolReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                "BoolToStringConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolToStringConverterProperty.SetGetter(
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(instance) == false);
            boolToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.BoolToStringConverterProperty(instance) = value;
                    return instance;
                });
            boolToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.BoolToStringConverterProperty(instance) = value;
                    return instance;
                });
            boolToStringConverterProperty.SetAccessors(
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(boolToStringConverterProperty, 4),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(boolToStringConverterProperty));
            boolToStringConverterProperty.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            boolToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<bool, string>(
                    string (bool v) => ((string)((v ? "B" : "A"))),
                    bool (string v) => !(string.IsNullOrEmpty(v)) && ((int)(v.ToUpperInvariant()[0])) == ((int)("B".ToUpperInvariant()[0]))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<bool, string>(
                        string (bool v) => ((string)((v ? "B" : "A"))),
                        bool (string v) => !(string.IsNullOrEmpty(v)) && ((int)(v.ToUpperInvariant()[0])) == ((int)("B".ToUpperInvariant()[0])))));
            boolToStringConverterProperty.SetSentinelFromProviderValue("A");
            boolToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolToTwoValuesConverterProperty = runtimeEntityType.AddProperty(
                "BoolToTwoValuesConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToTwoValuesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToTwoValuesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolToTwoValuesConverterProperty.SetGetter(
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(instance) == false);
            boolToTwoValuesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(instance) = value;
                    return instance;
                });
            boolToTwoValuesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(instance) = value;
                    return instance;
                });
            boolToTwoValuesConverterProperty.SetAccessors(
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(boolToTwoValuesConverterProperty, 5),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(boolToTwoValuesConverterProperty));
            boolToTwoValuesConverterProperty.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            boolToTwoValuesConverterProperty.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<bool, byte>(
                    byte (bool v) => ((byte)((v ? 1 : 0))),
                    bool (byte v) => v == 1),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<bool, byte>(
                        byte (bool v) => ((byte)((v ? 1 : 0))),
                        bool (byte v) => v == 1)));
            boolToTwoValuesConverterProperty.SetSentinelFromProviderValue((byte)0);
            boolToTwoValuesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolToZeroOneConverterProperty = runtimeEntityType.AddProperty(
                "BoolToZeroOneConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToZeroOneConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToZeroOneConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new BoolToZeroOneConverter<short>());
            boolToZeroOneConverterProperty.SetGetter(
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(instance) == false);
            boolToZeroOneConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(instance) = value;
                    return instance;
                });
            boolToZeroOneConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool value) =>
                {
                    ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(instance) = value;
                    return instance;
                });
            boolToZeroOneConverterProperty.SetAccessors(
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(boolToZeroOneConverterProperty, 6),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(boolToZeroOneConverterProperty));
            boolToZeroOneConverterProperty.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            boolToZeroOneConverterProperty.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<bool, short>(
                    short (bool v) => ((short)((v ? 1 : 0))),
                    bool (short v) => v == 1),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<bool, short>(
                        short (bool v) => ((short)((v ? 1 : 0))),
                        bool (short v) => v == 1)));
            boolToZeroOneConverterProperty.SetSentinelFromProviderValue((short)0);
            boolToZeroOneConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytes = runtimeEntityType.AddProperty(
                "Bytes",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            bytes.SetGetter(
                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bytes(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bytes(instance) == null);
            bytes.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.Bytes(instance) = value;
                    return instance;
                });
            bytes.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.Bytes(instance) = value;
                    return instance;
                });
            bytes.SetAccessors(
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Bytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Bytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(bytes, 7),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(bytes));
            bytes.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            bytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            bytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytesArray = runtimeEntityType.AddProperty(
                "BytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            bytesArray.SetGetter(
                byte[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesArray(instance) == null);
            bytesArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[][] value) =>
                {
                    ManyTypesUnsafeAccessors.BytesArray(instance) = value;
                    return instance;
                });
            bytesArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[][] value) =>
                {
                    ManyTypesUnsafeAccessors.BytesArray(instance) = value;
                    return instance;
                });
            bytesArray.SetAccessors(
                byte[][] (IInternalEntry entry) => ManyTypesUnsafeAccessors.BytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[][] (IInternalEntry entry) => ManyTypesUnsafeAccessors.BytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[][] (IInternalEntry entry) => entry.ReadOriginalValue<byte[][]>(bytesArray, 8),
                byte[][] (IInternalEntry entry) => entry.GetCurrentValue<byte[][]>(bytesArray));
            bytesArray.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            bytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                        int (byte[] v) => ((object)v).GetHashCode(),
                        byte[] (byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                        byte[] (byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                        byte[] (byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
            bytesArrayElementType.TypeMapping = bytesArray.TypeMapping.ElementTypeMapping;
            bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                "BytesToStringConverterProperty",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new BytesToStringConverter(),
                valueComparer: new ArrayStructuralComparer<byte>());
            bytesToStringConverterProperty.SetGetter(
                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(instance) == null);
            bytesToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.BytesToStringConverterProperty(instance) = value;
                    return instance;
                });
            bytesToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.BytesToStringConverterProperty(instance) = value;
                    return instance;
                });
            bytesToStringConverterProperty.SetAccessors(
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(bytesToStringConverterProperty, 9),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(bytesToStringConverterProperty));
            bytesToStringConverterProperty.SetPropertyIndexes(
                index: 9,
                originalValueIndex: 9,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            bytesToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<byte[], string>(
                    string (byte[] v) => Convert.ToBase64String(v),
                    byte[] (string v) => Convert.FromBase64String(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<byte[], string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<byte[], string>(
                        string (byte[] v) => Convert.ToBase64String(v),
                        byte[] (string v) => Convert.FromBase64String(v))));
            bytesToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var castingConverterProperty = runtimeEntityType.AddProperty(
                "CastingConverterProperty",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CastingConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CastingConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new CastingConverter<int, decimal>());
            castingConverterProperty.SetGetter(
                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CastingConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CastingConverterProperty(instance) == 0);
            castingConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.CastingConverterProperty(instance) = value;
                    return instance;
                });
            castingConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.CastingConverterProperty(instance) = value;
                    return instance;
                });
            castingConverterProperty.SetAccessors(
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.CastingConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.CastingConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => entry.ReadOriginalValue<int>(castingConverterProperty, 10),
                int (IInternalEntry entry) => entry.GetCurrentValue<int>(castingConverterProperty));
            castingConverterProperty.SetPropertyIndexes(
                index: 10,
                originalValueIndex: 10,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            castingConverterProperty.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                converter: new ValueConverter<int, decimal>(
                    decimal (int v) => ((decimal)(v)),
                    int (decimal v) => ((int)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<int, decimal>(
                        decimal (int v) => ((decimal)(v)),
                        int (decimal v) => ((int)(v)))));
            castingConverterProperty.SetSentinelFromProviderValue(0m);
            castingConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @char = runtimeEntityType.AddProperty(
                "Char",
                typeof(char),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            @char.SetGetter(
                char (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Char(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Char(instance) == '\0');
            @char.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char value) =>
                {
                    ManyTypesUnsafeAccessors.Char(instance) = value;
                    return instance;
                });
            @char.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char value) =>
                {
                    ManyTypesUnsafeAccessors.Char(instance) = value;
                    return instance;
                });
            @char.SetAccessors(
                char (IInternalEntry entry) => ManyTypesUnsafeAccessors.Char(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char (IInternalEntry entry) => ManyTypesUnsafeAccessors.Char(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char (IInternalEntry entry) => entry.ReadOriginalValue<char>(@char, 11),
                char (IInternalEntry entry) => entry.GetCurrentValue<char>(@char));
            @char.SetPropertyIndexes(
                index: 11,
                originalValueIndex: 11,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            @char.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v),
                keyComparer: new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                    char (string v) => (v.Length < 1 ? '\0' : v[0])),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        char (string v) => (v.Length < 1 ? '\0' : v[0]))));
            @char.SetSentinelFromProviderValue("\0");
            @char.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var charArray = runtimeEntityType.AddProperty(
                "CharArray",
                typeof(char[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            charArray.SetGetter(
                char[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharArray(instance) == null);
            charArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char[] value) =>
                {
                    ManyTypesUnsafeAccessors.CharArray(instance) = value;
                    return instance;
                });
            charArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char[] value) =>
                {
                    ManyTypesUnsafeAccessors.CharArray(instance) = value;
                    return instance;
                });
            charArray.SetAccessors(
                char[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.CharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.CharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char[] (IInternalEntry entry) => entry.ReadOriginalValue<char[]>(charArray, 12),
                char[] (IInternalEntry entry) => entry.GetCurrentValue<char[]>(charArray));
            charArray.SetPropertyIndexes(
                index: 12,
                originalValueIndex: 12,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            charArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v)),
                keyComparer: new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionOfStructsReaderWriter<char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                            char (string v) => (v.Length < 1 ? '\0' : v[0]))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                            char (string v) => (v.Length < 1 ? '\0' : v[0])))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        bool (char v1, char v2) => v1 == v2,
                        int (char v) => ((int)(v)),
                        char (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        bool (char v1, char v2) => v1 == v2,
                        int (char v) => ((int)(v)),
                        char (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        char (string v) => (v.Length < 1 ? '\0' : v[0])),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                            char (string v) => (v.Length < 1 ? '\0' : v[0])))));
            var charArrayElementType = charArray.SetElementType(typeof(char));
            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
            charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var charToStringConverterProperty = runtimeEntityType.AddProperty(
                "CharToStringConverterProperty",
                typeof(char),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new CharToStringConverter());
            charToStringConverterProperty.SetGetter(
                char (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(instance) == '\0');
            charToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char value) =>
                {
                    ManyTypesUnsafeAccessors.CharToStringConverterProperty(instance) = value;
                    return instance;
                });
            charToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char value) =>
                {
                    ManyTypesUnsafeAccessors.CharToStringConverterProperty(instance) = value;
                    return instance;
                });
            charToStringConverterProperty.SetAccessors(
                char (IInternalEntry entry) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char (IInternalEntry entry) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char (IInternalEntry entry) => entry.ReadOriginalValue<char>(charToStringConverterProperty, 13),
                char (IInternalEntry entry) => entry.GetCurrentValue<char>(charToStringConverterProperty));
            charToStringConverterProperty.SetPropertyIndexes(
                index: 13,
                originalValueIndex: 13,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            charToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v),
                keyComparer: new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nchar(1)",
                    size: 1,
                    unicode: true,
                    fixedLength: true,
                    dbType: System.Data.DbType.StringFixedLength),
                converter: new ValueConverter<char, string>(
                    string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                    char (string v) => (v.Length < 1 ? '\0' : v[0])),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        char (string v) => (v.Length < 1 ? '\0' : v[0]))));
            charToStringConverterProperty.SetSentinelFromProviderValue("\0");
            charToStringConverterProperty.AddAnnotation("Relational:IsFixedLength", true);
            charToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnly = runtimeEntityType.AddProperty(
                "DateOnly",
                typeof(DateOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dateOnly.SetGetter(
                DateOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnly(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnly(instance) == default(DateOnly));
            dateOnly.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly value) =>
                {
                    ManyTypesUnsafeAccessors.DateOnly(instance) = value;
                    return instance;
                });
            dateOnly.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly value) =>
                {
                    ManyTypesUnsafeAccessors.DateOnly(instance) = value;
                    return instance;
                });
            dateOnly.SetAccessors(
                DateOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly (IInternalEntry entry) => entry.ReadOriginalValue<DateOnly>(dateOnly, 14),
                DateOnly (IInternalEntry entry) => entry.GetCurrentValue<DateOnly>(dateOnly));
            dateOnly.SetPropertyIndexes(
                index: 14,
                originalValueIndex: 14,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v));
            dateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnlyArray = runtimeEntityType.AddProperty(
                "DateOnlyArray",
                typeof(DateOnly[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            dateOnlyArray.SetGetter(
                DateOnly[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyArray(instance) == null);
            dateOnlyArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly[] value) =>
                {
                    ManyTypesUnsafeAccessors.DateOnlyArray(instance) = value;
                    return instance;
                });
            dateOnlyArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly[] value) =>
                {
                    ManyTypesUnsafeAccessors.DateOnlyArray(instance) = value;
                    return instance;
                });
            dateOnlyArray.SetAccessors(
                DateOnly[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly[] (IInternalEntry entry) => entry.ReadOriginalValue<DateOnly[]>(dateOnlyArray, 15),
                DateOnly[] (IInternalEntry entry) => entry.GetCurrentValue<DateOnly[]>(dateOnlyArray));
            dateOnlyArray.SetPropertyIndexes(
                index: 15,
                originalValueIndex: 15,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<DateOnly[], DateOnly>(new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v)),
                keyComparer: new ListOfValueTypesComparer<DateOnly[], DateOnly>(new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionOfStructsReaderWriter<DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        int (DateOnly v) => ((object)v).GetHashCode(),
                        DateOnly (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        int (DateOnly v) => ((object)v).GetHashCode(),
                        DateOnly (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        int (DateOnly v) => ((object)v).GetHashCode(),
                        DateOnly (DateOnly v) => v)));
            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
            dateOnlyArrayElementType.TypeMapping = dateOnlyArray.TypeMapping.ElementTypeMapping;
            dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateOnlyToStringConverterProperty",
                typeof(DateOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateOnlyToStringConverter());
            dateOnlyToStringConverterProperty.SetGetter(
                DateOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(instance) == default(DateOnly));
            dateOnlyToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly value) =>
                {
                    ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(instance) = value;
                    return instance;
                });
            dateOnlyToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly value) =>
                {
                    ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(instance) = value;
                    return instance;
                });
            dateOnlyToStringConverterProperty.SetAccessors(
                DateOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly (IInternalEntry entry) => entry.ReadOriginalValue<DateOnly>(dateOnlyToStringConverterProperty, 16),
                DateOnly (IInternalEntry entry) => entry.GetCurrentValue<DateOnly>(dateOnlyToStringConverterProperty));
            dateOnlyToStringConverterProperty.SetPropertyIndexes(
                index: 16,
                originalValueIndex: 16,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateOnlyToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(10)",
                    size: 10,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<DateOnly, string>(
                    string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
                    DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateOnly, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateOnly, string>(
                        string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
                        DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
            dateOnlyToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01");
            dateOnlyToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTime = runtimeEntityType.AddProperty(
                "DateTime",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTime.SetGetter(
                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTime(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTime(instance) == default(DateTime));
            dateTime.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTime(instance) = value;
                    return instance;
                });
            dateTime.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTime(instance) = value;
                    return instance;
                });
            dateTime.SetAccessors(
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => entry.ReadOriginalValue<DateTime>(dateTime, 17),
                DateTime (IInternalEntry entry) => entry.GetCurrentValue<DateTime>(dateTime));
            dateTime.SetPropertyIndexes(
                index: 17,
                originalValueIndex: 17,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v));
            dateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeArray = runtimeEntityType.AddProperty(
                "DateTimeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            dateTimeArray.SetGetter(
                DateTime[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeArray(instance) == null);
            dateTimeArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime[] value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeArray(instance) = value;
                    return instance;
                });
            dateTimeArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime[] value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeArray(instance) = value;
                    return instance;
                });
            dateTimeArray.SetAccessors(
                DateTime[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime[] (IInternalEntry entry) => entry.ReadOriginalValue<DateTime[]>(dateTimeArray, 18),
                DateTime[] (IInternalEntry entry) => entry.GetCurrentValue<DateTime[]>(dateTimeArray));
            dateTimeArray.SetPropertyIndexes(
                index: 18,
                originalValueIndex: 18,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v)),
                keyComparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                        int (DateTime v) => ((object)v).GetHashCode(),
                        DateTime (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                        int (DateTime v) => ((object)v).GetHashCode(),
                        DateTime (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                        int (DateTime v) => ((object)v).GetHashCode(),
                        DateTime (DateTime v) => v)));
            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
            dateTimeArrayElementType.TypeMapping = dateTimeArray.TypeMapping.ElementTypeMapping;
            dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToBinaryConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBinaryConverter());
            dateTimeOffsetToBinaryConverterProperty.SetGetter(
                DateTimeOffset (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(instance).EqualsExact(default(DateTimeOffset)));
            dateTimeOffsetToBinaryConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTimeOffset value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeOffsetToBinaryConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTimeOffset value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeOffsetToBinaryConverterProperty.SetAccessors(
                DateTimeOffset (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(dateTimeOffsetToBinaryConverterProperty, 19),
                DateTimeOffset (IInternalEntry entry) => entry.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBinaryConverterProperty));
            dateTimeOffsetToBinaryConverterProperty.SetPropertyIndexes(
                index: 19,
                originalValueIndex: 19,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeOffsetToBinaryConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<DateTimeOffset, long>(
                    long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                    DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, long>(
                        long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                        DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v))));
            dateTimeOffsetToBinaryConverterProperty.SetSentinelFromProviderValue(0L);
            dateTimeOffsetToBinaryConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeOffsetToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToBytesConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBytesConverter());
            dateTimeOffsetToBytesConverterProperty.SetGetter(
                DateTimeOffset (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(instance).EqualsExact(default(DateTimeOffset)));
            dateTimeOffsetToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTimeOffset value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeOffsetToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTimeOffset value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeOffsetToBytesConverterProperty.SetAccessors(
                DateTimeOffset (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(dateTimeOffsetToBytesConverterProperty, 20),
                DateTimeOffset (IInternalEntry entry) => entry.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBytesConverterProperty));
            dateTimeOffsetToBytesConverterProperty.SetPropertyIndexes(
                index: 20,
                originalValueIndex: 20,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeOffsetToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(12)",
                    size: 12),
                converter: new ValueConverter<DateTimeOffset, byte[]>(
                    byte[] (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
                    DateTimeOffset (byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, byte[]>(
                        byte[] (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
                        DateTimeOffset (byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v))));
            dateTimeOffsetToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            dateTimeOffsetToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeOffsetToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToStringConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToStringConverter());
            dateTimeOffsetToStringConverterProperty.SetGetter(
                DateTimeOffset (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(instance).EqualsExact(default(DateTimeOffset)));
            dateTimeOffsetToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTimeOffset value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeOffsetToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTimeOffset value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeOffsetToStringConverterProperty.SetAccessors(
                DateTimeOffset (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(dateTimeOffsetToStringConverterProperty, 21),
                DateTimeOffset (IInternalEntry entry) => entry.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToStringConverterProperty));
            dateTimeOffsetToStringConverterProperty.SetPropertyIndexes(
                index: 21,
                originalValueIndex: 21,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeOffsetToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<DateTimeOffset, string>(
                    string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
                    DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, string>(
                        string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
                        DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture))));
            dateTimeOffsetToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00+00:00");
            dateTimeOffsetToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeToBinaryConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToBinaryConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeToBinaryConverter());
            dateTimeToBinaryConverterProperty.SetGetter(
                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(instance) == default(DateTime));
            dateTimeToBinaryConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeToBinaryConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeToBinaryConverterProperty.SetAccessors(
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => entry.ReadOriginalValue<DateTime>(dateTimeToBinaryConverterProperty, 22),
                DateTime (IInternalEntry entry) => entry.GetCurrentValue<DateTime>(dateTimeToBinaryConverterProperty));
            dateTimeToBinaryConverterProperty.SetPropertyIndexes(
                index: 22,
                originalValueIndex: 22,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeToBinaryConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<DateTime, long>(
                    long (DateTime v) => v.ToBinary(),
                    DateTime (long v) => DateTime.FromBinary(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTime, long>(
                        long (DateTime v) => v.ToBinary(),
                        DateTime (long v) => DateTime.FromBinary(v))));
            dateTimeToBinaryConverterProperty.SetSentinelFromProviderValue(0L);
            dateTimeToBinaryConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToStringConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeToStringConverter());
            dateTimeToStringConverterProperty.SetGetter(
                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(instance) == default(DateTime));
            dateTimeToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeToStringConverterProperty.SetAccessors(
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => entry.ReadOriginalValue<DateTime>(dateTimeToStringConverterProperty, 23),
                DateTime (IInternalEntry entry) => entry.GetCurrentValue<DateTime>(dateTimeToStringConverterProperty));
            dateTimeToStringConverterProperty.SetPropertyIndexes(
                index: 23,
                originalValueIndex: 23,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<DateTime, string>(
                    string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
                    DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateTime, string>(
                        string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
                        DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture))));
            dateTimeToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00");
            dateTimeToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeToTicksConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToTicksConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTimeToTicksConverterProperty.SetGetter(
                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(instance) == default(DateTime));
            dateTimeToTicksConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeToTicksConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime value) =>
                {
                    ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(instance) = value;
                    return instance;
                });
            dateTimeToTicksConverterProperty.SetAccessors(
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime (IInternalEntry entry) => entry.ReadOriginalValue<DateTime>(dateTimeToTicksConverterProperty, 24),
                DateTime (IInternalEntry entry) => entry.GetCurrentValue<DateTime>(dateTimeToTicksConverterProperty));
            dateTimeToTicksConverterProperty.SetPropertyIndexes(
                index: 24,
                originalValueIndex: 24,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dateTimeToTicksConverterProperty.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v));
            dateTimeToTicksConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @decimal = runtimeEntityType.AddProperty(
                "Decimal",
                typeof(decimal),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0m);
            @decimal.SetGetter(
                decimal (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Decimal(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Decimal(instance) == 0M);
            @decimal.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal value) =>
                {
                    ManyTypesUnsafeAccessors.Decimal(instance) = value;
                    return instance;
                });
            @decimal.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal value) =>
                {
                    ManyTypesUnsafeAccessors.Decimal(instance) = value;
                    return instance;
                });
            @decimal.SetAccessors(
                decimal (IInternalEntry entry) => ManyTypesUnsafeAccessors.Decimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal (IInternalEntry entry) => ManyTypesUnsafeAccessors.Decimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal (IInternalEntry entry) => entry.ReadOriginalValue<decimal>(@decimal, 25),
                decimal (IInternalEntry entry) => entry.GetCurrentValue<decimal>(@decimal));
            @decimal.SetPropertyIndexes(
                index: 25,
                originalValueIndex: 25,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            @decimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v));
            @decimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalArray = runtimeEntityType.AddProperty(
                "DecimalArray",
                typeof(decimal[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            decimalArray.SetGetter(
                decimal[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalArray(instance) == null);
            decimalArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal[] value) =>
                {
                    ManyTypesUnsafeAccessors.DecimalArray(instance) = value;
                    return instance;
                });
            decimalArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal[] value) =>
                {
                    ManyTypesUnsafeAccessors.DecimalArray(instance) = value;
                    return instance;
                });
            decimalArray.SetAccessors(
                decimal[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal[] (IInternalEntry entry) => entry.ReadOriginalValue<decimal[]>(decimalArray, 26),
                decimal[] (IInternalEntry entry) => entry.GetCurrentValue<decimal[]>(decimalArray));
            decimalArray.SetPropertyIndexes(
                index: 26,
                originalValueIndex: 26,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            decimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<decimal[], decimal>(new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v)),
                keyComparer: new ListOfValueTypesComparer<decimal[], decimal>(new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionOfStructsReaderWriter<decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v)));
            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
            decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DecimalNumberToBytesConverterProperty",
                typeof(decimal),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<decimal>());
            decimalNumberToBytesConverterProperty.SetGetter(
                decimal (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(instance) == 0M);
            decimalNumberToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal value) =>
                {
                    ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(instance) = value;
                    return instance;
                });
            decimalNumberToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal value) =>
                {
                    ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(instance) = value;
                    return instance;
                });
            decimalNumberToBytesConverterProperty.SetAccessors(
                decimal (IInternalEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal (IInternalEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal (IInternalEntry entry) => entry.ReadOriginalValue<decimal>(decimalNumberToBytesConverterProperty, 27),
                decimal (IInternalEntry entry) => entry.GetCurrentValue<decimal>(decimalNumberToBytesConverterProperty));
            decimalNumberToBytesConverterProperty.SetPropertyIndexes(
                index: 27,
                originalValueIndex: 27,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            decimalNumberToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(16)",
                    size: 16),
                converter: new ValueConverter<decimal, byte[]>(
                    byte[] (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
                    decimal (byte[] v) => (v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<decimal, byte[]>(
                        byte[] (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
                        decimal (byte[] v) => (v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v)))));
            decimalNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            decimalNumberToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "DecimalNumberToStringConverterProperty",
                typeof(decimal),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<decimal>());
            decimalNumberToStringConverterProperty.SetGetter(
                decimal (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(instance) == 0M);
            decimalNumberToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal value) =>
                {
                    ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(instance) = value;
                    return instance;
                });
            decimalNumberToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal value) =>
                {
                    ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(instance) = value;
                    return instance;
                });
            decimalNumberToStringConverterProperty.SetAccessors(
                decimal (IInternalEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal (IInternalEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal (IInternalEntry entry) => entry.ReadOriginalValue<decimal>(decimalNumberToStringConverterProperty, 28),
                decimal (IInternalEntry entry) => entry.GetCurrentValue<decimal>(decimalNumberToStringConverterProperty));
            decimalNumberToStringConverterProperty.SetPropertyIndexes(
                index: 28,
                originalValueIndex: 28,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            decimalNumberToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(64)",
                    size: 64,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<decimal, string>(
                    string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                    decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<decimal, string>(
                        string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            decimalNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
            decimalNumberToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @double = runtimeEntityType.AddProperty(
                "Double",
                typeof(double),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0.0);
            @double.SetGetter(
                double (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Double(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Double(instance).Equals(0D));
            @double.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double value) =>
                {
                    ManyTypesUnsafeAccessors.Double(instance) = value;
                    return instance;
                });
            @double.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double value) =>
                {
                    ManyTypesUnsafeAccessors.Double(instance) = value;
                    return instance;
                });
            @double.SetAccessors(
                double (IInternalEntry entry) => ManyTypesUnsafeAccessors.Double(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double (IInternalEntry entry) => ManyTypesUnsafeAccessors.Double(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double (IInternalEntry entry) => entry.ReadOriginalValue<double>(@double, 29),
                double (IInternalEntry entry) => entry.GetCurrentValue<double>(@double));
            @double.SetPropertyIndexes(
                index: 29,
                originalValueIndex: 29,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            @double.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                keyComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v));
            @double.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleArray = runtimeEntityType.AddProperty(
                "DoubleArray",
                typeof(double[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            doubleArray.SetGetter(
                double[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleArray(instance) == null);
            doubleArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double[] value) =>
                {
                    ManyTypesUnsafeAccessors.DoubleArray(instance) = value;
                    return instance;
                });
            doubleArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double[] value) =>
                {
                    ManyTypesUnsafeAccessors.DoubleArray(instance) = value;
                    return instance;
                });
            doubleArray.SetAccessors(
                double[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.DoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double[] (IInternalEntry entry) => entry.ReadOriginalValue<double[]>(doubleArray, 30),
                double[] (IInternalEntry entry) => entry.GetCurrentValue<double[]>(doubleArray));
            doubleArray.SetPropertyIndexes(
                index: 30,
                originalValueIndex: 30,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            doubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<double[], double>(new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v)),
                keyComparer: new ListOfValueTypesComparer<double[], double>(new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionOfStructsReaderWriter<double[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<double[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        bool (double v1, double v2) => v1.Equals(v2),
                        int (double v) => ((object)v).GetHashCode(),
                        double (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        bool (double v1, double v2) => v1.Equals(v2),
                        int (double v) => ((object)v).GetHashCode(),
                        double (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        bool (double v1, double v2) => v1.Equals(v2),
                        int (double v) => ((object)v).GetHashCode(),
                        double (double v) => v)));
            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
            doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DoubleNumberToBytesConverterProperty",
                typeof(double),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<double>());
            doubleNumberToBytesConverterProperty.SetGetter(
                double (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(instance).Equals(0D));
            doubleNumberToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double value) =>
                {
                    ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(instance) = value;
                    return instance;
                });
            doubleNumberToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double value) =>
                {
                    ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(instance) = value;
                    return instance;
                });
            doubleNumberToBytesConverterProperty.SetAccessors(
                double (IInternalEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double (IInternalEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double (IInternalEntry entry) => entry.ReadOriginalValue<double>(doubleNumberToBytesConverterProperty, 31),
                double (IInternalEntry entry) => entry.GetCurrentValue<double>(doubleNumberToBytesConverterProperty));
            doubleNumberToBytesConverterProperty.SetPropertyIndexes(
                index: 31,
                originalValueIndex: 31,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            doubleNumberToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                keyComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(8)",
                    size: 8),
                converter: new ValueConverter<double, byte[]>(
                    byte[] (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
                    double (byte[] v) => (v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<double, byte[]>(
                        byte[] (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
                        double (byte[] v) => (v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0)))));
            doubleNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
            doubleNumberToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "DoubleNumberToStringConverterProperty",
                typeof(double),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<double>());
            doubleNumberToStringConverterProperty.SetGetter(
                double (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(instance).Equals(0D));
            doubleNumberToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double value) =>
                {
                    ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(instance) = value;
                    return instance;
                });
            doubleNumberToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double value) =>
                {
                    ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(instance) = value;
                    return instance;
                });
            doubleNumberToStringConverterProperty.SetAccessors(
                double (IInternalEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double (IInternalEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double (IInternalEntry entry) => entry.ReadOriginalValue<double>(doubleNumberToStringConverterProperty, 32),
                double (IInternalEntry entry) => entry.GetCurrentValue<double>(doubleNumberToStringConverterProperty));
            doubleNumberToStringConverterProperty.SetPropertyIndexes(
                index: 32,
                originalValueIndex: 32,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            doubleNumberToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                keyComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(64)",
                    size: 64,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<double, string>(
                    string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v))),
                    double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<double, string>(
                        string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v))),
                        double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            doubleNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
            doubleNumberToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16 = runtimeEntityType.AddProperty(
                "Enum16",
                typeof(CompiledModelTestBase.Enum16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16.SetGetter(
                CompiledModelTestBase.Enum16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum16(instance))), ((object)(CompiledModelTestBase.Enum16.Default))));
            enum16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16(instance) = value;
                    return instance;
                });
            enum16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16(instance) = value;
                    return instance;
                });
            enum16.SetAccessors(
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16>(enum16, 33),
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16));
            enum16.SetPropertyIndexes(
                index: 33,
                originalValueIndex: 33,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                    short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                    CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))));
            enum16.SetSentinelFromProviderValue((short)0);
            enum16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16Array = runtimeEntityType.AddProperty(
                "Enum16Array",
                typeof(CompiledModelTestBase.Enum16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16Array.SetGetter(
                CompiledModelTestBase.Enum16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Array(instance) == null);
            enum16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16Array(instance) = value;
                    return instance;
                });
            enum16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16Array(instance) = value;
                    return instance;
                });
            enum16Array.SetAccessors(
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16[]>(enum16Array, 34),
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16Array));
            enum16Array.SetPropertyIndexes(
                index: 34,
                originalValueIndex: 34,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
            enum16ArrayElementType.TypeMapping = enum16Array.TypeMapping.ElementTypeMapping;
            enum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16AsString = runtimeEntityType.AddProperty(
                "Enum16AsString",
                typeof(CompiledModelTestBase.Enum16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum16AsString.SetGetter(
                CompiledModelTestBase.Enum16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum16AsString(instance))), ((object)(CompiledModelTestBase.Enum16.Default))));
            enum16AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16AsString(instance) = value;
                    return instance;
                });
            enum16AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16AsString(instance) = value;
                    return instance;
                });
            enum16AsString.SetAccessors(
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16>(enum16AsString, 35),
                CompiledModelTestBase.Enum16 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16AsString));
            enum16AsString.SetPropertyIndexes(
                index: 35,
                originalValueIndex: 35,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum16AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
                    string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                    CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, string>(
                        string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))));
            enum16AsString.SetSentinelFromProviderValue("Default");
            enum16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16AsStringArray = runtimeEntityType.AddProperty(
                "Enum16AsStringArray",
                typeof(CompiledModelTestBase.Enum16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16AsStringArray.SetGetter(
                CompiledModelTestBase.Enum16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringArray(instance) == null);
            enum16AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16AsStringArray(instance) = value;
                    return instance;
                });
            enum16AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16AsStringArray(instance) = value;
                    return instance;
                });
            enum16AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray, 36),
                CompiledModelTestBase.Enum16[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray));
            enum16AsStringArray.SetPropertyIndexes(
                index: 36,
                originalValueIndex: 36,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
                        string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
                providerClrType: typeof(string));
            enum16AsStringArrayElementType.TypeMapping = enum16AsStringArray.TypeMapping.ElementTypeMapping;
            enum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16AsStringCollection = runtimeEntityType.AddProperty(
                "Enum16AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(instance) == null);
            enum16AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16AsStringCollection(instance) = value;
                    return instance;
                });
            enum16AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16AsStringCollection(instance) = value;
                    return instance;
                });
            enum16AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection, 37),
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection));
            enum16AsStringCollection.SetPropertyIndexes(
                index: 37,
                originalValueIndex: 37,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
                        string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
                providerClrType: typeof(string));
            enum16AsStringCollectionElementType.TypeMapping = enum16AsStringCollection.TypeMapping.ElementTypeMapping;
            enum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16Collection = runtimeEntityType.AddProperty(
                "Enum16Collection",
                typeof(List<CompiledModelTestBase.Enum16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16Collection.SetGetter(
                List<CompiledModelTestBase.Enum16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Collection(instance) == null);
            enum16Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16Collection(instance) = value;
                    return instance;
                });
            enum16Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum16Collection(instance) = value;
                    return instance;
                });
            enum16Collection.SetAccessors(
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16>>(enum16Collection, 38),
                List<CompiledModelTestBase.Enum16> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16Collection));
            enum16Collection.SetPropertyIndexes(
                index: 38,
                originalValueIndex: 38,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
            enum16CollectionElementType.TypeMapping = enum16Collection.TypeMapping.ElementTypeMapping;
            enum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32 = runtimeEntityType.AddProperty(
                "Enum32",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32.SetGetter(
                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum32(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
            enum32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32(instance) = value;
                    return instance;
                });
            enum32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32(instance) = value;
                    return instance;
                });
            enum32.SetAccessors(
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enum32, 39),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32));
            enum32.SetPropertyIndexes(
                index: 39,
                originalValueIndex: 39,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                    CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))));
            enum32.SetSentinelFromProviderValue(0);
            enum32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32Array = runtimeEntityType.AddProperty(
                "Enum32Array",
                typeof(CompiledModelTestBase.Enum32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32Array.SetGetter(
                CompiledModelTestBase.Enum32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Array(instance) == null);
            enum32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32Array(instance) = value;
                    return instance;
                });
            enum32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32Array(instance) = value;
                    return instance;
                });
            enum32Array.SetAccessors(
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32[]>(enum32Array, 40),
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32Array));
            enum32Array.SetPropertyIndexes(
                index: 40,
                originalValueIndex: 40,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
            enum32ArrayElementType.TypeMapping = enum32Array.TypeMapping.ElementTypeMapping;
            enum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32AsString = runtimeEntityType.AddProperty(
                "Enum32AsString",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum32AsString.SetGetter(
                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum32AsString(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
            enum32AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32AsString(instance) = value;
                    return instance;
                });
            enum32AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32AsString(instance) = value;
                    return instance;
                });
            enum32AsString.SetAccessors(
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enum32AsString, 41),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32AsString));
            enum32AsString.SetPropertyIndexes(
                index: 41,
                originalValueIndex: 41,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum32AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                    string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                    CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))));
            enum32AsString.SetSentinelFromProviderValue("Default");
            enum32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32AsStringArray = runtimeEntityType.AddProperty(
                "Enum32AsStringArray",
                typeof(CompiledModelTestBase.Enum32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32AsStringArray.SetGetter(
                CompiledModelTestBase.Enum32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringArray(instance) == null);
            enum32AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32AsStringArray(instance) = value;
                    return instance;
                });
            enum32AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32AsStringArray(instance) = value;
                    return instance;
                });
            enum32AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray, 42),
                CompiledModelTestBase.Enum32[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray));
            enum32AsStringArray.SetPropertyIndexes(
                index: 42,
                originalValueIndex: 42,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
                providerClrType: typeof(string));
            enum32AsStringArrayElementType.TypeMapping = enum32AsStringArray.TypeMapping.ElementTypeMapping;
            enum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32AsStringCollection = runtimeEntityType.AddProperty(
                "Enum32AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(instance) == null);
            enum32AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32AsStringCollection(instance) = value;
                    return instance;
                });
            enum32AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32AsStringCollection(instance) = value;
                    return instance;
                });
            enum32AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection, 43),
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection));
            enum32AsStringCollection.SetPropertyIndexes(
                index: 43,
                originalValueIndex: 43,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
                providerClrType: typeof(string));
            enum32AsStringCollectionElementType.TypeMapping = enum32AsStringCollection.TypeMapping.ElementTypeMapping;
            enum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32Collection = runtimeEntityType.AddProperty(
                "Enum32Collection",
                typeof(List<CompiledModelTestBase.Enum32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32Collection.SetGetter(
                List<CompiledModelTestBase.Enum32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Collection(instance) == null);
            enum32Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32Collection(instance) = value;
                    return instance;
                });
            enum32Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum32Collection(instance) = value;
                    return instance;
                });
            enum32Collection.SetAccessors(
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32>>(enum32Collection, 44),
                List<CompiledModelTestBase.Enum32> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32Collection));
            enum32Collection.SetPropertyIndexes(
                index: 44,
                originalValueIndex: 44,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
            enum32CollectionElementType.TypeMapping = enum32Collection.TypeMapping.ElementTypeMapping;
            enum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64 = runtimeEntityType.AddProperty(
                "Enum64",
                typeof(CompiledModelTestBase.Enum64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64.SetGetter(
                CompiledModelTestBase.Enum64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum64(instance))), ((object)(CompiledModelTestBase.Enum64.Default))));
            enum64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64(instance) = value;
                    return instance;
                });
            enum64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64(instance) = value;
                    return instance;
                });
            enum64.SetAccessors(
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64>(enum64, 45),
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64));
            enum64.SetPropertyIndexes(
                index: 45,
                originalValueIndex: 45,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                    long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                    CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))));
            enum64.SetSentinelFromProviderValue(0L);
            enum64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64Array = runtimeEntityType.AddProperty(
                "Enum64Array",
                typeof(CompiledModelTestBase.Enum64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64Array.SetGetter(
                CompiledModelTestBase.Enum64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Array(instance) == null);
            enum64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64Array(instance) = value;
                    return instance;
                });
            enum64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64Array(instance) = value;
                    return instance;
                });
            enum64Array.SetAccessors(
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64[]>(enum64Array, 46),
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64Array));
            enum64Array.SetPropertyIndexes(
                index: 46,
                originalValueIndex: 46,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
            enum64ArrayElementType.TypeMapping = enum64Array.TypeMapping.ElementTypeMapping;
            enum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64AsString = runtimeEntityType.AddProperty(
                "Enum64AsString",
                typeof(CompiledModelTestBase.Enum64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum64AsString.SetGetter(
                CompiledModelTestBase.Enum64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum64AsString(instance))), ((object)(CompiledModelTestBase.Enum64.Default))));
            enum64AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64AsString(instance) = value;
                    return instance;
                });
            enum64AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64AsString(instance) = value;
                    return instance;
                });
            enum64AsString.SetAccessors(
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64>(enum64AsString, 47),
                CompiledModelTestBase.Enum64 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64AsString));
            enum64AsString.SetPropertyIndexes(
                index: 47,
                originalValueIndex: 47,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum64AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
                    string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                    CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, string>(
                        string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))));
            enum64AsString.SetSentinelFromProviderValue("Default");
            enum64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64AsStringArray = runtimeEntityType.AddProperty(
                "Enum64AsStringArray",
                typeof(CompiledModelTestBase.Enum64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64AsStringArray.SetGetter(
                CompiledModelTestBase.Enum64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringArray(instance) == null);
            enum64AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64AsStringArray(instance) = value;
                    return instance;
                });
            enum64AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64AsStringArray(instance) = value;
                    return instance;
                });
            enum64AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray, 48),
                CompiledModelTestBase.Enum64[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray));
            enum64AsStringArray.SetPropertyIndexes(
                index: 48,
                originalValueIndex: 48,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
                        string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
                providerClrType: typeof(string));
            enum64AsStringArrayElementType.TypeMapping = enum64AsStringArray.TypeMapping.ElementTypeMapping;
            enum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64AsStringCollection = runtimeEntityType.AddProperty(
                "Enum64AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(instance) == null);
            enum64AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64AsStringCollection(instance) = value;
                    return instance;
                });
            enum64AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64AsStringCollection(instance) = value;
                    return instance;
                });
            enum64AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection, 49),
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection));
            enum64AsStringCollection.SetPropertyIndexes(
                index: 49,
                originalValueIndex: 49,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
                        string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
                providerClrType: typeof(string));
            enum64AsStringCollectionElementType.TypeMapping = enum64AsStringCollection.TypeMapping.ElementTypeMapping;
            enum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64Collection = runtimeEntityType.AddProperty(
                "Enum64Collection",
                typeof(List<CompiledModelTestBase.Enum64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64Collection.SetGetter(
                List<CompiledModelTestBase.Enum64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Collection(instance) == null);
            enum64Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64Collection(instance) = value;
                    return instance;
                });
            enum64Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum64Collection(instance) = value;
                    return instance;
                });
            enum64Collection.SetAccessors(
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64>>(enum64Collection, 50),
                List<CompiledModelTestBase.Enum64> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64Collection));
            enum64Collection.SetPropertyIndexes(
                index: 50,
                originalValueIndex: 50,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
            enum64CollectionElementType.TypeMapping = enum64Collection.TypeMapping.ElementTypeMapping;
            enum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8 = runtimeEntityType.AddProperty(
                "Enum8",
                typeof(CompiledModelTestBase.Enum8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8.SetGetter(
                CompiledModelTestBase.Enum8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum8(instance))), ((object)(CompiledModelTestBase.Enum8.Default))));
            enum8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8(instance) = value;
                    return instance;
                });
            enum8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8(instance) = value;
                    return instance;
                });
            enum8.SetAccessors(
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8>(enum8, 51),
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8));
            enum8.SetPropertyIndexes(
                index: 51,
                originalValueIndex: 51,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                    short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                    CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))));
            enum8.SetSentinelFromProviderValue((short)0);
            enum8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8Array = runtimeEntityType.AddProperty(
                "Enum8Array",
                typeof(CompiledModelTestBase.Enum8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8Array.SetGetter(
                CompiledModelTestBase.Enum8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Array(instance) == null);
            enum8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8Array(instance) = value;
                    return instance;
                });
            enum8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8Array(instance) = value;
                    return instance;
                });
            enum8Array.SetAccessors(
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8[]>(enum8Array, 52),
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8Array));
            enum8Array.SetPropertyIndexes(
                index: 52,
                originalValueIndex: 52,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
            enum8ArrayElementType.TypeMapping = enum8Array.TypeMapping.ElementTypeMapping;
            enum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8AsString = runtimeEntityType.AddProperty(
                "Enum8AsString",
                typeof(CompiledModelTestBase.Enum8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum8AsString.SetGetter(
                CompiledModelTestBase.Enum8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum8AsString(instance))), ((object)(CompiledModelTestBase.Enum8.Default))));
            enum8AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8AsString(instance) = value;
                    return instance;
                });
            enum8AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8 value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8AsString(instance) = value;
                    return instance;
                });
            enum8AsString.SetAccessors(
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8>(enum8AsString, 53),
                CompiledModelTestBase.Enum8 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8AsString));
            enum8AsString.SetPropertyIndexes(
                index: 53,
                originalValueIndex: 53,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum8AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
                    string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                    CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, string>(
                        string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))));
            enum8AsString.SetSentinelFromProviderValue("Default");
            enum8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8AsStringArray = runtimeEntityType.AddProperty(
                "Enum8AsStringArray",
                typeof(CompiledModelTestBase.Enum8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8AsStringArray.SetGetter(
                CompiledModelTestBase.Enum8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringArray(instance) == null);
            enum8AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8AsStringArray(instance) = value;
                    return instance;
                });
            enum8AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8[] value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8AsStringArray(instance) = value;
                    return instance;
                });
            enum8AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray, 54),
                CompiledModelTestBase.Enum8[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray));
            enum8AsStringArray.SetPropertyIndexes(
                index: 54,
                originalValueIndex: 54,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
                        string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
                providerClrType: typeof(string));
            enum8AsStringArrayElementType.TypeMapping = enum8AsStringArray.TypeMapping.ElementTypeMapping;
            enum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8AsStringCollection = runtimeEntityType.AddProperty(
                "Enum8AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(instance) == null);
            enum8AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8AsStringCollection(instance) = value;
                    return instance;
                });
            enum8AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8AsStringCollection(instance) = value;
                    return instance;
                });
            enum8AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection, 55),
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection));
            enum8AsStringCollection.SetPropertyIndexes(
                index: 55,
                originalValueIndex: 55,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
                        string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
                providerClrType: typeof(string));
            enum8AsStringCollectionElementType.TypeMapping = enum8AsStringCollection.TypeMapping.ElementTypeMapping;
            enum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8Collection = runtimeEntityType.AddProperty(
                "Enum8Collection",
                typeof(List<CompiledModelTestBase.Enum8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8Collection.SetGetter(
                List<CompiledModelTestBase.Enum8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Collection(instance) == null);
            enum8Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8Collection(instance) = value;
                    return instance;
                });
            enum8Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8> value) =>
                {
                    ManyTypesUnsafeAccessors.Enum8Collection(instance) = value;
                    return instance;
                });
            enum8Collection.SetAccessors(
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.Enum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8>>(enum8Collection, 56),
                List<CompiledModelTestBase.Enum8> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8Collection));
            enum8Collection.SetPropertyIndexes(
                index: 56,
                originalValueIndex: 56,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enum8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
            enum8CollectionElementType.TypeMapping = enum8Collection.TypeMapping.ElementTypeMapping;
            enum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                "EnumToNumberConverterProperty",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumToNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumToNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new EnumToNumberConverter<CompiledModelTestBase.Enum32, int>());
            enumToNumberConverterProperty.SetGetter(
                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
            enumToNumberConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(instance) = value;
                    return instance;
                });
            enumToNumberConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(instance) = value;
                    return instance;
                });
            enumToNumberConverterProperty.SetAccessors(
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enumToNumberConverterProperty, 57),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToNumberConverterProperty));
            enumToNumberConverterProperty.SetPropertyIndexes(
                index: 57,
                originalValueIndex: 57,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumToNumberConverterProperty.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                    CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))));
            enumToNumberConverterProperty.SetSentinelFromProviderValue(0);
            enumToNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumToStringConverterProperty = runtimeEntityType.AddProperty(
                "EnumToStringConverterProperty",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new EnumToStringConverter<CompiledModelTestBase.Enum32>());
            enumToStringConverterProperty.SetGetter(
                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumToStringConverterProperty(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
            enumToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumToStringConverterProperty(instance) = value;
                    return instance;
                });
            enumToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumToStringConverterProperty(instance) = value;
                    return instance;
                });
            enumToStringConverterProperty.SetAccessors(
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enumToStringConverterProperty, 58),
                CompiledModelTestBase.Enum32 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToStringConverterProperty));
            enumToStringConverterProperty.SetPropertyIndexes(
                index: 58,
                originalValueIndex: 58,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                    string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                    CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))));
            enumToStringConverterProperty.SetSentinelFromProviderValue("Default");
            enumToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16 = runtimeEntityType.AddProperty(
                "EnumU16",
                typeof(CompiledModelTestBase.EnumU16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16.SetGetter(
                CompiledModelTestBase.EnumU16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU16(instance))), ((object)(CompiledModelTestBase.EnumU16.Min))));
            enumU16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16(instance) = value;
                    return instance;
                });
            enumU16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16(instance) = value;
                    return instance;
                });
            enumU16.SetAccessors(
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16>(enumU16, 59),
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16));
            enumU16.SetPropertyIndexes(
                index: 59,
                originalValueIndex: 59,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                    int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                    CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))));
            enumU16.SetSentinelFromProviderValue(0);
            enumU16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16Array = runtimeEntityType.AddProperty(
                "EnumU16Array",
                typeof(CompiledModelTestBase.EnumU16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16Array.SetGetter(
                CompiledModelTestBase.EnumU16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Array(instance) == null);
            enumU16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16Array(instance) = value;
                    return instance;
                });
            enumU16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16Array(instance) = value;
                    return instance;
                });
            enumU16Array.SetAccessors(
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16[]>(enumU16Array, 60),
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16Array));
            enumU16Array.SetPropertyIndexes(
                index: 60,
                originalValueIndex: 60,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
            enumU16ArrayElementType.TypeMapping = enumU16Array.TypeMapping.ElementTypeMapping;
            enumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16AsString = runtimeEntityType.AddProperty(
                "EnumU16AsString",
                typeof(CompiledModelTestBase.EnumU16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU16AsString.SetGetter(
                CompiledModelTestBase.EnumU16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU16AsString(instance))), ((object)(CompiledModelTestBase.EnumU16.Min))));
            enumU16AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16AsString(instance) = value;
                    return instance;
                });
            enumU16AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16AsString(instance) = value;
                    return instance;
                });
            enumU16AsString.SetAccessors(
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16>(enumU16AsString, 61),
                CompiledModelTestBase.EnumU16 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16AsString));
            enumU16AsString.SetPropertyIndexes(
                index: 61,
                originalValueIndex: 61,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU16AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                    string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                    CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                        string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))));
            enumU16AsString.SetSentinelFromProviderValue("Min");
            enumU16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16AsStringArray = runtimeEntityType.AddProperty(
                "EnumU16AsStringArray",
                typeof(CompiledModelTestBase.EnumU16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(instance) == null);
            enumU16AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16AsStringArray(instance) = value;
                    return instance;
                });
            enumU16AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16AsStringArray(instance) = value;
                    return instance;
                });
            enumU16AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray, 62),
                CompiledModelTestBase.EnumU16[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray));
            enumU16AsStringArray.SetPropertyIndexes(
                index: 62,
                originalValueIndex: 62,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                        string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
                providerClrType: typeof(string));
            enumU16AsStringArrayElementType.TypeMapping = enumU16AsStringArray.TypeMapping.ElementTypeMapping;
            enumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU16AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(instance) == null);
            enumU16AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16AsStringCollection(instance) = value;
                    return instance;
                });
            enumU16AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16AsStringCollection(instance) = value;
                    return instance;
                });
            enumU16AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection, 63),
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection));
            enumU16AsStringCollection.SetPropertyIndexes(
                index: 63,
                originalValueIndex: 63,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                        string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
                providerClrType: typeof(string));
            enumU16AsStringCollectionElementType.TypeMapping = enumU16AsStringCollection.TypeMapping.ElementTypeMapping;
            enumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16Collection = runtimeEntityType.AddProperty(
                "EnumU16Collection",
                typeof(List<CompiledModelTestBase.EnumU16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16Collection.SetGetter(
                List<CompiledModelTestBase.EnumU16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Collection(instance) == null);
            enumU16Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16Collection(instance) = value;
                    return instance;
                });
            enumU16Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU16Collection(instance) = value;
                    return instance;
                });
            enumU16Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection, 64),
                List<CompiledModelTestBase.EnumU16> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection));
            enumU16Collection.SetPropertyIndexes(
                index: 64,
                originalValueIndex: 64,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
            enumU16CollectionElementType.TypeMapping = enumU16Collection.TypeMapping.ElementTypeMapping;
            enumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32 = runtimeEntityType.AddProperty(
                "EnumU32",
                typeof(CompiledModelTestBase.EnumU32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32.SetGetter(
                CompiledModelTestBase.EnumU32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU32(instance))), ((object)(CompiledModelTestBase.EnumU32.Min))));
            enumU32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32(instance) = value;
                    return instance;
                });
            enumU32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32(instance) = value;
                    return instance;
                });
            enumU32.SetAccessors(
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32>(enumU32, 65),
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32));
            enumU32.SetPropertyIndexes(
                index: 65,
                originalValueIndex: 65,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                    long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                    CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))));
            enumU32.SetSentinelFromProviderValue(0L);
            enumU32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32Array = runtimeEntityType.AddProperty(
                "EnumU32Array",
                typeof(CompiledModelTestBase.EnumU32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32Array.SetGetter(
                CompiledModelTestBase.EnumU32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Array(instance) == null);
            enumU32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32Array(instance) = value;
                    return instance;
                });
            enumU32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32Array(instance) = value;
                    return instance;
                });
            enumU32Array.SetAccessors(
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32[]>(enumU32Array, 66),
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32Array));
            enumU32Array.SetPropertyIndexes(
                index: 66,
                originalValueIndex: 66,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
            enumU32ArrayElementType.TypeMapping = enumU32Array.TypeMapping.ElementTypeMapping;
            enumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32AsString = runtimeEntityType.AddProperty(
                "EnumU32AsString",
                typeof(CompiledModelTestBase.EnumU32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU32AsString.SetGetter(
                CompiledModelTestBase.EnumU32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU32AsString(instance))), ((object)(CompiledModelTestBase.EnumU32.Min))));
            enumU32AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32AsString(instance) = value;
                    return instance;
                });
            enumU32AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32AsString(instance) = value;
                    return instance;
                });
            enumU32AsString.SetAccessors(
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32>(enumU32AsString, 67),
                CompiledModelTestBase.EnumU32 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32AsString));
            enumU32AsString.SetPropertyIndexes(
                index: 67,
                originalValueIndex: 67,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU32AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                    string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                    CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))));
            enumU32AsString.SetSentinelFromProviderValue("Min");
            enumU32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32AsStringArray = runtimeEntityType.AddProperty(
                "EnumU32AsStringArray",
                typeof(CompiledModelTestBase.EnumU32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(instance) == null);
            enumU32AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32AsStringArray(instance) = value;
                    return instance;
                });
            enumU32AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32AsStringArray(instance) = value;
                    return instance;
                });
            enumU32AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray, 68),
                CompiledModelTestBase.EnumU32[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray));
            enumU32AsStringArray.SetPropertyIndexes(
                index: 68,
                originalValueIndex: 68,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
                providerClrType: typeof(string));
            enumU32AsStringArrayElementType.TypeMapping = enumU32AsStringArray.TypeMapping.ElementTypeMapping;
            enumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU32AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(instance) == null);
            enumU32AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32AsStringCollection(instance) = value;
                    return instance;
                });
            enumU32AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32AsStringCollection(instance) = value;
                    return instance;
                });
            enumU32AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection, 69),
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection));
            enumU32AsStringCollection.SetPropertyIndexes(
                index: 69,
                originalValueIndex: 69,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
                providerClrType: typeof(string));
            enumU32AsStringCollectionElementType.TypeMapping = enumU32AsStringCollection.TypeMapping.ElementTypeMapping;
            enumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32Collection = runtimeEntityType.AddProperty(
                "EnumU32Collection",
                typeof(List<CompiledModelTestBase.EnumU32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32Collection.SetGetter(
                List<CompiledModelTestBase.EnumU32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Collection(instance) == null);
            enumU32Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32Collection(instance) = value;
                    return instance;
                });
            enumU32Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU32Collection(instance) = value;
                    return instance;
                });
            enumU32Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection, 70),
                List<CompiledModelTestBase.EnumU32> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection));
            enumU32Collection.SetPropertyIndexes(
                index: 70,
                originalValueIndex: 70,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
            enumU32CollectionElementType.TypeMapping = enumU32Collection.TypeMapping.ElementTypeMapping;
            enumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64 = runtimeEntityType.AddProperty(
                "EnumU64",
                typeof(CompiledModelTestBase.EnumU64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64.SetGetter(
                CompiledModelTestBase.EnumU64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU64(instance))), ((object)(CompiledModelTestBase.EnumU64.Min))));
            enumU64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64(instance) = value;
                    return instance;
                });
            enumU64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64(instance) = value;
                    return instance;
                });
            enumU64.SetAccessors(
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64>(enumU64, 71),
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64));
            enumU64.SetPropertyIndexes(
                index: 71,
                originalValueIndex: 71,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                    decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                    CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))));
            enumU64.SetSentinelFromProviderValue(0m);
            enumU64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64Array = runtimeEntityType.AddProperty(
                "EnumU64Array",
                typeof(CompiledModelTestBase.EnumU64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64Array.SetGetter(
                CompiledModelTestBase.EnumU64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Array(instance) == null);
            enumU64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64Array(instance) = value;
                    return instance;
                });
            enumU64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64Array(instance) = value;
                    return instance;
                });
            enumU64Array.SetAccessors(
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64[]>(enumU64Array, 72),
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64Array));
            enumU64Array.SetPropertyIndexes(
                index: 72,
                originalValueIndex: 72,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
            enumU64ArrayElementType.TypeMapping = enumU64Array.TypeMapping.ElementTypeMapping;
            enumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64AsString = runtimeEntityType.AddProperty(
                "EnumU64AsString",
                typeof(CompiledModelTestBase.EnumU64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU64AsString.SetGetter(
                CompiledModelTestBase.EnumU64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU64AsString(instance))), ((object)(CompiledModelTestBase.EnumU64.Min))));
            enumU64AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64AsString(instance) = value;
                    return instance;
                });
            enumU64AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64AsString(instance) = value;
                    return instance;
                });
            enumU64AsString.SetAccessors(
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64>(enumU64AsString, 73),
                CompiledModelTestBase.EnumU64 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64AsString));
            enumU64AsString.SetPropertyIndexes(
                index: 73,
                originalValueIndex: 73,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU64AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                    string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                    CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                        string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))));
            enumU64AsString.SetSentinelFromProviderValue("Min");
            enumU64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64AsStringArray = runtimeEntityType.AddProperty(
                "EnumU64AsStringArray",
                typeof(CompiledModelTestBase.EnumU64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(instance) == null);
            enumU64AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64AsStringArray(instance) = value;
                    return instance;
                });
            enumU64AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64AsStringArray(instance) = value;
                    return instance;
                });
            enumU64AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray, 74),
                CompiledModelTestBase.EnumU64[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray));
            enumU64AsStringArray.SetPropertyIndexes(
                index: 74,
                originalValueIndex: 74,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                        string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
                providerClrType: typeof(string));
            enumU64AsStringArrayElementType.TypeMapping = enumU64AsStringArray.TypeMapping.ElementTypeMapping;
            enumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU64AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(instance) == null);
            enumU64AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64AsStringCollection(instance) = value;
                    return instance;
                });
            enumU64AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64AsStringCollection(instance) = value;
                    return instance;
                });
            enumU64AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection, 75),
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection));
            enumU64AsStringCollection.SetPropertyIndexes(
                index: 75,
                originalValueIndex: 75,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                        string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
                providerClrType: typeof(string));
            enumU64AsStringCollectionElementType.TypeMapping = enumU64AsStringCollection.TypeMapping.ElementTypeMapping;
            enumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64Collection = runtimeEntityType.AddProperty(
                "EnumU64Collection",
                typeof(List<CompiledModelTestBase.EnumU64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64Collection.SetGetter(
                List<CompiledModelTestBase.EnumU64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Collection(instance) == null);
            enumU64Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64Collection(instance) = value;
                    return instance;
                });
            enumU64Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU64Collection(instance) = value;
                    return instance;
                });
            enumU64Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection, 76),
                List<CompiledModelTestBase.EnumU64> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection));
            enumU64Collection.SetPropertyIndexes(
                index: 76,
                originalValueIndex: 76,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
            enumU64CollectionElementType.TypeMapping = enumU64Collection.TypeMapping.ElementTypeMapping;
            enumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8 = runtimeEntityType.AddProperty(
                "EnumU8",
                typeof(CompiledModelTestBase.EnumU8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8.SetGetter(
                CompiledModelTestBase.EnumU8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU8(instance))), ((object)(CompiledModelTestBase.EnumU8.Min))));
            enumU8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8(instance) = value;
                    return instance;
                });
            enumU8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8(instance) = value;
                    return instance;
                });
            enumU8.SetAccessors(
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8>(enumU8, 77),
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8));
            enumU8.SetPropertyIndexes(
                index: 77,
                originalValueIndex: 77,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                    byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                    CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))));
            enumU8.SetSentinelFromProviderValue((byte)0);
            enumU8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8Array = runtimeEntityType.AddProperty(
                "EnumU8Array",
                typeof(CompiledModelTestBase.EnumU8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8Array.SetGetter(
                CompiledModelTestBase.EnumU8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Array(instance) == null);
            enumU8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8Array(instance) = value;
                    return instance;
                });
            enumU8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8Array(instance) = value;
                    return instance;
                });
            enumU8Array.SetAccessors(
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8[]>(enumU8Array, 78),
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8Array));
            enumU8Array.SetPropertyIndexes(
                index: 78,
                originalValueIndex: 78,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
            enumU8ArrayElementType.TypeMapping = enumU8Array.TypeMapping.ElementTypeMapping;
            enumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8AsString = runtimeEntityType.AddProperty(
                "EnumU8AsString",
                typeof(CompiledModelTestBase.EnumU8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU8AsString.SetGetter(
                CompiledModelTestBase.EnumU8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU8AsString(instance))), ((object)(CompiledModelTestBase.EnumU8.Min))));
            enumU8AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8AsString(instance) = value;
                    return instance;
                });
            enumU8AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8 value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8AsString(instance) = value;
                    return instance;
                });
            enumU8AsString.SetAccessors(
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8>(enumU8AsString, 79),
                CompiledModelTestBase.EnumU8 (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8AsString));
            enumU8AsString.SetPropertyIndexes(
                index: 79,
                originalValueIndex: 79,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU8AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                    string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                    CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                        string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))));
            enumU8AsString.SetSentinelFromProviderValue("Min");
            enumU8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8AsStringArray = runtimeEntityType.AddProperty(
                "EnumU8AsStringArray",
                typeof(CompiledModelTestBase.EnumU8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(instance) == null);
            enumU8AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8AsStringArray(instance) = value;
                    return instance;
                });
            enumU8AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8[] value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8AsStringArray(instance) = value;
                    return instance;
                });
            enumU8AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray, 80),
                CompiledModelTestBase.EnumU8[] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray));
            enumU8AsStringArray.SetPropertyIndexes(
                index: 80,
                originalValueIndex: 80,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                        string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
                providerClrType: typeof(string));
            enumU8AsStringArrayElementType.TypeMapping = enumU8AsStringArray.TypeMapping.ElementTypeMapping;
            enumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU8AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(instance) == null);
            enumU8AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8AsStringCollection(instance) = value;
                    return instance;
                });
            enumU8AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8AsStringCollection(instance) = value;
                    return instance;
                });
            enumU8AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection, 81),
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection));
            enumU8AsStringCollection.SetPropertyIndexes(
                index: 81,
                originalValueIndex: 81,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                        string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                        CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
                providerClrType: typeof(string));
            enumU8AsStringCollectionElementType.TypeMapping = enumU8AsStringCollection.TypeMapping.ElementTypeMapping;
            enumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8Collection = runtimeEntityType.AddProperty(
                "EnumU8Collection",
                typeof(List<CompiledModelTestBase.EnumU8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8Collection.SetGetter(
                List<CompiledModelTestBase.EnumU8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Collection(instance) == null);
            enumU8Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8Collection(instance) = value;
                    return instance;
                });
            enumU8Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8> value) =>
                {
                    ManyTypesUnsafeAccessors.EnumU8Collection(instance) = value;
                    return instance;
                });
            enumU8Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => ManyTypesUnsafeAccessors.EnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection, 82),
                List<CompiledModelTestBase.EnumU8> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection));
            enumU8Collection.SetPropertyIndexes(
                index: 82,
                originalValueIndex: 82,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            enumU8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
            enumU8CollectionElementType.TypeMapping = enumU8Collection.TypeMapping.ElementTypeMapping;
            enumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @float = runtimeEntityType.AddProperty(
                "Float",
                typeof(float),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0f);
            @float.SetGetter(
                float (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Float(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Float(instance).Equals(0F));
            @float.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float value) =>
                {
                    ManyTypesUnsafeAccessors.Float(instance) = value;
                    return instance;
                });
            @float.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float value) =>
                {
                    ManyTypesUnsafeAccessors.Float(instance) = value;
                    return instance;
                });
            @float.SetAccessors(
                float (IInternalEntry entry) => ManyTypesUnsafeAccessors.Float(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float (IInternalEntry entry) => ManyTypesUnsafeAccessors.Float(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float (IInternalEntry entry) => entry.ReadOriginalValue<float>(@float, 83),
                float (IInternalEntry entry) => entry.GetCurrentValue<float>(@float));
            @float.SetPropertyIndexes(
                index: 83,
                originalValueIndex: 83,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            @float.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v),
                keyComparer: new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v));
            @float.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var floatArray = runtimeEntityType.AddProperty(
                "FloatArray",
                typeof(float[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            floatArray.SetGetter(
                float[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.FloatArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.FloatArray(instance) == null);
            floatArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float[] value) =>
                {
                    ManyTypesUnsafeAccessors.FloatArray(instance) = value;
                    return instance;
                });
            floatArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float[] value) =>
                {
                    ManyTypesUnsafeAccessors.FloatArray(instance) = value;
                    return instance;
                });
            floatArray.SetAccessors(
                float[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.FloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.FloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float[] (IInternalEntry entry) => entry.ReadOriginalValue<float[]>(floatArray, 84),
                float[] (IInternalEntry entry) => entry.GetCurrentValue<float[]>(floatArray));
            floatArray.SetPropertyIndexes(
                index: 84,
                originalValueIndex: 84,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            floatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<float[], float>(new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v)),
                keyComparer: new ListOfValueTypesComparer<float[], float>(new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionOfStructsReaderWriter<float[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<float[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        bool (float v1, float v2) => v1.Equals(v2),
                        int (float v) => ((object)v).GetHashCode(),
                        float (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        bool (float v1, float v2) => v1.Equals(v2),
                        int (float v) => ((object)v).GetHashCode(),
                        float (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        bool (float v1, float v2) => v1.Equals(v2),
                        int (float v) => ((object)v).GetHashCode(),
                        float (float v) => v)));
            var floatArrayElementType = floatArray.SetElementType(typeof(float));
            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
            floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guid = runtimeEntityType.AddProperty(
                "Guid",
                typeof(Guid),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            guid.SetGetter(
                Guid (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Guid(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Guid(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
            guid.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid value) =>
                {
                    ManyTypesUnsafeAccessors.Guid(instance) = value;
                    return instance;
                });
            guid.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid value) =>
                {
                    ManyTypesUnsafeAccessors.Guid(instance) = value;
                    return instance;
                });
            guid.SetAccessors(
                Guid (IInternalEntry entry) => ManyTypesUnsafeAccessors.Guid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid (IInternalEntry entry) => ManyTypesUnsafeAccessors.Guid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid (IInternalEntry entry) => entry.ReadOriginalValue<Guid>(guid, 85),
                Guid (IInternalEntry entry) => entry.GetCurrentValue<Guid>(guid));
            guid.SetPropertyIndexes(
                index: 85,
                originalValueIndex: 85,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            guid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            guid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidArray = runtimeEntityType.AddProperty(
                "GuidArray",
                typeof(Guid[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            guidArray.SetGetter(
                Guid[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidArray(instance) == null);
            guidArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid[] value) =>
                {
                    ManyTypesUnsafeAccessors.GuidArray(instance) = value;
                    return instance;
                });
            guidArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid[] value) =>
                {
                    ManyTypesUnsafeAccessors.GuidArray(instance) = value;
                    return instance;
                });
            guidArray.SetAccessors(
                Guid[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.GuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.GuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid[] (IInternalEntry entry) => entry.ReadOriginalValue<Guid[]>(guidArray, 86),
                Guid[] (IInternalEntry entry) => entry.GetCurrentValue<Guid[]>(guidArray));
            guidArray.SetPropertyIndexes(
                index: 86,
                originalValueIndex: 86,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            guidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v)),
                keyComparer: new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        bool (Guid v1, Guid v2) => v1 == v2,
                        int (Guid v) => ((object)v).GetHashCode(),
                        Guid (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        bool (Guid v1, Guid v2) => v1 == v2,
                        int (Guid v) => ((object)v).GetHashCode(),
                        Guid (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        bool (Guid v1, Guid v2) => v1 == v2,
                        int (Guid v) => ((object)v).GetHashCode(),
                        Guid (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
            guidArrayElementType.TypeMapping = guidArray.TypeMapping.ElementTypeMapping;
            guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                "GuidToBytesConverterProperty",
                typeof(Guid),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new GuidToBytesConverter());
            guidToBytesConverterProperty.SetGetter(
                Guid (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
            guidToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid value) =>
                {
                    ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(instance) = value;
                    return instance;
                });
            guidToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid value) =>
                {
                    ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(instance) = value;
                    return instance;
                });
            guidToBytesConverterProperty.SetAccessors(
                Guid (IInternalEntry entry) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid (IInternalEntry entry) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid (IInternalEntry entry) => entry.ReadOriginalValue<Guid>(guidToBytesConverterProperty, 87),
                Guid (IInternalEntry entry) => entry.GetCurrentValue<Guid>(guidToBytesConverterProperty));
            guidToBytesConverterProperty.SetPropertyIndexes(
                index: 87,
                originalValueIndex: 87,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            guidToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(16)",
                    size: 16),
                converter: new ValueConverter<Guid, byte[]>(
                    byte[] (Guid v) => v.ToByteArray(),
                    Guid (byte[] v) => new Guid(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<Guid, byte[]>(
                        byte[] (Guid v) => v.ToByteArray(),
                        Guid (byte[] v) => new Guid(v))));
            guidToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            guidToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidToStringConverterProperty = runtimeEntityType.AddProperty(
                "GuidToStringConverterProperty",
                typeof(Guid),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new GuidToStringConverter());
            guidToStringConverterProperty.SetGetter(
                Guid (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
            guidToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid value) =>
                {
                    ManyTypesUnsafeAccessors.GuidToStringConverterProperty(instance) = value;
                    return instance;
                });
            guidToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid value) =>
                {
                    ManyTypesUnsafeAccessors.GuidToStringConverterProperty(instance) = value;
                    return instance;
                });
            guidToStringConverterProperty.SetAccessors(
                Guid (IInternalEntry entry) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid (IInternalEntry entry) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid (IInternalEntry entry) => entry.ReadOriginalValue<Guid>(guidToStringConverterProperty, 88),
                Guid (IInternalEntry entry) => entry.GetCurrentValue<Guid>(guidToStringConverterProperty));
            guidToStringConverterProperty.SetPropertyIndexes(
                index: 88,
                originalValueIndex: 88,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            guidToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(36)",
                    size: 36,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Guid, string>(
                    string (Guid v) => v.ToString("D"),
                    Guid (string v) => new Guid(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Guid, string>(
                        string (Guid v) => v.ToString("D"),
                        Guid (string v) => new Guid(v))));
            guidToStringConverterProperty.SetSentinelFromProviderValue("00000000-0000-0000-0000-000000000000");
            guidToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddress = runtimeEntityType.AddProperty(
                "IPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            iPAddress.SetGetter(
                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddress(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddress(instance) == null);
            iPAddress.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddress(instance) = value;
                    return instance;
                });
            iPAddress.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddress(instance) = value;
                    return instance;
                });
            iPAddress.SetAccessors(
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => entry.ReadOriginalValue<IPAddress>(iPAddress, 89),
                IPAddress (IInternalEntry entry) => entry.GetCurrentValue<IPAddress>(iPAddress));
            iPAddress.SetPropertyIndexes(
                index: 89,
                originalValueIndex: 89,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            iPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    string (IPAddress v) => ((object)v).ToString(),
                    IPAddress (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        string (IPAddress v) => ((object)v).ToString(),
                        IPAddress (string v) => IPAddress.Parse(v))));
            iPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressArray = runtimeEntityType.AddProperty(
                "IPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            iPAddressArray.SetGetter(
                IPAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressArray(instance) == null);
            iPAddressArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddressArray(instance) = value;
                    return instance;
                });
            iPAddressArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddressArray(instance) = value;
                    return instance;
                });
            iPAddressArray.SetAccessors(
                IPAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress[] (IInternalEntry entry) => entry.ReadOriginalValue<IPAddress[]>(iPAddressArray, 90),
                IPAddress[] (IInternalEntry entry) => entry.GetCurrentValue<IPAddress[]>(iPAddressArray));
            iPAddressArray.SetPropertyIndexes(
                index: 90,
                originalValueIndex: 90,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            iPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (IPAddress v) => ((object)v).GetHashCode(),
                        IPAddress (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (IPAddress v) => ((object)v).GetHashCode(),
                        IPAddress (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        string (IPAddress v) => ((object)v).ToString(),
                        IPAddress (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v)))));
            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
            iPAddressArrayElementType.TypeMapping = iPAddressArray.TypeMapping.ElementTypeMapping;
            iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
                "IPAddressReadOnlyCollection",
                typeof(IReadOnlyCollection<IPAddress>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_ipAddressReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            iPAddressReadOnlyCollection.SetGetter(
                IReadOnlyCollection<IPAddress> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance)))),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance) == null);
            iPAddressReadOnlyCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<IPAddress> value) =>
                {
                    ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance) = ((List<IPAddress>)(value));
                    return instance;
                });
            iPAddressReadOnlyCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<IPAddress> value) =>
                {
                    ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance) = ((List<IPAddress>)(value));
                    return instance;
                });
            iPAddressReadOnlyCollection.SetAccessors(
                IReadOnlyCollection<IPAddress> (IInternalEntry entry) => ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<IPAddress> (IInternalEntry entry) => ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<IPAddress> (IInternalEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection, 91),
                IReadOnlyCollection<IPAddress> (IInternalEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection));
            iPAddressReadOnlyCollection.SetPropertyIndexes(
                index: 91,
                originalValueIndex: 91,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            iPAddressReadOnlyCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (IPAddress v) => ((object)v).GetHashCode(),
                        IPAddress (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (IPAddress v) => ((object)v).GetHashCode(),
                        IPAddress (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        string (IPAddress v) => ((object)v).ToString(),
                        IPAddress (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v)))));
            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
                providerClrType: typeof(string));
            iPAddressReadOnlyCollectionElementType.TypeMapping = iPAddressReadOnlyCollection.TypeMapping.ElementTypeMapping;
            iPAddressReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                "IPAddressToBytesConverterProperty",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new IPAddressToBytesConverter());
            iPAddressToBytesConverterProperty.SetGetter(
                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(instance) == null);
            iPAddressToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(instance) = value;
                    return instance;
                });
            iPAddressToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(instance) = value;
                    return instance;
                });
            iPAddressToBytesConverterProperty.SetAccessors(
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => entry.ReadOriginalValue<IPAddress>(iPAddressToBytesConverterProperty, 92),
                IPAddress (IInternalEntry entry) => entry.GetCurrentValue<IPAddress>(iPAddressToBytesConverterProperty));
            iPAddressToBytesConverterProperty.SetPropertyIndexes(
                index: 92,
                originalValueIndex: 92,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            iPAddressToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(16)",
                    size: 16),
                converter: new ValueConverter<IPAddress, byte[]>(
                    byte[] (IPAddress v) => v.GetAddressBytes(),
                    IPAddress (byte[] v) => new IPAddress(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<IPAddress, byte[]>(
                        byte[] (IPAddress v) => v.GetAddressBytes(),
                        IPAddress (byte[] v) => new IPAddress(v))));
            iPAddressToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                "IPAddressToStringConverterProperty",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new IPAddressToStringConverter());
            iPAddressToStringConverterProperty.SetGetter(
                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(instance) == null);
            iPAddressToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(instance) = value;
                    return instance;
                });
            iPAddressToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(instance) = value;
                    return instance;
                });
            iPAddressToStringConverterProperty.SetAccessors(
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => entry.ReadOriginalValue<IPAddress>(iPAddressToStringConverterProperty, 93),
                IPAddress (IInternalEntry entry) => entry.GetCurrentValue<IPAddress>(iPAddressToStringConverterProperty));
            iPAddressToStringConverterProperty.SetPropertyIndexes(
                index: 93,
                originalValueIndex: 93,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            iPAddressToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    string (IPAddress v) => ((object)v).ToString(),
                    IPAddress (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        string (IPAddress v) => ((object)v).ToString(),
                        IPAddress (string v) => IPAddress.Parse(v))));
            iPAddressToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16 = runtimeEntityType.AddProperty(
                "Int16",
                typeof(short),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (short)0);
            int16.SetGetter(
                short (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16(instance) == 0);
            int16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short value) =>
                {
                    ManyTypesUnsafeAccessors.Int16(instance) = value;
                    return instance;
                });
            int16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short value) =>
                {
                    ManyTypesUnsafeAccessors.Int16(instance) = value;
                    return instance;
                });
            int16.SetAccessors(
                short (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short (IInternalEntry entry) => entry.ReadOriginalValue<short>(int16, 94),
                short (IInternalEntry entry) => entry.GetCurrentValue<short>(int16));
            int16.SetPropertyIndexes(
                index: 94,
                originalValueIndex: 94,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                keyComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v));
            int16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16Array = runtimeEntityType.AddProperty(
                "Int16Array",
                typeof(short[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int16Array.SetGetter(
                short[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16Array(instance) == null);
            int16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int16Array(instance) = value;
                    return instance;
                });
            int16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int16Array(instance) = value;
                    return instance;
                });
            int16Array.SetAccessors(
                short[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short[] (IInternalEntry entry) => entry.ReadOriginalValue<short[]>(int16Array, 95),
                short[] (IInternalEntry entry) => entry.GetCurrentValue<short[]>(int16Array));
            int16Array.SetPropertyIndexes(
                index: 95,
                originalValueIndex: 95,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<short[], short>(new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v)),
                keyComparer: new ListOfValueTypesComparer<short[], short>(new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionOfStructsReaderWriter<short[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<short[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v)));
            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
            int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32 = runtimeEntityType.AddProperty(
                "Int32",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            int32.SetGetter(
                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32(instance) == 0);
            int32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.Int32(instance) = value;
                    return instance;
                });
            int32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.Int32(instance) = value;
                    return instance;
                });
            int32.SetAccessors(
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => entry.ReadOriginalValue<int>(int32, 96),
                int (IInternalEntry entry) => entry.GetCurrentValue<int>(int32));
            int32.SetPropertyIndexes(
                index: 96,
                originalValueIndex: 96,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v));
            int32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32Array = runtimeEntityType.AddProperty(
                "Int32Array",
                typeof(int[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int32Array.SetGetter(
                int[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32Array(instance) == null);
            int32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int32Array(instance) = value;
                    return instance;
                });
            int32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int32Array(instance) = value;
                    return instance;
                });
            int32Array.SetAccessors(
                int[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int[] (IInternalEntry entry) => entry.ReadOriginalValue<int[]>(int32Array, 97),
                int[] (IInternalEntry entry) => entry.GetCurrentValue<int[]>(int32Array));
            int32Array.SetPropertyIndexes(
                index: 97,
                originalValueIndex: 97,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v)),
                keyComparer: new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionOfStructsReaderWriter<int[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<int[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v)));
            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
            int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                "Int32ReadOnlyCollection",
                typeof(IReadOnlyCollection<int>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_int32ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int32ReadOnlyCollection.SetGetter(
                IReadOnlyCollection<int> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance)))),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance) == null);
            int32ReadOnlyCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<int> value) =>
                {
                    ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance) = ((List<int>)(value));
                    return instance;
                });
            int32ReadOnlyCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<int> value) =>
                {
                    ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance) = ((List<int>)(value));
                    return instance;
                });
            int32ReadOnlyCollection.SetAccessors(
                IReadOnlyCollection<int> (IInternalEntry entry) => ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<int> (IInternalEntry entry) => ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<int> (IInternalEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection, 98),
                IReadOnlyCollection<int> (IInternalEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection));
            int32ReadOnlyCollection.SetPropertyIndexes(
                index: 98,
                originalValueIndex: 98,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int32ReadOnlyCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<int>, int>(new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<int>, int>(new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionOfStructsReaderWriter<List<int>, int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<int>, int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v)));
            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
            int32ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64 = runtimeEntityType.AddProperty(
                "Int64",
                typeof(long),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0L);
            int64.SetGetter(
                long (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64(instance) == 0L);
            int64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long value) =>
                {
                    ManyTypesUnsafeAccessors.Int64(instance) = value;
                    return instance;
                });
            int64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long value) =>
                {
                    ManyTypesUnsafeAccessors.Int64(instance) = value;
                    return instance;
                });
            int64.SetAccessors(
                long (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long (IInternalEntry entry) => entry.ReadOriginalValue<long>(int64, 99),
                long (IInternalEntry entry) => entry.GetCurrentValue<long>(int64));
            int64.SetPropertyIndexes(
                index: 99,
                originalValueIndex: 99,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                keyComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v));
            int64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64Array = runtimeEntityType.AddProperty(
                "Int64Array",
                typeof(long[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int64Array.SetGetter(
                long[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64Array(instance) == null);
            int64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int64Array(instance) = value;
                    return instance;
                });
            int64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int64Array(instance) = value;
                    return instance;
                });
            int64Array.SetAccessors(
                long[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long[] (IInternalEntry entry) => entry.ReadOriginalValue<long[]>(int64Array, 100),
                long[] (IInternalEntry entry) => entry.GetCurrentValue<long[]>(int64Array));
            int64Array.SetPropertyIndexes(
                index: 100,
                originalValueIndex: 100,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v)),
                keyComparer: new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionOfStructsReaderWriter<long[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<long[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v)));
            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
            int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8 = runtimeEntityType.AddProperty(
                "Int8",
                typeof(sbyte),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int8.SetGetter(
                sbyte (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8(instance) == 0);
            int8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte value) =>
                {
                    ManyTypesUnsafeAccessors.Int8(instance) = value;
                    return instance;
                });
            int8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte value) =>
                {
                    ManyTypesUnsafeAccessors.Int8(instance) = value;
                    return instance;
                });
            int8.SetAccessors(
                sbyte (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte (IInternalEntry entry) => entry.ReadOriginalValue<sbyte>(int8, 101),
                sbyte (IInternalEntry entry) => entry.GetCurrentValue<sbyte>(int8));
            int8.SetPropertyIndexes(
                index: 101,
                originalValueIndex: 101,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    short (sbyte v) => ((short)(v)),
                    sbyte (short v) => ((sbyte)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        short (sbyte v) => ((short)(v)),
                        sbyte (short v) => ((sbyte)(v)))));
            int8.SetSentinelFromProviderValue((short)0);
            int8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8Array = runtimeEntityType.AddProperty(
                "Int8Array",
                typeof(sbyte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int8Array.SetGetter(
                sbyte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8Array(instance) == null);
            int8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int8Array(instance) = value;
                    return instance;
                });
            int8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte[] value) =>
                {
                    ManyTypesUnsafeAccessors.Int8Array(instance) = value;
                    return instance;
                });
            int8Array.SetAccessors(
                sbyte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.Int8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte[] (IInternalEntry entry) => entry.ReadOriginalValue<sbyte[]>(int8Array, 102),
                sbyte[] (IInternalEntry entry) => entry.GetCurrentValue<sbyte[]>(int8Array));
            int8Array.SetPropertyIndexes(
                index: 102,
                originalValueIndex: 102,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            int8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v)),
                keyComparer: new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            short (sbyte v) => ((short)(v)),
                            sbyte (short v) => ((sbyte)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            short (sbyte v) => ((short)(v)),
                            sbyte (short v) => ((sbyte)(v))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        bool (sbyte v1, sbyte v2) => v1 == v2,
                        int (sbyte v) => ((int)(v)),
                        sbyte (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        bool (sbyte v1, sbyte v2) => v1 == v2,
                        int (sbyte v) => ((int)(v)),
                        sbyte (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        short (sbyte v) => ((short)(v)),
                        sbyte (short v) => ((sbyte)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            short (sbyte v) => ((short)(v)),
                            sbyte (short v) => ((sbyte)(v))))));
            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
            int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "IntNumberToBytesConverterProperty",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IntNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IntNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<int>());
            intNumberToBytesConverterProperty.SetGetter(
                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(instance) == 0);
            intNumberToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(instance) = value;
                    return instance;
                });
            intNumberToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(instance) = value;
                    return instance;
                });
            intNumberToBytesConverterProperty.SetAccessors(
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => entry.ReadOriginalValue<int>(intNumberToBytesConverterProperty, 103),
                int (IInternalEntry entry) => entry.GetCurrentValue<int>(intNumberToBytesConverterProperty));
            intNumberToBytesConverterProperty.SetPropertyIndexes(
                index: 103,
                originalValueIndex: 103,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            intNumberToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(4)",
                    size: 4),
                converter: new ValueConverter<int, byte[]>(
                    byte[] (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
                    int (byte[] v) => (v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt((v.Length == 0 ? new byte[4] : v)), 0))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<int, byte[]>(
                        byte[] (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
                        int (byte[] v) => (v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt((v.Length == 0 ? new byte[4] : v)), 0)))));
            intNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0 });
            intNumberToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var intNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "IntNumberToStringConverterProperty",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IntNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IntNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<int>());
            intNumberToStringConverterProperty.SetGetter(
                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(instance) == 0);
            intNumberToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(instance) = value;
                    return instance;
                });
            intNumberToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int value) =>
                {
                    ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(instance) = value;
                    return instance;
                });
            intNumberToStringConverterProperty.SetAccessors(
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int (IInternalEntry entry) => entry.ReadOriginalValue<int>(intNumberToStringConverterProperty, 104),
                int (IInternalEntry entry) => entry.GetCurrentValue<int>(intNumberToStringConverterProperty));
            intNumberToStringConverterProperty.SetPropertyIndexes(
                index: 104,
                originalValueIndex: 104,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            intNumberToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(64)",
                    size: 64,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<int, string>(
                    string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                    int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<int, string>(
                        string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            intNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
            intNumberToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullIntToNullStringConverterProperty = runtimeEntityType.AddProperty(
                "NullIntToNullStringConverterProperty",
                typeof(int?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullIntToNullStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullIntToNullStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new CompiledModelTestBase.NullIntToNullStringConverter());
            nullIntToNullStringConverterProperty.SetGetter(
                int? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(instance).HasValue));
            nullIntToNullStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int? value) =>
                {
                    ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(instance) = value;
                    return instance;
                });
            nullIntToNullStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int? value) =>
                {
                    ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(instance) = value;
                    return instance;
                });
            nullIntToNullStringConverterProperty.SetAccessors(
                int? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int? (IInternalEntry entry) => entry.ReadOriginalValue<int?>(nullIntToNullStringConverterProperty, 105),
                int? (IInternalEntry entry) => entry.GetCurrentValue<int?>(nullIntToNullStringConverterProperty));
            nullIntToNullStringConverterProperty.SetPropertyIndexes(
                index: 105,
                originalValueIndex: 105,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullIntToNullStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    bool (int? v1, int? v2) => v1 == v2,
                    int (int? v) => ((int)(v)),
                    int? (int? v) => v),
                keyComparer: new ValueComparer<int?>(
                    bool (int? v1, int? v2) => v1 == v2,
                    int (int? v) => ((int)(v)),
                    int? (int? v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<int?, string>(
                    string (int? v) => (v == null ? null : ((object)v).ToString()),
                    int? (string v) => (v == null || v == "<null>" ? null : ((int? )(int.Parse(v)))),
                    convertsNulls: true),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int?, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<int?, string>(
                        string (int? v) => (v == null ? null : ((object)v).ToString()),
                        int? (string v) => (v == null || v == "<null>" ? null : ((int? )(int.Parse(v)))),
                        convertsNulls: true)));
            nullIntToNullStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBool = runtimeEntityType.AddProperty(
                "NullableBool",
                typeof(bool?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBool.SetGetter(
                bool? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBool(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableBool(instance).HasValue));
            nullableBool.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBool(instance) = value;
                    return instance;
                });
            nullableBool.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBool(instance) = value;
                    return instance;
                });
            nullableBool.SetAccessors(
                bool? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool? (IInternalEntry entry) => entry.ReadOriginalValue<bool?>(nullableBool, 106),
                bool? (IInternalEntry entry) => entry.GetCurrentValue<bool?>(nullableBool));
            nullableBool.SetPropertyIndexes(
                index: 106,
                originalValueIndex: 106,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableBool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v));
            nullableBool.SetComparer(new NullableValueComparer<bool>(nullableBool.TypeMapping.Comparer));
            nullableBool.SetKeyComparer(new NullableValueComparer<bool>(nullableBool.TypeMapping.KeyComparer));
            nullableBool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBoolArray = runtimeEntityType.AddProperty(
                "NullableBoolArray",
                typeof(bool?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableBoolArray.SetGetter(
                bool? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBoolArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBoolArray(instance) == null);
            nullableBoolArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBoolArray(instance) = value;
                    return instance;
                });
            nullableBoolArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, bool? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBoolArray(instance) = value;
                    return instance;
                });
            nullableBoolArray.SetAccessors(
                bool? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                bool? [] (IInternalEntry entry) => entry.ReadOriginalValue<bool? []>(nullableBoolArray, 107),
                bool? [] (IInternalEntry entry) => entry.GetCurrentValue<bool? []>(nullableBoolArray));
            nullableBoolArray.SetPropertyIndexes(
                index: 107,
                originalValueIndex: 107,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableBoolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<bool?[], bool>(new NullableValueComparer<bool>(new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<bool?[], bool>(new NullableValueComparer<bool>(new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool?>(new JsonCollectionOfNullableStructsReaderWriter<bool?[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<bool?[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        bool (bool v1, bool v2) => v1 == v2,
                        int (bool v) => ((object)v).GetHashCode(),
                        bool (bool v) => v)));
            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
                nullable: true);
            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
            nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytes = runtimeEntityType.AddProperty(
                "NullableBytes",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytes.SetGetter(
                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytes(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytes(instance) == null);
            nullableBytes.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBytes(instance) = value;
                    return instance;
                });
            nullableBytes.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBytes(instance) = value;
                    return instance;
                });
            nullableBytes.SetAccessors(
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(nullableBytes, 108),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(nullableBytes));
            nullableBytes.SetPropertyIndexes(
                index: 108,
                originalValueIndex: 108,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableBytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            nullableBytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytesArray = runtimeEntityType.AddProperty(
                "NullableBytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableBytesArray.SetGetter(
                byte[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytesArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytesArray(instance) == null);
            nullableBytesArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[][] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBytesArray(instance) = value;
                    return instance;
                });
            nullableBytesArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[][] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableBytesArray(instance) = value;
                    return instance;
                });
            nullableBytesArray.SetAccessors(
                byte[][] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[][] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableBytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[][] (IInternalEntry entry) => entry.ReadOriginalValue<byte[][]>(nullableBytesArray, 109),
                byte[][] (IInternalEntry entry) => entry.GetCurrentValue<byte[][]>(nullableBytesArray));
            nullableBytesArray.SetPropertyIndexes(
                index: 109,
                originalValueIndex: 109,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableBytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                        int (byte[] v) => ((object)v).GetHashCode(),
                        byte[] (byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                        byte[] (byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                        byte[] (byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
                nullable: true);
            nullableBytesArrayElementType.TypeMapping = nullableBytesArray.TypeMapping.ElementTypeMapping;
            nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableChar = runtimeEntityType.AddProperty(
                "NullableChar",
                typeof(char?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableChar.SetGetter(
                char? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableChar(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableChar(instance).HasValue));
            nullableChar.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableChar(instance) = value;
                    return instance;
                });
            nullableChar.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableChar(instance) = value;
                    return instance;
                });
            nullableChar.SetAccessors(
                char? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableChar(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableChar(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char? (IInternalEntry entry) => entry.ReadOriginalValue<char?>(nullableChar, 110),
                char? (IInternalEntry entry) => entry.GetCurrentValue<char?>(nullableChar));
            nullableChar.SetPropertyIndexes(
                index: 110,
                originalValueIndex: 110,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableChar.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v),
                keyComparer: new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                    char (string v) => (v.Length < 1 ? '\0' : v[0])),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        char (string v) => (v.Length < 1 ? '\0' : v[0]))));
            nullableChar.SetComparer(new NullableValueComparer<char>(nullableChar.TypeMapping.Comparer));
            nullableChar.SetKeyComparer(new NullableValueComparer<char>(nullableChar.TypeMapping.KeyComparer));
            nullableChar.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableCharArray = runtimeEntityType.AddProperty(
                "NullableCharArray",
                typeof(char?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableCharArray.SetGetter(
                char? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableCharArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableCharArray(instance) == null);
            nullableCharArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableCharArray(instance) = value;
                    return instance;
                });
            nullableCharArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, char? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableCharArray(instance) = value;
                    return instance;
                });
            nullableCharArray.SetAccessors(
                char? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableCharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableCharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                char? [] (IInternalEntry entry) => entry.ReadOriginalValue<char? []>(nullableCharArray, 111),
                char? [] (IInternalEntry entry) => entry.GetCurrentValue<char? []>(nullableCharArray));
            nullableCharArray.SetPropertyIndexes(
                index: 111,
                originalValueIndex: 111,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableCharArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<char?[], char>(new NullableValueComparer<char>(new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<char?[], char>(new NullableValueComparer<char>(new ValueComparer<char>(
                    bool (char v1, char v2) => v1 == v2,
                    int (char v) => ((int)(v)),
                    char (char v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char?>(new JsonCollectionOfNullableStructsReaderWriter<char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                            char (string v) => (v.Length < 1 ? '\0' : v[0]))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                            char (string v) => (v.Length < 1 ? '\0' : v[0])))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        bool (char v1, char v2) => v1 == v2,
                        int (char v) => ((int)(v)),
                        char (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        bool (char v1, char v2) => v1 == v2,
                        int (char v) => ((int)(v)),
                        char (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                        char (string v) => (v.Length < 1 ? '\0' : v[0])),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                            char (string v) => (v.Length < 1 ? '\0' : v[0])))));
            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
                nullable: true);
            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
            nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnly = runtimeEntityType.AddProperty(
                "NullableDateOnly",
                typeof(DateOnly?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnly.SetGetter(
                DateOnly? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateOnly(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDateOnly(instance).HasValue));
            nullableDateOnly.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateOnly(instance) = value;
                    return instance;
                });
            nullableDateOnly.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateOnly(instance) = value;
                    return instance;
                });
            nullableDateOnly.SetAccessors(
                DateOnly? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly? (IInternalEntry entry) => entry.ReadOriginalValue<DateOnly?>(nullableDateOnly, 112),
                DateOnly? (IInternalEntry entry) => entry.GetCurrentValue<DateOnly?>(nullableDateOnly));
            nullableDateOnly.SetPropertyIndexes(
                index: 112,
                originalValueIndex: 112,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v));
            nullableDateOnly.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnly.TypeMapping.Comparer));
            nullableDateOnly.SetKeyComparer(new NullableValueComparer<DateOnly>(nullableDateOnly.TypeMapping.KeyComparer));
            nullableDateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                "NullableDateOnlyArray",
                typeof(DateOnly?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDateOnlyArray.SetGetter(
                DateOnly? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(instance) == null);
            nullableDateOnlyArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateOnlyArray(instance) = value;
                    return instance;
                });
            nullableDateOnlyArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateOnly? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateOnlyArray(instance) = value;
                    return instance;
                });
            nullableDateOnlyArray.SetAccessors(
                DateOnly? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateOnly? [] (IInternalEntry entry) => entry.ReadOriginalValue<DateOnly? []>(nullableDateOnlyArray, 113),
                DateOnly? [] (IInternalEntry entry) => entry.GetCurrentValue<DateOnly? []>(nullableDateOnlyArray));
            nullableDateOnlyArray.SetPropertyIndexes(
                index: 113,
                originalValueIndex: 113,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<DateOnly?[], DateOnly>(new NullableValueComparer<DateOnly>(new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<DateOnly?[], DateOnly>(new NullableValueComparer<DateOnly>(new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonCollectionOfNullableStructsReaderWriter<DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        int (DateOnly v) => ((object)v).GetHashCode(),
                        DateOnly (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        int (DateOnly v) => ((object)v).GetHashCode(),
                        DateOnly (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        int (DateOnly v) => ((object)v).GetHashCode(),
                        DateOnly (DateOnly v) => v)));
            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
                nullable: true);
            nullableDateOnlyArrayElementType.TypeMapping = nullableDateOnlyArray.TypeMapping.ElementTypeMapping;
            nullableDateOnlyArrayElementType.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnlyArrayElementType.TypeMapping.Comparer));
            nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTime = runtimeEntityType.AddProperty(
                "NullableDateTime",
                typeof(DateTime?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTime.SetGetter(
                DateTime? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateTime(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDateTime(instance).HasValue));
            nullableDateTime.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateTime(instance) = value;
                    return instance;
                });
            nullableDateTime.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateTime(instance) = value;
                    return instance;
                });
            nullableDateTime.SetAccessors(
                DateTime? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime? (IInternalEntry entry) => entry.ReadOriginalValue<DateTime?>(nullableDateTime, 114),
                DateTime? (IInternalEntry entry) => entry.GetCurrentValue<DateTime?>(nullableDateTime));
            nullableDateTime.SetPropertyIndexes(
                index: 114,
                originalValueIndex: 114,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v));
            nullableDateTime.SetComparer(new NullableValueComparer<DateTime>(nullableDateTime.TypeMapping.Comparer));
            nullableDateTime.SetKeyComparer(new NullableValueComparer<DateTime>(nullableDateTime.TypeMapping.KeyComparer));
            nullableDateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTimeArray = runtimeEntityType.AddProperty(
                "NullableDateTimeArray",
                typeof(DateTime?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDateTimeArray.SetGetter(
                DateTime? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateTimeArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateTimeArray(instance) == null);
            nullableDateTimeArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateTimeArray(instance) = value;
                    return instance;
                });
            nullableDateTimeArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, DateTime? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDateTimeArray(instance) = value;
                    return instance;
                });
            nullableDateTimeArray.SetAccessors(
                DateTime? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                DateTime? [] (IInternalEntry entry) => entry.ReadOriginalValue<DateTime? []>(nullableDateTimeArray, 115),
                DateTime? [] (IInternalEntry entry) => entry.GetCurrentValue<DateTime? []>(nullableDateTimeArray));
            nullableDateTimeArray.SetPropertyIndexes(
                index: 115,
                originalValueIndex: 115,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<DateTime?[], DateTime>(new NullableValueComparer<DateTime>(new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<DateTime?[], DateTime>(new NullableValueComparer<DateTime>(new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonCollectionOfNullableStructsReaderWriter<DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                        int (DateTime v) => ((object)v).GetHashCode(),
                        DateTime (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                        int (DateTime v) => ((object)v).GetHashCode(),
                        DateTime (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                        int (DateTime v) => ((object)v).GetHashCode(),
                        DateTime (DateTime v) => v)));
            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
                nullable: true);
            nullableDateTimeArrayElementType.TypeMapping = nullableDateTimeArray.TypeMapping.ElementTypeMapping;
            nullableDateTimeArrayElementType.SetComparer(new NullableValueComparer<DateTime>(nullableDateTimeArrayElementType.TypeMapping.Comparer));
            nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimal = runtimeEntityType.AddProperty(
                "NullableDecimal",
                typeof(decimal?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimal.SetGetter(
                decimal? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDecimal(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDecimal(instance).HasValue));
            nullableDecimal.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDecimal(instance) = value;
                    return instance;
                });
            nullableDecimal.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDecimal(instance) = value;
                    return instance;
                });
            nullableDecimal.SetAccessors(
                decimal? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDecimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDecimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal? (IInternalEntry entry) => entry.ReadOriginalValue<decimal?>(nullableDecimal, 116),
                decimal? (IInternalEntry entry) => entry.GetCurrentValue<decimal?>(nullableDecimal));
            nullableDecimal.SetPropertyIndexes(
                index: 116,
                originalValueIndex: 116,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDecimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v));
            nullableDecimal.SetComparer(new NullableValueComparer<decimal>(nullableDecimal.TypeMapping.Comparer));
            nullableDecimal.SetKeyComparer(new NullableValueComparer<decimal>(nullableDecimal.TypeMapping.KeyComparer));
            nullableDecimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimalArray = runtimeEntityType.AddProperty(
                "NullableDecimalArray",
                typeof(decimal?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDecimalArray.SetGetter(
                decimal? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDecimalArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDecimalArray(instance) == null);
            nullableDecimalArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDecimalArray(instance) = value;
                    return instance;
                });
            nullableDecimalArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, decimal? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDecimalArray(instance) = value;
                    return instance;
                });
            nullableDecimalArray.SetAccessors(
                decimal? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                decimal? [] (IInternalEntry entry) => entry.ReadOriginalValue<decimal? []>(nullableDecimalArray, 117),
                decimal? [] (IInternalEntry entry) => entry.GetCurrentValue<decimal? []>(nullableDecimalArray));
            nullableDecimalArray.SetPropertyIndexes(
                index: 117,
                originalValueIndex: 117,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDecimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<decimal?[], decimal>(new NullableValueComparer<decimal>(new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<decimal?[], decimal>(new NullableValueComparer<decimal>(new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal?>(new JsonCollectionOfNullableStructsReaderWriter<decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v)));
            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
                nullable: true);
            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
            nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDouble = runtimeEntityType.AddProperty(
                "NullableDouble",
                typeof(double?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDouble.SetGetter(
                double? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDouble(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDouble(instance).HasValue));
            nullableDouble.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDouble(instance) = value;
                    return instance;
                });
            nullableDouble.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDouble(instance) = value;
                    return instance;
                });
            nullableDouble.SetAccessors(
                double? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDouble(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDouble(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double? (IInternalEntry entry) => entry.ReadOriginalValue<double?>(nullableDouble, 118),
                double? (IInternalEntry entry) => entry.GetCurrentValue<double?>(nullableDouble));
            nullableDouble.SetPropertyIndexes(
                index: 118,
                originalValueIndex: 118,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDouble.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                keyComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v));
            nullableDouble.SetComparer(new NullableValueComparer<double>(nullableDouble.TypeMapping.Comparer));
            nullableDouble.SetKeyComparer(new NullableValueComparer<double>(nullableDouble.TypeMapping.KeyComparer));
            nullableDouble.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDoubleArray = runtimeEntityType.AddProperty(
                "NullableDoubleArray",
                typeof(double?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDoubleArray.SetGetter(
                double? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDoubleArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDoubleArray(instance) == null);
            nullableDoubleArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDoubleArray(instance) = value;
                    return instance;
                });
            nullableDoubleArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, double? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableDoubleArray(instance) = value;
                    return instance;
                });
            nullableDoubleArray.SetAccessors(
                double? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableDoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                double? [] (IInternalEntry entry) => entry.ReadOriginalValue<double? []>(nullableDoubleArray, 119),
                double? [] (IInternalEntry entry) => entry.GetCurrentValue<double? []>(nullableDoubleArray));
            nullableDoubleArray.SetPropertyIndexes(
                index: 119,
                originalValueIndex: 119,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableDoubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<double?[], double>(new NullableValueComparer<double>(new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<double?[], double>(new NullableValueComparer<double>(new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double?>(new JsonCollectionOfNullableStructsReaderWriter<double?[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<double?[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        bool (double v1, double v2) => v1.Equals(v2),
                        int (double v) => ((object)v).GetHashCode(),
                        double (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        bool (double v1, double v2) => v1.Equals(v2),
                        int (double v) => ((object)v).GetHashCode(),
                        double (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        bool (double v1, double v2) => v1.Equals(v2),
                        int (double v) => ((object)v).GetHashCode(),
                        double (double v) => v)));
            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
                nullable: true);
            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
            nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16 = runtimeEntityType.AddProperty(
                "NullableEnum16",
                typeof(CompiledModelTestBase.Enum16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16.SetGetter(
                CompiledModelTestBase.Enum16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum16(instance).HasValue));
            nullableEnum16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16(instance) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value)))));
                    return instance;
                });
            nullableEnum16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16(instance) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value)))));
                    return instance;
                });
            nullableEnum16.SetAccessors(
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16?>(nullableEnum16, 120),
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16));
            nullableEnum16.SetPropertyIndexes(
                index: 120,
                originalValueIndex: 120,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                    short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                    CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))));
            nullableEnum16.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16.TypeMapping.Comparer));
            nullableEnum16.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16.TypeMapping.KeyComparer));
            nullableEnum16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16Array = runtimeEntityType.AddProperty(
                "NullableEnum16Array",
                typeof(CompiledModelTestBase.Enum16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16Array.SetGetter(
                CompiledModelTestBase.Enum16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Array(instance) == null);
            nullableEnum16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16Array(instance) = value;
                    return instance;
                });
            nullableEnum16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16Array(instance) = value;
                    return instance;
                });
            nullableEnum16Array.SetAccessors(
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array, 121),
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array));
            nullableEnum16Array.SetPropertyIndexes(
                index: 121,
                originalValueIndex: 121,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
                nullable: true);
            nullableEnum16ArrayElementType.TypeMapping = nullableEnum16Array.TypeMapping.ElementTypeMapping;
            nullableEnum16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16ArrayElementType.TypeMapping.Comparer));
            nullableEnum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16AsString = runtimeEntityType.AddProperty(
                "NullableEnum16AsString",
                typeof(CompiledModelTestBase.Enum16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16AsString.SetGetter(
                CompiledModelTestBase.Enum16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum16AsString(instance).HasValue));
            nullableEnum16AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value)))));
                    return instance;
                });
            nullableEnum16AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value)))));
                    return instance;
                });
            nullableEnum16AsString.SetAccessors(
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString, 122),
                CompiledModelTestBase.Enum16? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString));
            nullableEnum16AsString.SetPropertyIndexes(
                index: 122,
                originalValueIndex: 122,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum16AsString.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                    short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                    CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))));
            nullableEnum16AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsString.TypeMapping.Comparer));
            nullableEnum16AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsString.TypeMapping.KeyComparer));
            nullableEnum16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum16AsStringArray",
                typeof(CompiledModelTestBase.Enum16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16AsStringArray.SetGetter(
                CompiledModelTestBase.Enum16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(instance) == null);
            nullableEnum16AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum16AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum16AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray, 123),
                CompiledModelTestBase.Enum16? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray));
            nullableEnum16AsStringArray.SetPropertyIndexes(
                index: 123,
                originalValueIndex: 123,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
                nullable: true);
            nullableEnum16AsStringArrayElementType.TypeMapping = nullableEnum16AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnum16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum16AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(instance) == null);
            nullableEnum16AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum16AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum16AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection, 124),
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection));
            nullableEnum16AsStringCollection.SetPropertyIndexes(
                index: 124,
                originalValueIndex: 124,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
                nullable: true);
            nullableEnum16AsStringCollectionElementType.TypeMapping = nullableEnum16AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnum16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16Collection = runtimeEntityType.AddProperty(
                "NullableEnum16Collection",
                typeof(List<CompiledModelTestBase.Enum16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16Collection.SetGetter(
                List<CompiledModelTestBase.Enum16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Collection(instance) == null);
            nullableEnum16Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16Collection(instance) = value;
                    return instance;
                });
            nullableEnum16Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum16Collection(instance) = value;
                    return instance;
                });
            nullableEnum16Collection.SetAccessors(
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection, 125),
                List<CompiledModelTestBase.Enum16?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection));
            nullableEnum16Collection.SetPropertyIndexes(
                index: 125,
                originalValueIndex: 125,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                        CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                            CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
                nullable: true);
            nullableEnum16CollectionElementType.TypeMapping = nullableEnum16Collection.TypeMapping.ElementTypeMapping;
            nullableEnum16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16CollectionElementType.TypeMapping.Comparer));
            nullableEnum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32 = runtimeEntityType.AddProperty(
                "NullableEnum32",
                typeof(CompiledModelTestBase.Enum32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32.SetGetter(
                CompiledModelTestBase.Enum32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum32(instance).HasValue));
            nullableEnum32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32(instance) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value)))));
                    return instance;
                });
            nullableEnum32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32(instance) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value)))));
                    return instance;
                });
            nullableEnum32.SetAccessors(
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32?>(nullableEnum32, 126),
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32));
            nullableEnum32.SetPropertyIndexes(
                index: 126,
                originalValueIndex: 126,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                    CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))));
            nullableEnum32.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32.TypeMapping.Comparer));
            nullableEnum32.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32.TypeMapping.KeyComparer));
            nullableEnum32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32Array = runtimeEntityType.AddProperty(
                "NullableEnum32Array",
                typeof(CompiledModelTestBase.Enum32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32Array.SetGetter(
                CompiledModelTestBase.Enum32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Array(instance) == null);
            nullableEnum32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32Array(instance) = value;
                    return instance;
                });
            nullableEnum32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32Array(instance) = value;
                    return instance;
                });
            nullableEnum32Array.SetAccessors(
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array, 127),
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array));
            nullableEnum32Array.SetPropertyIndexes(
                index: 127,
                originalValueIndex: 127,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
                nullable: true);
            nullableEnum32ArrayElementType.TypeMapping = nullableEnum32Array.TypeMapping.ElementTypeMapping;
            nullableEnum32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32ArrayElementType.TypeMapping.Comparer));
            nullableEnum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32AsString = runtimeEntityType.AddProperty(
                "NullableEnum32AsString",
                typeof(CompiledModelTestBase.Enum32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32AsString.SetGetter(
                CompiledModelTestBase.Enum32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum32AsString(instance).HasValue));
            nullableEnum32AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value)))));
                    return instance;
                });
            nullableEnum32AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value)))));
                    return instance;
                });
            nullableEnum32AsString.SetAccessors(
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString, 128),
                CompiledModelTestBase.Enum32? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString));
            nullableEnum32AsString.SetPropertyIndexes(
                index: 128,
                originalValueIndex: 128,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum32AsString.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                    CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))));
            nullableEnum32AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsString.TypeMapping.Comparer));
            nullableEnum32AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsString.TypeMapping.KeyComparer));
            nullableEnum32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum32AsStringArray",
                typeof(CompiledModelTestBase.Enum32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32AsStringArray.SetGetter(
                CompiledModelTestBase.Enum32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(instance) == null);
            nullableEnum32AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum32AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum32AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray, 129),
                CompiledModelTestBase.Enum32? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray));
            nullableEnum32AsStringArray.SetPropertyIndexes(
                index: 129,
                originalValueIndex: 129,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
                nullable: true);
            nullableEnum32AsStringArrayElementType.TypeMapping = nullableEnum32AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnum32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum32AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(instance) == null);
            nullableEnum32AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum32AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum32AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection, 130),
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection));
            nullableEnum32AsStringCollection.SetPropertyIndexes(
                index: 130,
                originalValueIndex: 130,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
                nullable: true);
            nullableEnum32AsStringCollectionElementType.TypeMapping = nullableEnum32AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnum32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32Collection = runtimeEntityType.AddProperty(
                "NullableEnum32Collection",
                typeof(List<CompiledModelTestBase.Enum32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32Collection.SetGetter(
                List<CompiledModelTestBase.Enum32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Collection(instance) == null);
            nullableEnum32Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32Collection(instance) = value;
                    return instance;
                });
            nullableEnum32Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum32Collection(instance) = value;
                    return instance;
                });
            nullableEnum32Collection.SetAccessors(
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection, 131),
                List<CompiledModelTestBase.Enum32?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection));
            nullableEnum32Collection.SetPropertyIndexes(
                index: 131,
                originalValueIndex: 131,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                            CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
                nullable: true);
            nullableEnum32CollectionElementType.TypeMapping = nullableEnum32Collection.TypeMapping.ElementTypeMapping;
            nullableEnum32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32CollectionElementType.TypeMapping.Comparer));
            nullableEnum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64 = runtimeEntityType.AddProperty(
                "NullableEnum64",
                typeof(CompiledModelTestBase.Enum64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64.SetGetter(
                CompiledModelTestBase.Enum64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum64(instance).HasValue));
            nullableEnum64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64(instance) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value)))));
                    return instance;
                });
            nullableEnum64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64(instance) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value)))));
                    return instance;
                });
            nullableEnum64.SetAccessors(
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64?>(nullableEnum64, 132),
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64));
            nullableEnum64.SetPropertyIndexes(
                index: 132,
                originalValueIndex: 132,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                    long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                    CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))));
            nullableEnum64.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64.TypeMapping.Comparer));
            nullableEnum64.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64.TypeMapping.KeyComparer));
            nullableEnum64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64Array = runtimeEntityType.AddProperty(
                "NullableEnum64Array",
                typeof(CompiledModelTestBase.Enum64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64Array.SetGetter(
                CompiledModelTestBase.Enum64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Array(instance) == null);
            nullableEnum64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64Array(instance) = value;
                    return instance;
                });
            nullableEnum64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64Array(instance) = value;
                    return instance;
                });
            nullableEnum64Array.SetAccessors(
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array, 133),
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array));
            nullableEnum64Array.SetPropertyIndexes(
                index: 133,
                originalValueIndex: 133,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
                nullable: true);
            nullableEnum64ArrayElementType.TypeMapping = nullableEnum64Array.TypeMapping.ElementTypeMapping;
            nullableEnum64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64ArrayElementType.TypeMapping.Comparer));
            nullableEnum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64AsString = runtimeEntityType.AddProperty(
                "NullableEnum64AsString",
                typeof(CompiledModelTestBase.Enum64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64AsString.SetGetter(
                CompiledModelTestBase.Enum64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum64AsString(instance).HasValue));
            nullableEnum64AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value)))));
                    return instance;
                });
            nullableEnum64AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value)))));
                    return instance;
                });
            nullableEnum64AsString.SetAccessors(
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString, 134),
                CompiledModelTestBase.Enum64? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString));
            nullableEnum64AsString.SetPropertyIndexes(
                index: 134,
                originalValueIndex: 134,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum64AsString.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                    long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                    CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))));
            nullableEnum64AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsString.TypeMapping.Comparer));
            nullableEnum64AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsString.TypeMapping.KeyComparer));
            nullableEnum64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum64AsStringArray",
                typeof(CompiledModelTestBase.Enum64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64AsStringArray.SetGetter(
                CompiledModelTestBase.Enum64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(instance) == null);
            nullableEnum64AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum64AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum64AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray, 135),
                CompiledModelTestBase.Enum64? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray));
            nullableEnum64AsStringArray.SetPropertyIndexes(
                index: 135,
                originalValueIndex: 135,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
                nullable: true);
            nullableEnum64AsStringArrayElementType.TypeMapping = nullableEnum64AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnum64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum64AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(instance) == null);
            nullableEnum64AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum64AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum64AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection, 136),
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection));
            nullableEnum64AsStringCollection.SetPropertyIndexes(
                index: 136,
                originalValueIndex: 136,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
                nullable: true);
            nullableEnum64AsStringCollectionElementType.TypeMapping = nullableEnum64AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnum64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64Collection = runtimeEntityType.AddProperty(
                "NullableEnum64Collection",
                typeof(List<CompiledModelTestBase.Enum64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64Collection.SetGetter(
                List<CompiledModelTestBase.Enum64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Collection(instance) == null);
            nullableEnum64Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64Collection(instance) = value;
                    return instance;
                });
            nullableEnum64Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum64Collection(instance) = value;
                    return instance;
                });
            nullableEnum64Collection.SetAccessors(
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection, 137),
                List<CompiledModelTestBase.Enum64?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection));
            nullableEnum64Collection.SetPropertyIndexes(
                index: 137,
                originalValueIndex: 137,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                        CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                            CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
                nullable: true);
            nullableEnum64CollectionElementType.TypeMapping = nullableEnum64Collection.TypeMapping.ElementTypeMapping;
            nullableEnum64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64CollectionElementType.TypeMapping.Comparer));
            nullableEnum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8 = runtimeEntityType.AddProperty(
                "NullableEnum8",
                typeof(CompiledModelTestBase.Enum8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8.SetGetter(
                CompiledModelTestBase.Enum8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum8(instance).HasValue));
            nullableEnum8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8(instance) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value)))));
                    return instance;
                });
            nullableEnum8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8(instance) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value)))));
                    return instance;
                });
            nullableEnum8.SetAccessors(
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8?>(nullableEnum8, 138),
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8));
            nullableEnum8.SetPropertyIndexes(
                index: 138,
                originalValueIndex: 138,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                    short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                    CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))));
            nullableEnum8.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8.TypeMapping.Comparer));
            nullableEnum8.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8.TypeMapping.KeyComparer));
            nullableEnum8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8Array = runtimeEntityType.AddProperty(
                "NullableEnum8Array",
                typeof(CompiledModelTestBase.Enum8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8Array.SetGetter(
                CompiledModelTestBase.Enum8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Array(instance) == null);
            nullableEnum8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8Array(instance) = value;
                    return instance;
                });
            nullableEnum8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8Array(instance) = value;
                    return instance;
                });
            nullableEnum8Array.SetAccessors(
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array, 139),
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array));
            nullableEnum8Array.SetPropertyIndexes(
                index: 139,
                originalValueIndex: 139,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
                nullable: true);
            nullableEnum8ArrayElementType.TypeMapping = nullableEnum8Array.TypeMapping.ElementTypeMapping;
            nullableEnum8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8ArrayElementType.TypeMapping.Comparer));
            nullableEnum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8AsString = runtimeEntityType.AddProperty(
                "NullableEnum8AsString",
                typeof(CompiledModelTestBase.Enum8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8AsString.SetGetter(
                CompiledModelTestBase.Enum8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum8AsString(instance).HasValue));
            nullableEnum8AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value)))));
                    return instance;
                });
            nullableEnum8AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8AsString(instance) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value)))));
                    return instance;
                });
            nullableEnum8AsString.SetAccessors(
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString, 140),
                CompiledModelTestBase.Enum8? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString));
            nullableEnum8AsString.SetPropertyIndexes(
                index: 140,
                originalValueIndex: 140,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum8AsString.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                    short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                    CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))));
            nullableEnum8AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsString.TypeMapping.Comparer));
            nullableEnum8AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsString.TypeMapping.KeyComparer));
            nullableEnum8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum8AsStringArray",
                typeof(CompiledModelTestBase.Enum8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8AsStringArray.SetGetter(
                CompiledModelTestBase.Enum8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(instance) == null);
            nullableEnum8AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum8AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.Enum8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnum8AsStringArray.SetAccessors(
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray, 141),
                CompiledModelTestBase.Enum8? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray));
            nullableEnum8AsStringArray.SetPropertyIndexes(
                index: 141,
                originalValueIndex: 141,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
                nullable: true);
            nullableEnum8AsStringArrayElementType.TypeMapping = nullableEnum8AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnum8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum8AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8AsStringCollection.SetGetter(
                List<CompiledModelTestBase.Enum8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(instance) == null);
            nullableEnum8AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum8AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnum8AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection, 142),
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection));
            nullableEnum8AsStringCollection.SetPropertyIndexes(
                index: 142,
                originalValueIndex: 142,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
                nullable: true);
            nullableEnum8AsStringCollectionElementType.TypeMapping = nullableEnum8AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnum8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8Collection = runtimeEntityType.AddProperty(
                "NullableEnum8Collection",
                typeof(List<CompiledModelTestBase.Enum8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8Collection.SetGetter(
                List<CompiledModelTestBase.Enum8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Collection(instance) == null);
            nullableEnum8Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8Collection(instance) = value;
                    return instance;
                });
            nullableEnum8Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.Enum8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnum8Collection(instance) = value;
                    return instance;
                });
            nullableEnum8Collection.SetAccessors(
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection, 143),
                List<CompiledModelTestBase.Enum8?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection));
            nullableEnum8Collection.SetPropertyIndexes(
                index: 143,
                originalValueIndex: 143,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnum8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                        CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                            CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
                nullable: true);
            nullableEnum8CollectionElementType.TypeMapping = nullableEnum8Collection.TypeMapping.ElementTypeMapping;
            nullableEnum8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8CollectionElementType.TypeMapping.Comparer));
            nullableEnum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16 = runtimeEntityType.AddProperty(
                "NullableEnumU16",
                typeof(CompiledModelTestBase.EnumU16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16.SetGetter(
                CompiledModelTestBase.EnumU16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU16(instance).HasValue));
            nullableEnumU16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value)))));
                    return instance;
                });
            nullableEnumU16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value)))));
                    return instance;
                });
            nullableEnumU16.SetAccessors(
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16, 144),
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16));
            nullableEnumU16.SetPropertyIndexes(
                index: 144,
                originalValueIndex: 144,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                    int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                    CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))));
            nullableEnumU16.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16.TypeMapping.Comparer));
            nullableEnumU16.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16.TypeMapping.KeyComparer));
            nullableEnumU16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16Array = runtimeEntityType.AddProperty(
                "NullableEnumU16Array",
                typeof(CompiledModelTestBase.EnumU16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16Array.SetGetter(
                CompiledModelTestBase.EnumU16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Array(instance) == null);
            nullableEnumU16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16Array(instance) = value;
                    return instance;
                });
            nullableEnumU16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16Array(instance) = value;
                    return instance;
                });
            nullableEnumU16Array.SetAccessors(
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array, 145),
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array));
            nullableEnumU16Array.SetPropertyIndexes(
                index: 145,
                originalValueIndex: 145,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
                nullable: true);
            nullableEnumU16ArrayElementType.TypeMapping = nullableEnumU16Array.TypeMapping.ElementTypeMapping;
            nullableEnumU16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16ArrayElementType.TypeMapping.Comparer));
            nullableEnumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                "NullableEnumU16AsString",
                typeof(CompiledModelTestBase.EnumU16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16AsString.SetGetter(
                CompiledModelTestBase.EnumU16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU16AsString(instance).HasValue));
            nullableEnumU16AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value)))));
                    return instance;
                });
            nullableEnumU16AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value)))));
                    return instance;
                });
            nullableEnumU16AsString.SetAccessors(
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString, 146),
                CompiledModelTestBase.EnumU16? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString));
            nullableEnumU16AsString.SetPropertyIndexes(
                index: 146,
                originalValueIndex: 146,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU16AsString.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                    int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                    CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))));
            nullableEnumU16AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsString.TypeMapping.Comparer));
            nullableEnumU16AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsString.TypeMapping.KeyComparer));
            nullableEnumU16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU16AsStringArray",
                typeof(CompiledModelTestBase.EnumU16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(instance) == null);
            nullableEnumU16AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU16AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU16? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU16AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray, 147),
                CompiledModelTestBase.EnumU16? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray));
            nullableEnumU16AsStringArray.SetPropertyIndexes(
                index: 147,
                originalValueIndex: 147,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
                nullable: true);
            nullableEnumU16AsStringArrayElementType.TypeMapping = nullableEnumU16AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnumU16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU16AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(instance) == null);
            nullableEnumU16AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU16AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU16AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection, 148),
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection));
            nullableEnumU16AsStringCollection.SetPropertyIndexes(
                index: 148,
                originalValueIndex: 148,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
                nullable: true);
            nullableEnumU16AsStringCollectionElementType.TypeMapping = nullableEnumU16AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnumU16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                "NullableEnumU16Collection",
                typeof(List<CompiledModelTestBase.EnumU16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16Collection.SetGetter(
                List<CompiledModelTestBase.EnumU16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(instance) == null);
            nullableEnumU16Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16Collection(instance) = value;
                    return instance;
                });
            nullableEnumU16Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU16?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU16Collection(instance) = value;
                    return instance;
                });
            nullableEnumU16Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection, 149),
                List<CompiledModelTestBase.EnumU16?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection));
            nullableEnumU16Collection.SetPropertyIndexes(
                index: 149,
                originalValueIndex: 149,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                        CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                            CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
                nullable: true);
            nullableEnumU16CollectionElementType.TypeMapping = nullableEnumU16Collection.TypeMapping.ElementTypeMapping;
            nullableEnumU16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16CollectionElementType.TypeMapping.Comparer));
            nullableEnumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32 = runtimeEntityType.AddProperty(
                "NullableEnumU32",
                typeof(CompiledModelTestBase.EnumU32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32.SetGetter(
                CompiledModelTestBase.EnumU32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU32(instance).HasValue));
            nullableEnumU32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value)))));
                    return instance;
                });
            nullableEnumU32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value)))));
                    return instance;
                });
            nullableEnumU32.SetAccessors(
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32, 150),
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32));
            nullableEnumU32.SetPropertyIndexes(
                index: 150,
                originalValueIndex: 150,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                    long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                    CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))));
            nullableEnumU32.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32.TypeMapping.Comparer));
            nullableEnumU32.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32.TypeMapping.KeyComparer));
            nullableEnumU32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32Array = runtimeEntityType.AddProperty(
                "NullableEnumU32Array",
                typeof(CompiledModelTestBase.EnumU32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32Array.SetGetter(
                CompiledModelTestBase.EnumU32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Array(instance) == null);
            nullableEnumU32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32Array(instance) = value;
                    return instance;
                });
            nullableEnumU32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32Array(instance) = value;
                    return instance;
                });
            nullableEnumU32Array.SetAccessors(
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array, 151),
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array));
            nullableEnumU32Array.SetPropertyIndexes(
                index: 151,
                originalValueIndex: 151,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
                nullable: true);
            nullableEnumU32ArrayElementType.TypeMapping = nullableEnumU32Array.TypeMapping.ElementTypeMapping;
            nullableEnumU32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32ArrayElementType.TypeMapping.Comparer));
            nullableEnumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                "NullableEnumU32AsString",
                typeof(CompiledModelTestBase.EnumU32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32AsString.SetGetter(
                CompiledModelTestBase.EnumU32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU32AsString(instance).HasValue));
            nullableEnumU32AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value)))));
                    return instance;
                });
            nullableEnumU32AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value)))));
                    return instance;
                });
            nullableEnumU32AsString.SetAccessors(
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString, 152),
                CompiledModelTestBase.EnumU32? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString));
            nullableEnumU32AsString.SetPropertyIndexes(
                index: 152,
                originalValueIndex: 152,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU32AsString.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                    long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                    CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))));
            nullableEnumU32AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsString.TypeMapping.Comparer));
            nullableEnumU32AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsString.TypeMapping.KeyComparer));
            nullableEnumU32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU32AsStringArray",
                typeof(CompiledModelTestBase.EnumU32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(instance) == null);
            nullableEnumU32AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU32AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU32? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU32AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray, 153),
                CompiledModelTestBase.EnumU32? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray));
            nullableEnumU32AsStringArray.SetPropertyIndexes(
                index: 153,
                originalValueIndex: 153,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
                nullable: true);
            nullableEnumU32AsStringArrayElementType.TypeMapping = nullableEnumU32AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnumU32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU32AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(instance) == null);
            nullableEnumU32AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU32AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU32AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection, 154),
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection));
            nullableEnumU32AsStringCollection.SetPropertyIndexes(
                index: 154,
                originalValueIndex: 154,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
                nullable: true);
            nullableEnumU32AsStringCollectionElementType.TypeMapping = nullableEnumU32AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnumU32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                "NullableEnumU32Collection",
                typeof(List<CompiledModelTestBase.EnumU32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32Collection.SetGetter(
                List<CompiledModelTestBase.EnumU32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(instance) == null);
            nullableEnumU32Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32Collection(instance) = value;
                    return instance;
                });
            nullableEnumU32Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU32?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU32Collection(instance) = value;
                    return instance;
                });
            nullableEnumU32Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection, 155),
                List<CompiledModelTestBase.EnumU32?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection));
            nullableEnumU32Collection.SetPropertyIndexes(
                index: 155,
                originalValueIndex: 155,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                        CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                            CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
                nullable: true);
            nullableEnumU32CollectionElementType.TypeMapping = nullableEnumU32Collection.TypeMapping.ElementTypeMapping;
            nullableEnumU32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32CollectionElementType.TypeMapping.Comparer));
            nullableEnumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64 = runtimeEntityType.AddProperty(
                "NullableEnumU64",
                typeof(CompiledModelTestBase.EnumU64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64.SetGetter(
                CompiledModelTestBase.EnumU64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU64(instance).HasValue));
            nullableEnumU64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value)))));
                    return instance;
                });
            nullableEnumU64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value)))));
                    return instance;
                });
            nullableEnumU64.SetAccessors(
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64, 156),
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64));
            nullableEnumU64.SetPropertyIndexes(
                index: 156,
                originalValueIndex: 156,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                    decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                    CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))));
            nullableEnumU64.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64.TypeMapping.Comparer));
            nullableEnumU64.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64.TypeMapping.KeyComparer));
            nullableEnumU64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64Array = runtimeEntityType.AddProperty(
                "NullableEnumU64Array",
                typeof(CompiledModelTestBase.EnumU64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64Array.SetGetter(
                CompiledModelTestBase.EnumU64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Array(instance) == null);
            nullableEnumU64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64Array(instance) = value;
                    return instance;
                });
            nullableEnumU64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64Array(instance) = value;
                    return instance;
                });
            nullableEnumU64Array.SetAccessors(
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array, 157),
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array));
            nullableEnumU64Array.SetPropertyIndexes(
                index: 157,
                originalValueIndex: 157,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
                nullable: true);
            nullableEnumU64ArrayElementType.TypeMapping = nullableEnumU64Array.TypeMapping.ElementTypeMapping;
            nullableEnumU64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64ArrayElementType.TypeMapping.Comparer));
            nullableEnumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                "NullableEnumU64AsString",
                typeof(CompiledModelTestBase.EnumU64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64AsString.SetGetter(
                CompiledModelTestBase.EnumU64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU64AsString(instance).HasValue));
            nullableEnumU64AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value)))));
                    return instance;
                });
            nullableEnumU64AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value)))));
                    return instance;
                });
            nullableEnumU64AsString.SetAccessors(
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString, 158),
                CompiledModelTestBase.EnumU64? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString));
            nullableEnumU64AsString.SetPropertyIndexes(
                index: 158,
                originalValueIndex: 158,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU64AsString.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                    decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                    CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))));
            nullableEnumU64AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsString.TypeMapping.Comparer));
            nullableEnumU64AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsString.TypeMapping.KeyComparer));
            nullableEnumU64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU64AsStringArray",
                typeof(CompiledModelTestBase.EnumU64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(instance) == null);
            nullableEnumU64AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU64AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU64? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU64AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray, 159),
                CompiledModelTestBase.EnumU64? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray));
            nullableEnumU64AsStringArray.SetPropertyIndexes(
                index: 159,
                originalValueIndex: 159,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
                nullable: true);
            nullableEnumU64AsStringArrayElementType.TypeMapping = nullableEnumU64AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnumU64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU64AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(instance) == null);
            nullableEnumU64AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU64AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU64AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection, 160),
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection));
            nullableEnumU64AsStringCollection.SetPropertyIndexes(
                index: 160,
                originalValueIndex: 160,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
                nullable: true);
            nullableEnumU64AsStringCollectionElementType.TypeMapping = nullableEnumU64AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnumU64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                "NullableEnumU64Collection",
                typeof(List<CompiledModelTestBase.EnumU64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64Collection.SetGetter(
                List<CompiledModelTestBase.EnumU64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(instance) == null);
            nullableEnumU64Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64Collection(instance) = value;
                    return instance;
                });
            nullableEnumU64Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU64?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU64Collection(instance) = value;
                    return instance;
                });
            nullableEnumU64Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection, 161),
                List<CompiledModelTestBase.EnumU64?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection));
            nullableEnumU64Collection.SetPropertyIndexes(
                index: 161,
                originalValueIndex: 161,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value)))))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                        CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                            CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
                nullable: true);
            nullableEnumU64CollectionElementType.TypeMapping = nullableEnumU64Collection.TypeMapping.ElementTypeMapping;
            nullableEnumU64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64CollectionElementType.TypeMapping.Comparer));
            nullableEnumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8 = runtimeEntityType.AddProperty(
                "NullableEnumU8",
                typeof(CompiledModelTestBase.EnumU8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8.SetGetter(
                CompiledModelTestBase.EnumU8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU8(instance).HasValue));
            nullableEnumU8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value)))));
                    return instance;
                });
            nullableEnumU8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value)))));
                    return instance;
                });
            nullableEnumU8.SetAccessors(
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8, 162),
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8));
            nullableEnumU8.SetPropertyIndexes(
                index: 162,
                originalValueIndex: 162,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                    byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                    CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))));
            nullableEnumU8.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8.TypeMapping.Comparer));
            nullableEnumU8.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8.TypeMapping.KeyComparer));
            nullableEnumU8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8Array = runtimeEntityType.AddProperty(
                "NullableEnumU8Array",
                typeof(CompiledModelTestBase.EnumU8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8Array.SetGetter(
                CompiledModelTestBase.EnumU8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Array(instance) == null);
            nullableEnumU8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8Array(instance) = value;
                    return instance;
                });
            nullableEnumU8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8Array(instance) = value;
                    return instance;
                });
            nullableEnumU8Array.SetAccessors(
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array, 163),
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array));
            nullableEnumU8Array.SetPropertyIndexes(
                index: 163,
                originalValueIndex: 163,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
                nullable: true);
            nullableEnumU8ArrayElementType.TypeMapping = nullableEnumU8Array.TypeMapping.ElementTypeMapping;
            nullableEnumU8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8ArrayElementType.TypeMapping.Comparer));
            nullableEnumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                "NullableEnumU8AsString",
                typeof(CompiledModelTestBase.EnumU8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8AsString.SetGetter(
                CompiledModelTestBase.EnumU8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU8AsString(instance).HasValue));
            nullableEnumU8AsString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value)))));
                    return instance;
                });
            nullableEnumU8AsString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8AsString(instance) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value)))));
                    return instance;
                });
            nullableEnumU8AsString.SetAccessors(
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString, 164),
                CompiledModelTestBase.EnumU8? (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString));
            nullableEnumU8AsString.SetPropertyIndexes(
                index: 164,
                originalValueIndex: 164,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU8AsString.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                    byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                    CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))));
            nullableEnumU8AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsString.TypeMapping.Comparer));
            nullableEnumU8AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsString.TypeMapping.KeyComparer));
            nullableEnumU8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU8AsStringArray",
                typeof(CompiledModelTestBase.EnumU8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8AsStringArray.SetGetter(
                CompiledModelTestBase.EnumU8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(instance) == null);
            nullableEnumU8AsStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU8AsStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, CompiledModelTestBase.EnumU8? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(instance) = value;
                    return instance;
                });
            nullableEnumU8AsStringArray.SetAccessors(
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray, 165),
                CompiledModelTestBase.EnumU8? [] (IInternalEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray));
            nullableEnumU8AsStringArray.SetPropertyIndexes(
                index: 165,
                originalValueIndex: 165,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
                nullable: true);
            nullableEnumU8AsStringArrayElementType.TypeMapping = nullableEnumU8AsStringArray.TypeMapping.ElementTypeMapping;
            nullableEnumU8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringArrayElementType.TypeMapping.Comparer));
            nullableEnumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU8AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8AsStringCollection.SetGetter(
                List<CompiledModelTestBase.EnumU8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(instance) == null);
            nullableEnumU8AsStringCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU8AsStringCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(instance) = value;
                    return instance;
                });
            nullableEnumU8AsStringCollection.SetAccessors(
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection, 166),
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection));
            nullableEnumU8AsStringCollection.SetPropertyIndexes(
                index: 166,
                originalValueIndex: 166,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
                nullable: true);
            nullableEnumU8AsStringCollectionElementType.TypeMapping = nullableEnumU8AsStringCollection.TypeMapping.ElementTypeMapping;
            nullableEnumU8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringCollectionElementType.TypeMapping.Comparer));
            nullableEnumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                "NullableEnumU8Collection",
                typeof(List<CompiledModelTestBase.EnumU8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8Collection.SetGetter(
                List<CompiledModelTestBase.EnumU8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(instance) == null);
            nullableEnumU8Collection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8Collection(instance) = value;
                    return instance;
                });
            nullableEnumU8Collection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, List<CompiledModelTestBase.EnumU8?> value) =>
                {
                    ManyTypesUnsafeAccessors.NullableEnumU8Collection(instance) = value;
                    return instance;
                });
            nullableEnumU8Collection.SetAccessors(
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection, 167),
                List<CompiledModelTestBase.EnumU8?> (IInternalEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection));
            nullableEnumU8Collection.SetPropertyIndexes(
                index: 167,
                originalValueIndex: 167,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableEnumU8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                        CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                            CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
                nullable: true);
            nullableEnumU8CollectionElementType.TypeMapping = nullableEnumU8Collection.TypeMapping.ElementTypeMapping;
            nullableEnumU8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8CollectionElementType.TypeMapping.Comparer));
            nullableEnumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloat = runtimeEntityType.AddProperty(
                "NullableFloat",
                typeof(float?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloat.SetGetter(
                float? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableFloat(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableFloat(instance).HasValue));
            nullableFloat.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableFloat(instance) = value;
                    return instance;
                });
            nullableFloat.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableFloat(instance) = value;
                    return instance;
                });
            nullableFloat.SetAccessors(
                float? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableFloat(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableFloat(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float? (IInternalEntry entry) => entry.ReadOriginalValue<float?>(nullableFloat, 168),
                float? (IInternalEntry entry) => entry.GetCurrentValue<float?>(nullableFloat));
            nullableFloat.SetPropertyIndexes(
                index: 168,
                originalValueIndex: 168,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableFloat.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v),
                keyComparer: new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v));
            nullableFloat.SetComparer(new NullableValueComparer<float>(nullableFloat.TypeMapping.Comparer));
            nullableFloat.SetKeyComparer(new NullableValueComparer<float>(nullableFloat.TypeMapping.KeyComparer));
            nullableFloat.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloatArray = runtimeEntityType.AddProperty(
                "NullableFloatArray",
                typeof(float?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableFloatArray.SetGetter(
                float? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableFloatArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableFloatArray(instance) == null);
            nullableFloatArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableFloatArray(instance) = value;
                    return instance;
                });
            nullableFloatArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, float? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableFloatArray(instance) = value;
                    return instance;
                });
            nullableFloatArray.SetAccessors(
                float? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableFloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableFloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                float? [] (IInternalEntry entry) => entry.ReadOriginalValue<float? []>(nullableFloatArray, 169),
                float? [] (IInternalEntry entry) => entry.GetCurrentValue<float? []>(nullableFloatArray));
            nullableFloatArray.SetPropertyIndexes(
                index: 169,
                originalValueIndex: 169,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableFloatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<float?[], float>(new NullableValueComparer<float>(new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<float?[], float>(new NullableValueComparer<float>(new ValueComparer<float>(
                    bool (float v1, float v2) => v1.Equals(v2),
                    int (float v) => ((object)v).GetHashCode(),
                    float (float v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float?>(new JsonCollectionOfNullableStructsReaderWriter<float?[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<float?[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        bool (float v1, float v2) => v1.Equals(v2),
                        int (float v) => ((object)v).GetHashCode(),
                        float (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        bool (float v1, float v2) => v1.Equals(v2),
                        int (float v) => ((object)v).GetHashCode(),
                        float (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        bool (float v1, float v2) => v1.Equals(v2),
                        int (float v) => ((object)v).GetHashCode(),
                        float (float v) => v)));
            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
                nullable: true);
            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
            nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuid = runtimeEntityType.AddProperty(
                "NullableGuid",
                typeof(Guid?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuid.SetGetter(
                Guid? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuid(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableGuid(instance).HasValue));
            nullableGuid.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableGuid(instance) = value;
                    return instance;
                });
            nullableGuid.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableGuid(instance) = value;
                    return instance;
                });
            nullableGuid.SetAccessors(
                Guid? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableGuid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableGuid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid? (IInternalEntry entry) => entry.ReadOriginalValue<Guid?>(nullableGuid, 170),
                Guid? (IInternalEntry entry) => entry.GetCurrentValue<Guid?>(nullableGuid));
            nullableGuid.SetPropertyIndexes(
                index: 170,
                originalValueIndex: 170,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableGuid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            nullableGuid.SetComparer(new NullableValueComparer<Guid>(nullableGuid.TypeMapping.Comparer));
            nullableGuid.SetKeyComparer(new NullableValueComparer<Guid>(nullableGuid.TypeMapping.KeyComparer));
            nullableGuid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuidArray = runtimeEntityType.AddProperty(
                "NullableGuidArray",
                typeof(Guid?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableGuidArray.SetGetter(
                Guid? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuidArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuidArray(instance) == null);
            nullableGuidArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableGuidArray(instance) = value;
                    return instance;
                });
            nullableGuidArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Guid? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableGuidArray(instance) = value;
                    return instance;
                });
            nullableGuidArray.SetAccessors(
                Guid? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableGuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableGuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Guid? [] (IInternalEntry entry) => entry.ReadOriginalValue<Guid? []>(nullableGuidArray, 171),
                Guid? [] (IInternalEntry entry) => entry.GetCurrentValue<Guid? []>(nullableGuidArray));
            nullableGuidArray.SetPropertyIndexes(
                index: 171,
                originalValueIndex: 171,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableGuidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
                    bool (Guid v1, Guid v2) => v1 == v2,
                    int (Guid v) => ((object)v).GetHashCode(),
                    Guid (Guid v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid?>(new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        bool (Guid v1, Guid v2) => v1 == v2,
                        int (Guid v) => ((object)v).GetHashCode(),
                        Guid (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        bool (Guid v1, Guid v2) => v1 == v2,
                        int (Guid v) => ((object)v).GetHashCode(),
                        Guid (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        bool (Guid v1, Guid v2) => v1 == v2,
                        int (Guid v) => ((object)v).GetHashCode(),
                        Guid (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
                nullable: true);
            nullableGuidArrayElementType.TypeMapping = nullableGuidArray.TypeMapping.ElementTypeMapping;
            nullableGuidArrayElementType.SetComparer(new NullableValueComparer<Guid>(nullableGuidArrayElementType.TypeMapping.Comparer));
            nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddress = runtimeEntityType.AddProperty(
                "NullableIPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddress.SetGetter(
                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddress(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddress(instance) == null);
            nullableIPAddress.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.NullableIPAddress(instance) = value;
                    return instance;
                });
            nullableIPAddress.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress value) =>
                {
                    ManyTypesUnsafeAccessors.NullableIPAddress(instance) = value;
                    return instance;
                });
            nullableIPAddress.SetAccessors(
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress (IInternalEntry entry) => entry.ReadOriginalValue<IPAddress>(nullableIPAddress, 172),
                IPAddress (IInternalEntry entry) => entry.GetCurrentValue<IPAddress>(nullableIPAddress));
            nullableIPAddress.SetPropertyIndexes(
                index: 172,
                originalValueIndex: 172,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableIPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    string (IPAddress v) => ((object)v).ToString(),
                    IPAddress (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        string (IPAddress v) => ((object)v).ToString(),
                        IPAddress (string v) => IPAddress.Parse(v))));
            nullableIPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddressArray = runtimeEntityType.AddProperty(
                "NullableIPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableIPAddressArray.SetGetter(
                IPAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddressArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddressArray(instance) == null);
            nullableIPAddressArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableIPAddressArray(instance) = value;
                    return instance;
                });
            nullableIPAddressArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IPAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableIPAddressArray(instance) = value;
                    return instance;
                });
            nullableIPAddressArray.SetAccessors(
                IPAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                IPAddress[] (IInternalEntry entry) => entry.ReadOriginalValue<IPAddress[]>(nullableIPAddressArray, 173),
                IPAddress[] (IInternalEntry entry) => entry.GetCurrentValue<IPAddress[]>(nullableIPAddressArray));
            nullableIPAddressArray.SetPropertyIndexes(
                index: 173,
                originalValueIndex: 173,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableIPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (IPAddress v) => ((object)v).GetHashCode(),
                    IPAddress (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (IPAddress v) => ((object)v).GetHashCode(),
                        IPAddress (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (IPAddress v) => ((object)v).GetHashCode(),
                        IPAddress (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        string (IPAddress v) => ((object)v).ToString(),
                        IPAddress (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            string (IPAddress v) => ((object)v).ToString(),
                            IPAddress (string v) => IPAddress.Parse(v)))));
            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
                nullable: true);
            nullableIPAddressArrayElementType.TypeMapping = nullableIPAddressArray.TypeMapping.ElementTypeMapping;
            nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16 = runtimeEntityType.AddProperty(
                "NullableInt16",
                typeof(short?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16.SetGetter(
                short? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt16(instance).HasValue));
            nullableInt16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt16(instance) = value;
                    return instance;
                });
            nullableInt16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt16(instance) = value;
                    return instance;
                });
            nullableInt16.SetAccessors(
                short? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short? (IInternalEntry entry) => entry.ReadOriginalValue<short?>(nullableInt16, 174),
                short? (IInternalEntry entry) => entry.GetCurrentValue<short?>(nullableInt16));
            nullableInt16.SetPropertyIndexes(
                index: 174,
                originalValueIndex: 174,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                keyComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v));
            nullableInt16.SetComparer(new NullableValueComparer<short>(nullableInt16.TypeMapping.Comparer));
            nullableInt16.SetKeyComparer(new NullableValueComparer<short>(nullableInt16.TypeMapping.KeyComparer));
            nullableInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16Array = runtimeEntityType.AddProperty(
                "NullableInt16Array",
                typeof(short?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt16Array.SetGetter(
                short? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt16Array(instance) == null);
            nullableInt16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt16Array(instance) = value;
                    return instance;
                });
            nullableInt16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, short? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt16Array(instance) = value;
                    return instance;
                });
            nullableInt16Array.SetAccessors(
                short? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                short? [] (IInternalEntry entry) => entry.ReadOriginalValue<short? []>(nullableInt16Array, 175),
                short? [] (IInternalEntry entry) => entry.GetCurrentValue<short? []>(nullableInt16Array));
            nullableInt16Array.SetPropertyIndexes(
                index: 175,
                originalValueIndex: 175,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<short?[], short>(new NullableValueComparer<short>(new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<short?[], short>(new NullableValueComparer<short>(new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short?>(new JsonCollectionOfNullableStructsReaderWriter<short?[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<short?[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v)));
            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
                nullable: true);
            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
            nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32 = runtimeEntityType.AddProperty(
                "NullableInt32",
                typeof(int?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32.SetGetter(
                int? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt32(instance).HasValue));
            nullableInt32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt32(instance) = value;
                    return instance;
                });
            nullableInt32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt32(instance) = value;
                    return instance;
                });
            nullableInt32.SetAccessors(
                int? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int? (IInternalEntry entry) => entry.ReadOriginalValue<int?>(nullableInt32, 176),
                int? (IInternalEntry entry) => entry.GetCurrentValue<int?>(nullableInt32));
            nullableInt32.SetPropertyIndexes(
                index: 176,
                originalValueIndex: 176,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v));
            nullableInt32.SetComparer(new NullableValueComparer<int>(nullableInt32.TypeMapping.Comparer));
            nullableInt32.SetKeyComparer(new NullableValueComparer<int>(nullableInt32.TypeMapping.KeyComparer));
            nullableInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32Array = runtimeEntityType.AddProperty(
                "NullableInt32Array",
                typeof(int?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt32Array.SetGetter(
                int? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32Array(instance) == null);
            nullableInt32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt32Array(instance) = value;
                    return instance;
                });
            nullableInt32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, int? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt32Array(instance) = value;
                    return instance;
                });
            nullableInt32Array.SetAccessors(
                int? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                int? [] (IInternalEntry entry) => entry.ReadOriginalValue<int? []>(nullableInt32Array, 177),
                int? [] (IInternalEntry entry) => entry.GetCurrentValue<int? []>(nullableInt32Array));
            nullableInt32Array.SetPropertyIndexes(
                index: 177,
                originalValueIndex: 177,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int?>(new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v)));
            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
                nullable: true);
            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
            nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64 = runtimeEntityType.AddProperty(
                "NullableInt64",
                typeof(long?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64.SetGetter(
                long? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt64(instance).HasValue));
            nullableInt64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt64(instance) = value;
                    return instance;
                });
            nullableInt64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt64(instance) = value;
                    return instance;
                });
            nullableInt64.SetAccessors(
                long? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long? (IInternalEntry entry) => entry.ReadOriginalValue<long?>(nullableInt64, 178),
                long? (IInternalEntry entry) => entry.GetCurrentValue<long?>(nullableInt64));
            nullableInt64.SetPropertyIndexes(
                index: 178,
                originalValueIndex: 178,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                keyComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v));
            nullableInt64.SetComparer(new NullableValueComparer<long>(nullableInt64.TypeMapping.Comparer));
            nullableInt64.SetKeyComparer(new NullableValueComparer<long>(nullableInt64.TypeMapping.KeyComparer));
            nullableInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64Array = runtimeEntityType.AddProperty(
                "NullableInt64Array",
                typeof(long?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt64Array.SetGetter(
                long? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64Array(instance) == null);
            nullableInt64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt64Array(instance) = value;
                    return instance;
                });
            nullableInt64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, long? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt64Array(instance) = value;
                    return instance;
                });
            nullableInt64Array.SetAccessors(
                long? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                long? [] (IInternalEntry entry) => entry.ReadOriginalValue<long? []>(nullableInt64Array, 179),
                long? [] (IInternalEntry entry) => entry.GetCurrentValue<long? []>(nullableInt64Array));
            nullableInt64Array.SetPropertyIndexes(
                index: 179,
                originalValueIndex: 179,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long?>(new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v)));
            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
                nullable: true);
            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
            nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8 = runtimeEntityType.AddProperty(
                "NullableInt8",
                typeof(sbyte?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8.SetGetter(
                sbyte? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt8(instance).HasValue));
            nullableInt8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt8(instance) = value;
                    return instance;
                });
            nullableInt8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt8(instance) = value;
                    return instance;
                });
            nullableInt8.SetAccessors(
                sbyte? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte? (IInternalEntry entry) => entry.ReadOriginalValue<sbyte?>(nullableInt8, 180),
                sbyte? (IInternalEntry entry) => entry.GetCurrentValue<sbyte?>(nullableInt8));
            nullableInt8.SetPropertyIndexes(
                index: 180,
                originalValueIndex: 180,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v),
                providerValueComparer: new ValueComparer<short>(
                    bool (short v1, short v2) => v1 == v2,
                    int (short v) => ((int)(v)),
                    short (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    short (sbyte v) => ((short)(v)),
                    sbyte (short v) => ((sbyte)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        short (sbyte v) => ((short)(v)),
                        sbyte (short v) => ((sbyte)(v)))));
            nullableInt8.SetComparer(new NullableValueComparer<sbyte>(nullableInt8.TypeMapping.Comparer));
            nullableInt8.SetKeyComparer(new NullableValueComparer<sbyte>(nullableInt8.TypeMapping.KeyComparer));
            nullableInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8Array = runtimeEntityType.AddProperty(
                "NullableInt8Array",
                typeof(sbyte?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt8Array.SetGetter(
                sbyte? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt8Array(instance) == null);
            nullableInt8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt8Array(instance) = value;
                    return instance;
                });
            nullableInt8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, sbyte? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableInt8Array(instance) = value;
                    return instance;
                });
            nullableInt8Array.SetAccessors(
                sbyte? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                sbyte? [] (IInternalEntry entry) => entry.ReadOriginalValue<sbyte? []>(nullableInt8Array, 181),
                sbyte? [] (IInternalEntry entry) => entry.GetCurrentValue<sbyte? []>(nullableInt8Array));
            nullableInt8Array.SetPropertyIndexes(
                index: 181,
                originalValueIndex: 181,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<sbyte?[], sbyte>(new NullableValueComparer<sbyte>(new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<sbyte?[], sbyte>(new NullableValueComparer<sbyte>(new ValueComparer<sbyte>(
                    bool (sbyte v1, sbyte v2) => v1 == v2,
                    int (sbyte v) => ((int)(v)),
                    sbyte (sbyte v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonCollectionOfNullableStructsReaderWriter<sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            short (sbyte v) => ((short)(v)),
                            sbyte (short v) => ((sbyte)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            short (sbyte v) => ((short)(v)),
                            sbyte (short v) => ((sbyte)(v))))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        bool (sbyte v1, sbyte v2) => v1 == v2,
                        int (sbyte v) => ((int)(v)),
                        sbyte (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        bool (sbyte v1, sbyte v2) => v1 == v2,
                        int (sbyte v) => ((int)(v)),
                        sbyte (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        bool (short v1, short v2) => v1 == v2,
                        int (short v) => ((int)(v)),
                        short (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        short (sbyte v) => ((short)(v)),
                        sbyte (short v) => ((sbyte)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            short (sbyte v) => ((short)(v)),
                            sbyte (short v) => ((sbyte)(v))))));
            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
                nullable: true);
            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
            nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                "NullablePhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddress.SetGetter(
                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(instance) == null);
            nullablePhysicalAddress.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.NullablePhysicalAddress(instance) = value;
                    return instance;
                });
            nullablePhysicalAddress.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.NullablePhysicalAddress(instance) = value;
                    return instance;
                });
            nullablePhysicalAddress.SetAccessors(
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(nullablePhysicalAddress, 182),
                PhysicalAddress (IInternalEntry entry) => entry.GetCurrentValue<PhysicalAddress>(nullablePhysicalAddress));
            nullablePhysicalAddress.SetPropertyIndexes(
                index: 182,
                originalValueIndex: 182,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullablePhysicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    string (PhysicalAddress v) => ((object)v).ToString(),
                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        string (PhysicalAddress v) => ((object)v).ToString(),
                        PhysicalAddress (string v) => PhysicalAddress.Parse(v))));
            nullablePhysicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                "NullablePhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullablePhysicalAddressArray.SetGetter(
                PhysicalAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(instance) == null);
            nullablePhysicalAddressArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(instance) = value;
                    return instance;
                });
            nullablePhysicalAddressArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(instance) = value;
                    return instance;
                });
            nullablePhysicalAddressArray.SetAccessors(
                PhysicalAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress[] (IInternalEntry entry) => entry.ReadOriginalValue<PhysicalAddress[]>(nullablePhysicalAddressArray, 183),
                PhysicalAddress[] (IInternalEntry entry) => entry.GetCurrentValue<PhysicalAddress[]>(nullablePhysicalAddressArray));
            nullablePhysicalAddressArray.SetPropertyIndexes(
                index: 183,
                originalValueIndex: 183,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullablePhysicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            string (PhysicalAddress v) => ((object)v).ToString(),
                            PhysicalAddress (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            string (PhysicalAddress v) => ((object)v).ToString(),
                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
                        PhysicalAddress (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
                        PhysicalAddress (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        string (PhysicalAddress v) => ((object)v).ToString(),
                        PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            string (PhysicalAddress v) => ((object)v).ToString(),
                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
                nullable: true);
            nullablePhysicalAddressArrayElementType.TypeMapping = nullablePhysicalAddressArray.TypeMapping.ElementTypeMapping;
            nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableString = runtimeEntityType.AddProperty(
                "NullableString",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableString.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableString(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableString(instance) == null);
            nullableString.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.NullableString(instance) = value;
                    return instance;
                });
            nullableString.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.NullableString(instance) = value;
                    return instance;
                });
            nullableString.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(nullableString, 184),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(nullableString));
            nullableString.SetPropertyIndexes(
                index: 184,
                originalValueIndex: 184,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            nullableString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableStringArray = runtimeEntityType.AddProperty(
                "NullableStringArray",
                typeof(string[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableStringArray.SetGetter(
                string[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableStringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableStringArray(instance) == null);
            nullableStringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableStringArray(instance) = value;
                    return instance;
                });
            nullableStringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableStringArray(instance) = value;
                    return instance;
                });
            nullableStringArray.SetAccessors(
                string[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string[] (IInternalEntry entry) => entry.ReadOriginalValue<string[]>(nullableStringArray, 185),
                string[] (IInternalEntry entry) => entry.GetCurrentValue<string[]>(nullableStringArray));
            nullableStringArray.SetPropertyIndexes(
                index: 185,
                originalValueIndex: 185,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
                nullable: true);
            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
            nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnly = runtimeEntityType.AddProperty(
                "NullableTimeOnly",
                typeof(TimeOnly?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnly.SetGetter(
                TimeOnly? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeOnly(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableTimeOnly(instance).HasValue));
            nullableTimeOnly.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeOnly(instance) = value;
                    return instance;
                });
            nullableTimeOnly.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeOnly(instance) = value;
                    return instance;
                });
            nullableTimeOnly.SetAccessors(
                TimeOnly? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly? (IInternalEntry entry) => entry.ReadOriginalValue<TimeOnly?>(nullableTimeOnly, 186),
                TimeOnly? (IInternalEntry entry) => entry.GetCurrentValue<TimeOnly?>(nullableTimeOnly));
            nullableTimeOnly.SetPropertyIndexes(
                index: 186,
                originalValueIndex: 186,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableTimeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v));
            nullableTimeOnly.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnly.TypeMapping.Comparer));
            nullableTimeOnly.SetKeyComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnly.TypeMapping.KeyComparer));
            nullableTimeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                "NullableTimeOnlyArray",
                typeof(TimeOnly?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableTimeOnlyArray.SetGetter(
                TimeOnly? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(instance) == null);
            nullableTimeOnlyArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeOnlyArray(instance) = value;
                    return instance;
                });
            nullableTimeOnlyArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeOnlyArray(instance) = value;
                    return instance;
                });
            nullableTimeOnlyArray.SetAccessors(
                TimeOnly? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly? [] (IInternalEntry entry) => entry.ReadOriginalValue<TimeOnly? []>(nullableTimeOnlyArray, 187),
                TimeOnly? [] (IInternalEntry entry) => entry.GetCurrentValue<TimeOnly? []>(nullableTimeOnlyArray));
            nullableTimeOnlyArray.SetPropertyIndexes(
                index: 187,
                originalValueIndex: 187,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableTimeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<TimeOnly?[], TimeOnly>(new NullableValueComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<TimeOnly?[], TimeOnly>(new NullableValueComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonCollectionOfNullableStructsReaderWriter<TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        int (TimeOnly v) => ((object)v).GetHashCode(),
                        TimeOnly (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        int (TimeOnly v) => ((object)v).GetHashCode(),
                        TimeOnly (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        int (TimeOnly v) => ((object)v).GetHashCode(),
                        TimeOnly (TimeOnly v) => v)));
            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
                nullable: true);
            nullableTimeOnlyArrayElementType.TypeMapping = nullableTimeOnlyArray.TypeMapping.ElementTypeMapping;
            nullableTimeOnlyArrayElementType.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnlyArrayElementType.TypeMapping.Comparer));
            nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpan = runtimeEntityType.AddProperty(
                "NullableTimeSpan",
                typeof(TimeSpan?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpan.SetGetter(
                TimeSpan? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeSpan(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableTimeSpan(instance).HasValue));
            nullableTimeSpan.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeSpan(instance) = value;
                    return instance;
                });
            nullableTimeSpan.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeSpan(instance) = value;
                    return instance;
                });
            nullableTimeSpan.SetAccessors(
                TimeSpan? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan? (IInternalEntry entry) => entry.ReadOriginalValue<TimeSpan?>(nullableTimeSpan, 188),
                TimeSpan? (IInternalEntry entry) => entry.GetCurrentValue<TimeSpan?>(nullableTimeSpan));
            nullableTimeSpan.SetPropertyIndexes(
                index: 188,
                originalValueIndex: 188,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableTimeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v));
            nullableTimeSpan.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpan.TypeMapping.Comparer));
            nullableTimeSpan.SetKeyComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpan.TypeMapping.KeyComparer));
            nullableTimeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                "NullableTimeSpanArray",
                typeof(TimeSpan?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableTimeSpanArray.SetGetter(
                TimeSpan? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(instance) == null);
            nullableTimeSpanArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeSpanArray(instance) = value;
                    return instance;
                });
            nullableTimeSpanArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableTimeSpanArray(instance) = value;
                    return instance;
                });
            nullableTimeSpanArray.SetAccessors(
                TimeSpan? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan? [] (IInternalEntry entry) => entry.ReadOriginalValue<TimeSpan? []>(nullableTimeSpanArray, 189),
                TimeSpan? [] (IInternalEntry entry) => entry.GetCurrentValue<TimeSpan? []>(nullableTimeSpanArray));
            nullableTimeSpanArray.SetPropertyIndexes(
                index: 189,
                originalValueIndex: 189,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableTimeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<TimeSpan?[], TimeSpan>(new NullableValueComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<TimeSpan?[], TimeSpan>(new NullableValueComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonCollectionOfNullableStructsReaderWriter<TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        int (TimeSpan v) => ((object)v).GetHashCode(),
                        TimeSpan (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        int (TimeSpan v) => ((object)v).GetHashCode(),
                        TimeSpan (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        int (TimeSpan v) => ((object)v).GetHashCode(),
                        TimeSpan (TimeSpan v) => v)));
            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
                nullable: true);
            nullableTimeSpanArrayElementType.TypeMapping = nullableTimeSpanArray.TypeMapping.ElementTypeMapping;
            nullableTimeSpanArrayElementType.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpanArrayElementType.TypeMapping.Comparer));
            nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16 = runtimeEntityType.AddProperty(
                "NullableUInt16",
                typeof(ushort?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16.SetGetter(
                ushort? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt16(instance).HasValue));
            nullableUInt16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt16(instance) = value;
                    return instance;
                });
            nullableUInt16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt16(instance) = value;
                    return instance;
                });
            nullableUInt16.SetAccessors(
                ushort? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort? (IInternalEntry entry) => entry.ReadOriginalValue<ushort?>(nullableUInt16, 190),
                ushort? (IInternalEntry entry) => entry.GetCurrentValue<ushort?>(nullableUInt16));
            nullableUInt16.SetPropertyIndexes(
                index: 190,
                originalValueIndex: 190,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    int (ushort v) => ((int)(v)),
                    ushort (int v) => ((ushort)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        int (ushort v) => ((int)(v)),
                        ushort (int v) => ((ushort)(v)))));
            nullableUInt16.SetComparer(new NullableValueComparer<ushort>(nullableUInt16.TypeMapping.Comparer));
            nullableUInt16.SetKeyComparer(new NullableValueComparer<ushort>(nullableUInt16.TypeMapping.KeyComparer));
            nullableUInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16Array = runtimeEntityType.AddProperty(
                "NullableUInt16Array",
                typeof(ushort?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt16Array.SetGetter(
                ushort? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt16Array(instance) == null);
            nullableUInt16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt16Array(instance) = value;
                    return instance;
                });
            nullableUInt16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt16Array(instance) = value;
                    return instance;
                });
            nullableUInt16Array.SetAccessors(
                ushort? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort? [] (IInternalEntry entry) => entry.ReadOriginalValue<ushort? []>(nullableUInt16Array, 191),
                ushort? [] (IInternalEntry entry) => entry.GetCurrentValue<ushort? []>(nullableUInt16Array));
            nullableUInt16Array.SetPropertyIndexes(
                index: 191,
                originalValueIndex: 191,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<ushort?[], ushort>(new NullableValueComparer<ushort>(new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<ushort?[], ushort>(new NullableValueComparer<ushort>(new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort?>(new JsonCollectionOfNullableStructsReaderWriter<ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            int (ushort v) => ((int)(v)),
                            ushort (int v) => ((ushort)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            int (ushort v) => ((int)(v)),
                            ushort (int v) => ((ushort)(v))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        bool (ushort v1, ushort v2) => v1 == v2,
                        int (ushort v) => ((int)(v)),
                        ushort (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        bool (ushort v1, ushort v2) => v1 == v2,
                        int (ushort v) => ((int)(v)),
                        ushort (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        int (ushort v) => ((int)(v)),
                        ushort (int v) => ((ushort)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            int (ushort v) => ((int)(v)),
                            ushort (int v) => ((ushort)(v))))));
            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
                nullable: true);
            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
            nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32 = runtimeEntityType.AddProperty(
                "NullableUInt32",
                typeof(uint?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32.SetGetter(
                uint? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt32(instance).HasValue));
            nullableUInt32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt32(instance) = value;
                    return instance;
                });
            nullableUInt32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt32(instance) = value;
                    return instance;
                });
            nullableUInt32.SetAccessors(
                uint? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint? (IInternalEntry entry) => entry.ReadOriginalValue<uint?>(nullableUInt32, 192),
                uint? (IInternalEntry entry) => entry.GetCurrentValue<uint?>(nullableUInt32));
            nullableUInt32.SetPropertyIndexes(
                index: 192,
                originalValueIndex: 192,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<uint, long>(
                    long (uint v) => ((long)(v)),
                    uint (long v) => ((uint)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        long (uint v) => ((long)(v)),
                        uint (long v) => ((uint)(v)))));
            nullableUInt32.SetComparer(new NullableValueComparer<uint>(nullableUInt32.TypeMapping.Comparer));
            nullableUInt32.SetKeyComparer(new NullableValueComparer<uint>(nullableUInt32.TypeMapping.KeyComparer));
            nullableUInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32Array = runtimeEntityType.AddProperty(
                "NullableUInt32Array",
                typeof(uint?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt32Array.SetGetter(
                uint? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt32Array(instance) == null);
            nullableUInt32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt32Array(instance) = value;
                    return instance;
                });
            nullableUInt32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt32Array(instance) = value;
                    return instance;
                });
            nullableUInt32Array.SetAccessors(
                uint? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint? [] (IInternalEntry entry) => entry.ReadOriginalValue<uint? []>(nullableUInt32Array, 193),
                uint? [] (IInternalEntry entry) => entry.GetCurrentValue<uint? []>(nullableUInt32Array));
            nullableUInt32Array.SetPropertyIndexes(
                index: 193,
                originalValueIndex: 193,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<uint?[], uint>(new NullableValueComparer<uint>(new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<uint?[], uint>(new NullableValueComparer<uint>(new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint?>(new JsonCollectionOfNullableStructsReaderWriter<uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            long (uint v) => ((long)(v)),
                            uint (long v) => ((uint)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            long (uint v) => ((long)(v)),
                            uint (long v) => ((uint)(v))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        bool (uint v1, uint v2) => v1 == v2,
                        int (uint v) => ((int)(v)),
                        uint (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        bool (uint v1, uint v2) => v1 == v2,
                        int (uint v) => ((int)(v)),
                        uint (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        long (uint v) => ((long)(v)),
                        uint (long v) => ((uint)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            long (uint v) => ((long)(v)),
                            uint (long v) => ((uint)(v))))));
            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
                nullable: true);
            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
            nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64 = runtimeEntityType.AddProperty(
                "NullableUInt64",
                typeof(ulong?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64.SetGetter(
                ulong? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt64(instance).HasValue));
            nullableUInt64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt64(instance) = value;
                    return instance;
                });
            nullableUInt64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt64(instance) = value;
                    return instance;
                });
            nullableUInt64.SetAccessors(
                ulong? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong? (IInternalEntry entry) => entry.ReadOriginalValue<ulong?>(nullableUInt64, 194),
                ulong? (IInternalEntry entry) => entry.GetCurrentValue<ulong?>(nullableUInt64));
            nullableUInt64.SetPropertyIndexes(
                index: 194,
                originalValueIndex: 194,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    decimal (ulong v) => ((decimal)(v)),
                    ulong (decimal v) => ((ulong)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v)))));
            nullableUInt64.SetComparer(new NullableValueComparer<ulong>(nullableUInt64.TypeMapping.Comparer));
            nullableUInt64.SetKeyComparer(new NullableValueComparer<ulong>(nullableUInt64.TypeMapping.KeyComparer));
            nullableUInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64Array = runtimeEntityType.AddProperty(
                "NullableUInt64Array",
                typeof(ulong?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt64Array.SetGetter(
                ulong? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt64Array(instance) == null);
            nullableUInt64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt64Array(instance) = value;
                    return instance;
                });
            nullableUInt64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt64Array(instance) = value;
                    return instance;
                });
            nullableUInt64Array.SetAccessors(
                ulong? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong? [] (IInternalEntry entry) => entry.ReadOriginalValue<ulong? []>(nullableUInt64Array, 195),
                ulong? [] (IInternalEntry entry) => entry.GetCurrentValue<ulong? []>(nullableUInt64Array));
            nullableUInt64Array.SetPropertyIndexes(
                index: 195,
                originalValueIndex: 195,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<ulong?[], ulong>(new NullableValueComparer<ulong>(new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<ulong?[], ulong>(new NullableValueComparer<ulong>(new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong?>(new JsonCollectionOfNullableStructsReaderWriter<ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            decimal (ulong v) => ((decimal)(v)),
                            ulong (decimal v) => ((ulong)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            decimal (ulong v) => ((decimal)(v)),
                            ulong (decimal v) => ((ulong)(v))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        bool (ulong v1, ulong v2) => v1 == v2,
                        int (ulong v) => ((object)v).GetHashCode(),
                        ulong (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        bool (ulong v1, ulong v2) => v1 == v2,
                        int (ulong v) => ((object)v).GetHashCode(),
                        ulong (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            decimal (ulong v) => ((decimal)(v)),
                            ulong (decimal v) => ((ulong)(v))))));
            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
                nullable: true);
            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
            nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8 = runtimeEntityType.AddProperty(
                "NullableUInt8",
                typeof(byte?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8.SetGetter(
                byte? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt8(instance).HasValue));
            nullableUInt8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt8(instance) = value;
                    return instance;
                });
            nullableUInt8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte? value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt8(instance) = value;
                    return instance;
                });
            nullableUInt8.SetAccessors(
                byte? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte? (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte? (IInternalEntry entry) => entry.ReadOriginalValue<byte?>(nullableUInt8, 196),
                byte? (IInternalEntry entry) => entry.GetCurrentValue<byte?>(nullableUInt8));
            nullableUInt8.SetPropertyIndexes(
                index: 196,
                originalValueIndex: 196,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v));
            nullableUInt8.SetComparer(new NullableValueComparer<byte>(nullableUInt8.TypeMapping.Comparer));
            nullableUInt8.SetKeyComparer(new NullableValueComparer<byte>(nullableUInt8.TypeMapping.KeyComparer));
            nullableUInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8Array = runtimeEntityType.AddProperty(
                "NullableUInt8Array",
                typeof(byte?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt8Array.SetGetter(
                byte? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8Array(instance) == null);
            nullableUInt8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt8Array(instance) = value;
                    return instance;
                });
            nullableUInt8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte? [] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUInt8Array(instance) = value;
                    return instance;
                });
            nullableUInt8Array.SetAccessors(
                byte? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte? [] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte? [] (IInternalEntry entry) => entry.ReadOriginalValue<byte? []>(nullableUInt8Array, 197),
                byte? [] (IInternalEntry entry) => entry.GetCurrentValue<byte? []>(nullableUInt8Array));
            nullableUInt8Array.SetPropertyIndexes(
                index: 197,
                originalValueIndex: 197,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v))),
                keyComparer: new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v))),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte?>(new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v)));
            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
                nullable: true);
            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
            nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUri = runtimeEntityType.AddProperty(
                "NullableUri",
                typeof(Uri),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUri.SetGetter(
                Uri (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUri(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUri(instance) == null);
            nullableUri.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUri(instance) = value;
                    return instance;
                });
            nullableUri.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUri(instance) = value;
                    return instance;
                });
            nullableUri.SetAccessors(
                Uri (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri (IInternalEntry entry) => entry.ReadOriginalValue<Uri>(nullableUri, 198),
                Uri (IInternalEntry entry) => entry.GetCurrentValue<Uri>(nullableUri));
            nullableUri.SetPropertyIndexes(
                index: 198,
                originalValueIndex: 198,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    string (Uri v) => ((object)v).ToString(),
                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            nullableUri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUriArray = runtimeEntityType.AddProperty(
                "NullableUriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUriArray.SetGetter(
                Uri[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUriArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUriArray(instance) == null);
            nullableUriArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUriArray(instance) = value;
                    return instance;
                });
            nullableUriArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri[] value) =>
                {
                    ManyTypesUnsafeAccessors.NullableUriArray(instance) = value;
                    return instance;
                });
            nullableUriArray.SetAccessors(
                Uri[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.NullableUriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri[] (IInternalEntry entry) => entry.ReadOriginalValue<Uri[]>(nullableUriArray, 199),
                Uri[] (IInternalEntry entry) => entry.GetCurrentValue<Uri[]>(nullableUriArray));
            nullableUriArray.SetPropertyIndexes(
                index: 199,
                originalValueIndex: 199,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            nullableUriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            string (Uri v) => ((object)v).ToString(),
                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            string (Uri v) => ((object)v).ToString(),
                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (Uri v) => ((object)v).GetHashCode(),
                        Uri (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (Uri v) => ((object)v).GetHashCode(),
                        Uri (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            string (Uri v) => ((object)v).ToString(),
                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
                nullable: true);
            nullableUriArrayElementType.TypeMapping = nullableUriArray.TypeMapping.ElementTypeMapping;
            nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddress = runtimeEntityType.AddProperty(
                "PhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            physicalAddress.SetGetter(
                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddress(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddress(instance) == null);
            physicalAddress.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddress(instance) = value;
                    return instance;
                });
            physicalAddress.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddress(instance) = value;
                    return instance;
                });
            physicalAddress.SetAccessors(
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(physicalAddress, 200),
                PhysicalAddress (IInternalEntry entry) => entry.GetCurrentValue<PhysicalAddress>(physicalAddress));
            physicalAddress.SetPropertyIndexes(
                index: 200,
                originalValueIndex: 200,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            physicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    string (PhysicalAddress v) => ((object)v).ToString(),
                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        string (PhysicalAddress v) => ((object)v).ToString(),
                        PhysicalAddress (string v) => PhysicalAddress.Parse(v))));
            physicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressArray = runtimeEntityType.AddProperty(
                "PhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            physicalAddressArray.SetGetter(
                PhysicalAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressArray(instance) == null);
            physicalAddressArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddressArray(instance) = value;
                    return instance;
                });
            physicalAddressArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress[] value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddressArray(instance) = value;
                    return instance;
                });
            physicalAddressArray.SetAccessors(
                PhysicalAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress[] (IInternalEntry entry) => entry.ReadOriginalValue<PhysicalAddress[]>(physicalAddressArray, 201),
                PhysicalAddress[] (IInternalEntry entry) => entry.GetCurrentValue<PhysicalAddress[]>(physicalAddressArray));
            physicalAddressArray.SetPropertyIndexes(
                index: 201,
                originalValueIndex: 201,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            physicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            string (PhysicalAddress v) => ((object)v).ToString(),
                            PhysicalAddress (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            string (PhysicalAddress v) => ((object)v).ToString(),
                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
                        PhysicalAddress (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
                        PhysicalAddress (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        string (PhysicalAddress v) => ((object)v).ToString(),
                        PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            string (PhysicalAddress v) => ((object)v).ToString(),
                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
            physicalAddressArrayElementType.TypeMapping = physicalAddressArray.TypeMapping.ElementTypeMapping;
            physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                "PhysicalAddressToBytesConverterProperty",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new PhysicalAddressToBytesConverter());
            physicalAddressToBytesConverterProperty.SetGetter(
                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(instance) == null);
            physicalAddressToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(instance) = value;
                    return instance;
                });
            physicalAddressToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(instance) = value;
                    return instance;
                });
            physicalAddressToBytesConverterProperty.SetAccessors(
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(physicalAddressToBytesConverterProperty, 202),
                PhysicalAddress (IInternalEntry entry) => entry.GetCurrentValue<PhysicalAddress>(physicalAddressToBytesConverterProperty));
            physicalAddressToBytesConverterProperty.SetPropertyIndexes(
                index: 202,
                originalValueIndex: 202,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            physicalAddressToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(8)",
                    size: 8),
                converter: new ValueConverter<PhysicalAddress, byte[]>(
                    byte[] (PhysicalAddress v) => v.GetAddressBytes(),
                    PhysicalAddress (byte[] v) => new PhysicalAddress(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, byte[]>(
                        byte[] (PhysicalAddress v) => v.GetAddressBytes(),
                        PhysicalAddress (byte[] v) => new PhysicalAddress(v))));
            physicalAddressToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                "PhysicalAddressToStringConverterProperty",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new PhysicalAddressToStringConverter());
            physicalAddressToStringConverterProperty.SetGetter(
                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(instance) == null);
            physicalAddressToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(instance) = value;
                    return instance;
                });
            physicalAddressToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, PhysicalAddress value) =>
                {
                    ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(instance) = value;
                    return instance;
                });
            physicalAddressToStringConverterProperty.SetAccessors(
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                PhysicalAddress (IInternalEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(physicalAddressToStringConverterProperty, 203),
                PhysicalAddress (IInternalEntry entry) => entry.GetCurrentValue<PhysicalAddress>(physicalAddressToStringConverterProperty));
            physicalAddressToStringConverterProperty.SetPropertyIndexes(
                index: 203,
                originalValueIndex: 203,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            physicalAddressToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
                    PhysicalAddress (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    string (PhysicalAddress v) => ((object)v).ToString(),
                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        string (PhysicalAddress v) => ((object)v).ToString(),
                        PhysicalAddress (string v) => PhysicalAddress.Parse(v))));
            physicalAddressToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @string = runtimeEntityType.AddProperty(
                "String",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            @string.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.String(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.String(instance) == null);
            @string.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.String(instance) = value;
                    return instance;
                });
            @string.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.String(instance) = value;
                    return instance;
                });
            @string.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.String(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.String(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(@string, 204),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(@string));
            @string.SetPropertyIndexes(
                index: 204,
                originalValueIndex: 204,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            @string.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            @string.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringArray = runtimeEntityType.AddProperty(
                "StringArray",
                typeof(string[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            stringArray.SetGetter(
                string[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringArray(instance) == null);
            stringArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string[] value) =>
                {
                    ManyTypesUnsafeAccessors.StringArray(instance) = value;
                    return instance;
                });
            stringArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string[] value) =>
                {
                    ManyTypesUnsafeAccessors.StringArray(instance) = value;
                    return instance;
                });
            stringArray.SetAccessors(
                string[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string[] (IInternalEntry entry) => entry.ReadOriginalValue<string[]>(stringArray, 205),
                string[] (IInternalEntry entry) => entry.GetCurrentValue<string[]>(stringArray));
            stringArray.SetPropertyIndexes(
                index: 205,
                originalValueIndex: 205,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            var stringArrayElementType = stringArray.SetElementType(typeof(string));
            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
            stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                "StringReadOnlyCollection",
                typeof(IReadOnlyCollection<string>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_stringReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            stringReadOnlyCollection.SetGetter(
                IReadOnlyCollection<string> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance)))),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance) == null);
            stringReadOnlyCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<string> value) =>
                {
                    ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance) = ((List<string>)(value));
                    return instance;
                });
            stringReadOnlyCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<string> value) =>
                {
                    ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance) = ((List<string>)(value));
                    return instance;
                });
            stringReadOnlyCollection.SetAccessors(
                IReadOnlyCollection<string> (IInternalEntry entry) => ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<string> (IInternalEntry entry) => ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<string> (IInternalEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<string>>(stringReadOnlyCollection, 206),
                IReadOnlyCollection<string> (IInternalEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<string>>(stringReadOnlyCollection));
            stringReadOnlyCollection.SetPropertyIndexes(
                index: 206,
                originalValueIndex: 206,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringReadOnlyCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
            stringReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                "StringToBoolConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToBoolConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToBoolConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToBoolConverter());
            stringToBoolConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(instance) == null);
            stringToBoolConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToBoolConverterProperty(instance) = value;
                    return instance;
                });
            stringToBoolConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToBoolConverterProperty(instance) = value;
                    return instance;
                });
            stringToBoolConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToBoolConverterProperty, 207),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToBoolConverterProperty));
            stringToBoolConverterProperty.SetPropertyIndexes(
                index: 207,
                originalValueIndex: 207,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToBoolConverterProperty.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                converter: new ValueConverter<string, bool>(
                    bool (string v) => Convert.ToBoolean(v),
                    string (bool v) => Convert.ToString(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, bool>(
                    JsonBoolReaderWriter.Instance,
                    new ValueConverter<string, bool>(
                        bool (string v) => Convert.ToBoolean(v),
                        string (bool v) => Convert.ToString(v))));
            stringToBoolConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToBytesConverterProperty = runtimeEntityType.AddProperty(
                "StringToBytesConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringToBytesConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(instance) == null);
            stringToBytesConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToBytesConverterProperty(instance) = value;
                    return instance;
                });
            stringToBytesConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToBytesConverterProperty(instance) = value;
                    return instance;
                });
            stringToBytesConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToBytesConverterProperty, 208),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToBytesConverterProperty));
            stringToBytesConverterProperty.SetPropertyIndexes(
                index: 208,
                originalValueIndex: 208,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                converter: new ValueConverter<string, byte[]>(
                    byte[] (string v) => Encoding.GetEncoding(12000).GetBytes(v),
                    string (byte[] v) => Encoding.GetEncoding(12000).GetString(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<string, byte[]>(
                        byte[] (string v) => Encoding.GetEncoding(12000).GetBytes(v),
                        string (byte[] v) => Encoding.GetEncoding(12000).GetString(v))));
            stringToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToCharConverterProperty = runtimeEntityType.AddProperty(
                "StringToCharConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToCharConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToCharConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToCharConverter());
            stringToCharConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(instance) == null);
            stringToCharConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToCharConverterProperty(instance) = value;
                    return instance;
                });
            stringToCharConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToCharConverterProperty(instance) = value;
                    return instance;
                });
            stringToCharConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToCharConverterProperty, 209),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToCharConverterProperty));
            stringToCharConverterProperty.SetPropertyIndexes(
                index: 209,
                originalValueIndex: 209,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToCharConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<string, string>(
                    string (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)((v.Length < 1 ? '\0' : v[0])))),
                    string (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)((v.Length < 1 ? '\0' : v[0]))))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<string, string>(
                        string (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)((v.Length < 1 ? '\0' : v[0])))),
                        string (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)((v.Length < 1 ? '\0' : v[0])))))));
            stringToCharConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDateOnlyConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateOnlyConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToDateOnlyConverter());
            stringToDateOnlyConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(instance) == null);
            stringToDateOnlyConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(instance) = value;
                    return instance;
                });
            stringToDateOnlyConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(instance) = value;
                    return instance;
                });
            stringToDateOnlyConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToDateOnlyConverterProperty, 210),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToDateOnlyConverterProperty));
            stringToDateOnlyConverterProperty.SetPropertyIndexes(
                index: 210,
                originalValueIndex: 210,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToDateOnlyConverterProperty.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    int (DateOnly v) => ((object)v).GetHashCode(),
                    DateOnly (DateOnly v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 10),
                converter: new ValueConverter<string, DateOnly>(
                    DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                    string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateOnly>(
                    JsonDateOnlyReaderWriter.Instance,
                    new ValueConverter<string, DateOnly>(
                        DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                        string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"))));
            stringToDateOnlyConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDateTimeConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateTimeConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateTimeConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateTimeConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToDateTimeConverter());
            stringToDateTimeConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(instance) == null);
            stringToDateTimeConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(instance) = value;
                    return instance;
                });
            stringToDateTimeConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(instance) = value;
                    return instance;
                });
            stringToDateTimeConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToDateTimeConverterProperty, 211),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToDateTimeConverterProperty));
            stringToDateTimeConverterProperty.SetPropertyIndexes(
                index: 211,
                originalValueIndex: 211,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToDateTimeConverterProperty.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                    int (DateTime v) => ((object)v).GetHashCode(),
                    DateTime (DateTime v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, DateTime>(
                    DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
                    string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTime>(
                    JsonDateTimeReaderWriter.Instance,
                    new ValueConverter<string, DateTime>(
                        DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
                        string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"))));
            stringToDateTimeConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDateTimeOffsetConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateTimeOffsetConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateTimeOffsetConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateTimeOffsetConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToDateTimeOffsetConverter());
            stringToDateTimeOffsetConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(instance) == null);
            stringToDateTimeOffsetConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(instance) = value;
                    return instance;
                });
            stringToDateTimeOffsetConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(instance) = value;
                    return instance;
                });
            stringToDateTimeOffsetConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToDateTimeOffsetConverterProperty, 212),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToDateTimeOffsetConverterProperty));
            stringToDateTimeOffsetConverterProperty.SetPropertyIndexes(
                index: 212,
                originalValueIndex: 212,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToDateTimeOffsetConverterProperty.TypeMapping = SqlServerDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, DateTimeOffset>(
                    DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
                    string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTimeOffset>(
                    JsonDateTimeOffsetReaderWriter.Instance,
                    new ValueConverter<string, DateTimeOffset>(
                        DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
                        string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"))));
            stringToDateTimeOffsetConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDecimalNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToDecimalNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDecimalNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDecimalNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToNumberConverter<decimal>());
            stringToDecimalNumberConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(instance) == null);
            stringToDecimalNumberConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(instance) = value;
                    return instance;
                });
            stringToDecimalNumberConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(instance) = value;
                    return instance;
                });
            stringToDecimalNumberConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToDecimalNumberConverterProperty, 213),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToDecimalNumberConverterProperty));
            stringToDecimalNumberConverterProperty.SetPropertyIndexes(
                index: 213,
                originalValueIndex: 213,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToDecimalNumberConverterProperty.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, decimal>(
                    decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v)))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<string, decimal>(
                        decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))))));
            stringToDecimalNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDoubleNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToDoubleNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDoubleNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDoubleNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToNumberConverter<double>());
            stringToDoubleNumberConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(instance) == null);
            stringToDoubleNumberConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(instance) = value;
                    return instance;
                });
            stringToDoubleNumberConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(instance) = value;
                    return instance;
                });
            stringToDoubleNumberConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToDoubleNumberConverterProperty, 214),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToDoubleNumberConverterProperty));
            stringToDoubleNumberConverterProperty.SetPropertyIndexes(
                index: 214,
                originalValueIndex: 214,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToDoubleNumberConverterProperty.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<double>(
                    bool (double v1, double v2) => v1.Equals(v2),
                    int (double v) => ((object)v).GetHashCode(),
                    double (double v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, double>(
                    double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v)))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, double>(
                    JsonDoubleReaderWriter.Instance,
                    new ValueConverter<string, double>(
                        double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v))))));
            stringToDoubleNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToEnumConverterProperty = runtimeEntityType.AddProperty(
                "StringToEnumConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToEnumConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToEnumConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToEnumConverter<CompiledModelTestBase.EnumU32>());
            stringToEnumConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(instance) == null);
            stringToEnumConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToEnumConverterProperty(instance) = value;
                    return instance;
                });
            stringToEnumConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToEnumConverterProperty(instance) = value;
                    return instance;
                });
            stringToEnumConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToEnumConverterProperty, 215),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToEnumConverterProperty));
            stringToEnumConverterProperty.SetPropertyIndexes(
                index: 215,
                originalValueIndex: 215,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToEnumConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<string, long>(
                    long (string v) => ((long)(StringEnumConverter<string, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))),
                    string (long value) => ((object)((CompiledModelTestBase.EnumU32)(value))).ToString()),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<string, long>(
                        long (string v) => ((long)(StringEnumConverter<string, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))),
                        string (long value) => ((object)((CompiledModelTestBase.EnumU32)(value))).ToString())));
            stringToEnumConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToGuidConverterProperty = runtimeEntityType.AddProperty(
                "StringToGuidConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToGuidConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToGuidConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            stringToGuidConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(instance) == null);
            stringToGuidConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToGuidConverterProperty(instance) = value;
                    return instance;
                });
            stringToGuidConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToGuidConverterProperty(instance) = value;
                    return instance;
                });
            stringToGuidConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToGuidConverterProperty, 216),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToGuidConverterProperty));
            stringToGuidConverterProperty.SetPropertyIndexes(
                index: 216,
                originalValueIndex: 216,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToGuidConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            stringToGuidConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToIntNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToIntNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToIntNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToIntNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToNumberConverter<int>());
            stringToIntNumberConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(instance) == null);
            stringToIntNumberConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(instance) = value;
                    return instance;
                });
            stringToIntNumberConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(instance) = value;
                    return instance;
                });
            stringToIntNumberConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToIntNumberConverterProperty, 217),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToIntNumberConverterProperty));
            stringToIntNumberConverterProperty.SetPropertyIndexes(
                index: 217,
                originalValueIndex: 217,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToIntNumberConverterProperty.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, int>(
                    int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v)))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<string, int>(
                        int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))))));
            stringToIntNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToTimeOnlyConverterProperty = runtimeEntityType.AddProperty(
                "StringToTimeOnlyConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToTimeOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToTimeOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToTimeOnlyConverter());
            stringToTimeOnlyConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(instance) == null);
            stringToTimeOnlyConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(instance) = value;
                    return instance;
                });
            stringToTimeOnlyConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(instance) = value;
                    return instance;
                });
            stringToTimeOnlyConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToTimeOnlyConverterProperty, 218),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToTimeOnlyConverterProperty));
            stringToTimeOnlyConverterProperty.SetPropertyIndexes(
                index: 218,
                originalValueIndex: 218,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToTimeOnlyConverterProperty.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, TimeOnly>(
                    TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                    string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o"))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance,
                    new ValueConverter<string, TimeOnly>(
                        TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                        string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o")))));
            stringToTimeOnlyConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToTimeSpanConverterProperty = runtimeEntityType.AddProperty(
                "StringToTimeSpanConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToTimeSpanConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToTimeSpanConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToTimeSpanConverter());
            stringToTimeSpanConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(instance) == null);
            stringToTimeSpanConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(instance) = value;
                    return instance;
                });
            stringToTimeSpanConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(instance) = value;
                    return instance;
                });
            stringToTimeSpanConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToTimeSpanConverterProperty, 219),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToTimeSpanConverterProperty));
            stringToTimeSpanConverterProperty.SetPropertyIndexes(
                index: 219,
                originalValueIndex: 219,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToTimeSpanConverterProperty.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, TimeSpan>(
                    TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
                    string (TimeSpan v) => v.ToString("c")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance,
                    new ValueConverter<string, TimeSpan>(
                        TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
                        string (TimeSpan v) => v.ToString("c"))));
            stringToTimeSpanConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToUriConverterProperty = runtimeEntityType.AddProperty(
                "StringToUriConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToUriConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToUriConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToUriConverter());
            stringToUriConverterProperty.SetGetter(
                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(instance) == null);
            stringToUriConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToUriConverterProperty(instance) = value;
                    return instance;
                });
            stringToUriConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, string value) =>
                {
                    ManyTypesUnsafeAccessors.StringToUriConverterProperty(instance) = value;
                    return instance;
                });
            stringToUriConverterProperty.SetAccessors(
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(stringToUriConverterProperty, 220),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(stringToUriConverterProperty));
            stringToUriConverterProperty.SetPropertyIndexes(
                index: 220,
                originalValueIndex: 220,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            stringToUriConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<string, string>(
                    string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString(),
                    string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString()),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<string, string>(
                        string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString(),
                        string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString())));
            stringToUriConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnly = runtimeEntityType.AddProperty(
                "TimeOnly",
                typeof(TimeOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeOnly(0, 0, 0));
            timeOnly.SetGetter(
                TimeOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnly(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnly(instance) == default(TimeOnly));
            timeOnly.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnly(instance) = value;
                    return instance;
                });
            timeOnly.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnly(instance) = value;
                    return instance;
                });
            timeOnly.SetAccessors(
                TimeOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly (IInternalEntry entry) => entry.ReadOriginalValue<TimeOnly>(timeOnly, 221),
                TimeOnly (IInternalEntry entry) => entry.GetCurrentValue<TimeOnly>(timeOnly));
            timeOnly.SetPropertyIndexes(
                index: 221,
                originalValueIndex: 221,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v));
            timeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyArray = runtimeEntityType.AddProperty(
                "TimeOnlyArray",
                typeof(TimeOnly[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            timeOnlyArray.SetGetter(
                TimeOnly[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyArray(instance) == null);
            timeOnlyArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly[] value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnlyArray(instance) = value;
                    return instance;
                });
            timeOnlyArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly[] value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnlyArray(instance) = value;
                    return instance;
                });
            timeOnlyArray.SetAccessors(
                TimeOnly[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly[] (IInternalEntry entry) => entry.ReadOriginalValue<TimeOnly[]>(timeOnlyArray, 222),
                TimeOnly[] (IInternalEntry entry) => entry.GetCurrentValue<TimeOnly[]>(timeOnlyArray));
            timeOnlyArray.SetPropertyIndexes(
                index: 222,
                originalValueIndex: 222,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<TimeOnly[], TimeOnly>(new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v)),
                keyComparer: new ListOfValueTypesComparer<TimeOnly[], TimeOnly>(new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionOfStructsReaderWriter<TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        int (TimeOnly v) => ((object)v).GetHashCode(),
                        TimeOnly (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        int (TimeOnly v) => ((object)v).GetHashCode(),
                        TimeOnly (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        int (TimeOnly v) => ((object)v).GetHashCode(),
                        TimeOnly (TimeOnly v) => v)));
            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
            timeOnlyArrayElementType.TypeMapping = timeOnlyArray.TypeMapping.ElementTypeMapping;
            timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                "TimeOnlyToStringConverterProperty",
                typeof(TimeOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeOnlyToStringConverter());
            timeOnlyToStringConverterProperty.SetGetter(
                TimeOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(instance) == default(TimeOnly));
            timeOnlyToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(instance) = value;
                    return instance;
                });
            timeOnlyToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(instance) = value;
                    return instance;
                });
            timeOnlyToStringConverterProperty.SetAccessors(
                TimeOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly (IInternalEntry entry) => entry.ReadOriginalValue<TimeOnly>(timeOnlyToStringConverterProperty, 223),
                TimeOnly (IInternalEntry entry) => entry.GetCurrentValue<TimeOnly>(timeOnlyToStringConverterProperty));
            timeOnlyToStringConverterProperty.SetPropertyIndexes(
                index: 223,
                originalValueIndex: 223,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeOnlyToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<TimeOnly, string>(
                    string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o")),
                    TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<TimeOnly, string>(
                        string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o")),
                        TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
            timeOnlyToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");
            timeOnlyToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyToTicksConverterProperty = runtimeEntityType.AddProperty(
                "TimeOnlyToTicksConverterProperty",
                typeof(TimeOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeOnlyToTicksConverter());
            timeOnlyToTicksConverterProperty.SetGetter(
                TimeOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(instance) == default(TimeOnly));
            timeOnlyToTicksConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(instance) = value;
                    return instance;
                });
            timeOnlyToTicksConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeOnly value) =>
                {
                    ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(instance) = value;
                    return instance;
                });
            timeOnlyToTicksConverterProperty.SetAccessors(
                TimeOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeOnly (IInternalEntry entry) => entry.ReadOriginalValue<TimeOnly>(timeOnlyToTicksConverterProperty, 224),
                TimeOnly (IInternalEntry entry) => entry.GetCurrentValue<TimeOnly>(timeOnlyToTicksConverterProperty));
            timeOnlyToTicksConverterProperty.SetPropertyIndexes(
                index: 224,
                originalValueIndex: 224,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeOnlyToTicksConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    int (TimeOnly v) => ((object)v).GetHashCode(),
                    TimeOnly (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<TimeOnly, long>(
                    long (TimeOnly v) => v.Ticks,
                    TimeOnly (long v) => new TimeOnly(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<TimeOnly, long>(
                        long (TimeOnly v) => v.Ticks,
                        TimeOnly (long v) => new TimeOnly(v))));
            timeOnlyToTicksConverterProperty.SetSentinelFromProviderValue(0L);
            timeOnlyToTicksConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpan = runtimeEntityType.AddProperty(
                "TimeSpan",
                typeof(TimeSpan),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeSpan(0, 0, 0, 0, 0));
            timeSpan.SetGetter(
                TimeSpan (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpan(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpan(instance) == default(TimeSpan));
            timeSpan.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpan(instance) = value;
                    return instance;
                });
            timeSpan.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpan(instance) = value;
                    return instance;
                });
            timeSpan.SetAccessors(
                TimeSpan (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan (IInternalEntry entry) => entry.ReadOriginalValue<TimeSpan>(timeSpan, 225),
                TimeSpan (IInternalEntry entry) => entry.GetCurrentValue<TimeSpan>(timeSpan));
            timeSpan.SetPropertyIndexes(
                index: 225,
                originalValueIndex: 225,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v));
            timeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanArray = runtimeEntityType.AddProperty(
                "TimeSpanArray",
                typeof(TimeSpan[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            timeSpanArray.SetGetter(
                TimeSpan[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanArray(instance) == null);
            timeSpanArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan[] value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpanArray(instance) = value;
                    return instance;
                });
            timeSpanArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan[] value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpanArray(instance) = value;
                    return instance;
                });
            timeSpanArray.SetAccessors(
                TimeSpan[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan[] (IInternalEntry entry) => entry.ReadOriginalValue<TimeSpan[]>(timeSpanArray, 226),
                TimeSpan[] (IInternalEntry entry) => entry.GetCurrentValue<TimeSpan[]>(timeSpanArray));
            timeSpanArray.SetPropertyIndexes(
                index: 226,
                originalValueIndex: 226,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<TimeSpan[], TimeSpan>(new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v)),
                keyComparer: new ListOfValueTypesComparer<TimeSpan[], TimeSpan>(new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionOfStructsReaderWriter<TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        int (TimeSpan v) => ((object)v).GetHashCode(),
                        TimeSpan (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        int (TimeSpan v) => ((object)v).GetHashCode(),
                        TimeSpan (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        int (TimeSpan v) => ((object)v).GetHashCode(),
                        TimeSpan (TimeSpan v) => v)));
            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
            timeSpanArrayElementType.TypeMapping = timeSpanArray.TypeMapping.ElementTypeMapping;
            timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                "TimeSpanToStringConverterProperty",
                typeof(TimeSpan),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeSpanToStringConverter());
            timeSpanToStringConverterProperty.SetGetter(
                TimeSpan (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(instance) == default(TimeSpan));
            timeSpanToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(instance) = value;
                    return instance;
                });
            timeSpanToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(instance) = value;
                    return instance;
                });
            timeSpanToStringConverterProperty.SetAccessors(
                TimeSpan (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan (IInternalEntry entry) => entry.ReadOriginalValue<TimeSpan>(timeSpanToStringConverterProperty, 227),
                TimeSpan (IInternalEntry entry) => entry.GetCurrentValue<TimeSpan>(timeSpanToStringConverterProperty));
            timeSpanToStringConverterProperty.SetPropertyIndexes(
                index: 227,
                originalValueIndex: 227,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeSpanToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<TimeSpan, string>(
                    string (TimeSpan v) => v.ToString("c"),
                    TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<TimeSpan, string>(
                        string (TimeSpan v) => v.ToString("c"),
                        TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture))));
            timeSpanToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");
            timeSpanToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanToTicksConverterProperty = runtimeEntityType.AddProperty(
                "TimeSpanToTicksConverterProperty",
                typeof(TimeSpan),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeSpanToTicksConverter());
            timeSpanToTicksConverterProperty.SetGetter(
                TimeSpan (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(instance) == default(TimeSpan));
            timeSpanToTicksConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(instance) = value;
                    return instance;
                });
            timeSpanToTicksConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, TimeSpan value) =>
                {
                    ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(instance) = value;
                    return instance;
                });
            timeSpanToTicksConverterProperty.SetAccessors(
                TimeSpan (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan (IInternalEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                TimeSpan (IInternalEntry entry) => entry.ReadOriginalValue<TimeSpan>(timeSpanToTicksConverterProperty, 228),
                TimeSpan (IInternalEntry entry) => entry.GetCurrentValue<TimeSpan>(timeSpanToTicksConverterProperty));
            timeSpanToTicksConverterProperty.SetPropertyIndexes(
                index: 228,
                originalValueIndex: 228,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            timeSpanToTicksConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    int (TimeSpan v) => ((object)v).GetHashCode(),
                    TimeSpan (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<TimeSpan, long>(
                    long (TimeSpan v) => v.Ticks,
                    TimeSpan (long v) => new TimeSpan(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<TimeSpan, long>(
                        long (TimeSpan v) => v.Ticks,
                        TimeSpan (long v) => new TimeSpan(v))));
            timeSpanToTicksConverterProperty.SetSentinelFromProviderValue(0L);
            timeSpanToTicksConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16 = runtimeEntityType.AddProperty(
                "UInt16",
                typeof(ushort),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt16.SetGetter(
                ushort (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16(instance) == 0);
            uInt16.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort value) =>
                {
                    ManyTypesUnsafeAccessors.UInt16(instance) = value;
                    return instance;
                });
            uInt16.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort value) =>
                {
                    ManyTypesUnsafeAccessors.UInt16(instance) = value;
                    return instance;
                });
            uInt16.SetAccessors(
                ushort (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort (IInternalEntry entry) => entry.ReadOriginalValue<ushort>(uInt16, 229),
                ushort (IInternalEntry entry) => entry.GetCurrentValue<ushort>(uInt16));
            uInt16.SetPropertyIndexes(
                index: 229,
                originalValueIndex: 229,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    int (ushort v) => ((int)(v)),
                    ushort (int v) => ((ushort)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        int (ushort v) => ((int)(v)),
                        ushort (int v) => ((ushort)(v)))));
            uInt16.SetSentinelFromProviderValue(0);
            uInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16Array = runtimeEntityType.AddProperty(
                "UInt16Array",
                typeof(ushort[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt16Array.SetGetter(
                ushort[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16Array(instance) == null);
            uInt16Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt16Array(instance) = value;
                    return instance;
                });
            uInt16Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ushort[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt16Array(instance) = value;
                    return instance;
                });
            uInt16Array.SetAccessors(
                ushort[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ushort[] (IInternalEntry entry) => entry.ReadOriginalValue<ushort[]>(uInt16Array, 230),
                ushort[] (IInternalEntry entry) => entry.GetCurrentValue<ushort[]>(uInt16Array));
            uInt16Array.SetPropertyIndexes(
                index: 230,
                originalValueIndex: 230,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<ushort[], ushort>(new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v)),
                keyComparer: new ListOfValueTypesComparer<ushort[], ushort>(new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionOfStructsReaderWriter<ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            int (ushort v) => ((int)(v)),
                            ushort (int v) => ((ushort)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            int (ushort v) => ((int)(v)),
                            ushort (int v) => ((ushort)(v))))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        bool (ushort v1, ushort v2) => v1 == v2,
                        int (ushort v) => ((int)(v)),
                        ushort (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        bool (ushort v1, ushort v2) => v1 == v2,
                        int (ushort v) => ((int)(v)),
                        ushort (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        bool (int v1, int v2) => v1 == v2,
                        int (int v) => v,
                        int (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        int (ushort v) => ((int)(v)),
                        ushort (int v) => ((ushort)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            int (ushort v) => ((int)(v)),
                            ushort (int v) => ((ushort)(v))))));
            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
            uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32 = runtimeEntityType.AddProperty(
                "UInt32",
                typeof(uint),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt32.SetGetter(
                uint (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32(instance) == 0U);
            uInt32.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint value) =>
                {
                    ManyTypesUnsafeAccessors.UInt32(instance) = value;
                    return instance;
                });
            uInt32.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint value) =>
                {
                    ManyTypesUnsafeAccessors.UInt32(instance) = value;
                    return instance;
                });
            uInt32.SetAccessors(
                uint (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint (IInternalEntry entry) => entry.ReadOriginalValue<uint>(uInt32, 231),
                uint (IInternalEntry entry) => entry.GetCurrentValue<uint>(uInt32));
            uInt32.SetPropertyIndexes(
                index: 231,
                originalValueIndex: 231,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                converter: new ValueConverter<uint, long>(
                    long (uint v) => ((long)(v)),
                    uint (long v) => ((uint)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        long (uint v) => ((long)(v)),
                        uint (long v) => ((uint)(v)))));
            uInt32.SetSentinelFromProviderValue(0L);
            uInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32Array = runtimeEntityType.AddProperty(
                "UInt32Array",
                typeof(uint[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt32Array.SetGetter(
                uint[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32Array(instance) == null);
            uInt32Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt32Array(instance) = value;
                    return instance;
                });
            uInt32Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, uint[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt32Array(instance) = value;
                    return instance;
                });
            uInt32Array.SetAccessors(
                uint[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                uint[] (IInternalEntry entry) => entry.ReadOriginalValue<uint[]>(uInt32Array, 232),
                uint[] (IInternalEntry entry) => entry.GetCurrentValue<uint[]>(uInt32Array));
            uInt32Array.SetPropertyIndexes(
                index: 232,
                originalValueIndex: 232,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<uint[], uint>(new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v)),
                keyComparer: new ListOfValueTypesComparer<uint[], uint>(new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionOfStructsReaderWriter<uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            long (uint v) => ((long)(v)),
                            uint (long v) => ((uint)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            long (uint v) => ((long)(v)),
                            uint (long v) => ((uint)(v))))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        bool (uint v1, uint v2) => v1 == v2,
                        int (uint v) => ((int)(v)),
                        uint (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        bool (uint v1, uint v2) => v1 == v2,
                        int (uint v) => ((int)(v)),
                        uint (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        bool (long v1, long v2) => v1 == v2,
                        int (long v) => ((object)v).GetHashCode(),
                        long (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        long (uint v) => ((long)(v)),
                        uint (long v) => ((uint)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            long (uint v) => ((long)(v)),
                            uint (long v) => ((uint)(v))))));
            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
            uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64 = runtimeEntityType.AddProperty(
                "UInt64",
                typeof(ulong),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt64.SetGetter(
                ulong (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64(instance) == 0UL);
            uInt64.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong value) =>
                {
                    ManyTypesUnsafeAccessors.UInt64(instance) = value;
                    return instance;
                });
            uInt64.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong value) =>
                {
                    ManyTypesUnsafeAccessors.UInt64(instance) = value;
                    return instance;
                });
            uInt64.SetAccessors(
                ulong (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong (IInternalEntry entry) => entry.ReadOriginalValue<ulong>(uInt64, 233),
                ulong (IInternalEntry entry) => entry.GetCurrentValue<ulong>(uInt64));
            uInt64.SetPropertyIndexes(
                index: 233,
                originalValueIndex: 233,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    decimal (ulong v) => ((decimal)(v)),
                    ulong (decimal v) => ((ulong)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v)))));
            uInt64.SetSentinelFromProviderValue(0m);
            uInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64Array = runtimeEntityType.AddProperty(
                "UInt64Array",
                typeof(ulong[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt64Array.SetGetter(
                ulong[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64Array(instance) == null);
            uInt64Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt64Array(instance) = value;
                    return instance;
                });
            uInt64Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, ulong[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt64Array(instance) = value;
                    return instance;
                });
            uInt64Array.SetAccessors(
                ulong[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                ulong[] (IInternalEntry entry) => entry.ReadOriginalValue<ulong[]>(uInt64Array, 234),
                ulong[] (IInternalEntry entry) => entry.GetCurrentValue<ulong[]>(uInt64Array));
            uInt64Array.SetPropertyIndexes(
                index: 234,
                originalValueIndex: 234,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<ulong[], ulong>(new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v)),
                keyComparer: new ListOfValueTypesComparer<ulong[], ulong>(new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionOfStructsReaderWriter<ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            decimal (ulong v) => ((decimal)(v)),
                            ulong (decimal v) => ((ulong)(v)))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            decimal (ulong v) => ((decimal)(v)),
                            ulong (decimal v) => ((ulong)(v))))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        bool (ulong v1, ulong v2) => v1 == v2,
                        int (ulong v) => ((object)v).GetHashCode(),
                        ulong (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        bool (ulong v1, ulong v2) => v1 == v2,
                        int (ulong v) => ((object)v).GetHashCode(),
                        ulong (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        bool (decimal v1, decimal v2) => v1 == v2,
                        int (decimal v) => ((object)v).GetHashCode(),
                        decimal (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v))),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            decimal (ulong v) => ((decimal)(v)),
                            ulong (decimal v) => ((ulong)(v))))));
            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
            uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8 = runtimeEntityType.AddProperty(
                "UInt8",
                typeof(byte),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (byte)0);
            uInt8.SetGetter(
                byte (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8(instance) == 0);
            uInt8.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte value) =>
                {
                    ManyTypesUnsafeAccessors.UInt8(instance) = value;
                    return instance;
                });
            uInt8.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte value) =>
                {
                    ManyTypesUnsafeAccessors.UInt8(instance) = value;
                    return instance;
                });
            uInt8.SetAccessors(
                byte (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte (IInternalEntry entry) => entry.ReadOriginalValue<byte>(uInt8, 235),
                byte (IInternalEntry entry) => entry.GetCurrentValue<byte>(uInt8));
            uInt8.SetPropertyIndexes(
                index: 235,
                originalValueIndex: 235,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v));
            uInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8Array = runtimeEntityType.AddProperty(
                "UInt8Array",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt8Array.SetGetter(
                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8Array(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8Array(instance) == null);
            uInt8Array.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt8Array(instance) = value;
                    return instance;
                });
            uInt8Array.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, byte[] value) =>
                {
                    ManyTypesUnsafeAccessors.UInt8Array(instance) = value;
                    return instance;
                });
            uInt8Array.SetAccessors(
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                byte[] (IInternalEntry entry) => entry.ReadOriginalValue<byte[]>(uInt8Array, 236),
                byte[] (IInternalEntry entry) => entry.GetCurrentValue<byte[]>(uInt8Array));
            uInt8Array.SetPropertyIndexes(
                index: 236,
                originalValueIndex: 236,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt8Array.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => ((object)v).GetHashCode(),
                    byte[] (byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                    byte[] (byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            uInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8ReadOnlyCollection = runtimeEntityType.AddProperty(
                "UInt8ReadOnlyCollection",
                typeof(IReadOnlyCollection<byte>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_uInt8ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt8ReadOnlyCollection.SetGetter(
                IReadOnlyCollection<byte> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance)))),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance) == null);
            uInt8ReadOnlyCollection.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<byte> value) =>
                {
                    ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance) = ((List<byte>)(value));
                    return instance;
                });
            uInt8ReadOnlyCollection.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, IReadOnlyCollection<byte> value) =>
                {
                    ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance) = ((List<byte>)(value));
                    return instance;
                });
            uInt8ReadOnlyCollection.SetAccessors(
                IReadOnlyCollection<byte> (IInternalEntry entry) => ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<byte> (IInternalEntry entry) => ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
                IReadOnlyCollection<byte> (IInternalEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection, 237),
                IReadOnlyCollection<byte> (IInternalEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection));
            uInt8ReadOnlyCollection.SetPropertyIndexes(
                index: 237,
                originalValueIndex: 237,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uInt8ReadOnlyCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v)),
                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        bool (byte v1, byte v2) => v1 == v2,
                        int (byte v) => ((int)(v)),
                        byte (byte v) => v)));
            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
            uInt8ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uri = runtimeEntityType.AddProperty(
                "Uri",
                typeof(Uri),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uri.SetGetter(
                Uri (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Uri(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Uri(instance) == null);
            uri.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri value) =>
                {
                    ManyTypesUnsafeAccessors.Uri(instance) = value;
                    return instance;
                });
            uri.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri value) =>
                {
                    ManyTypesUnsafeAccessors.Uri(instance) = value;
                    return instance;
                });
            uri.SetAccessors(
                Uri (IInternalEntry entry) => ManyTypesUnsafeAccessors.Uri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri (IInternalEntry entry) => ManyTypesUnsafeAccessors.Uri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri (IInternalEntry entry) => entry.ReadOriginalValue<Uri>(uri, 238),
                Uri (IInternalEntry entry) => entry.GetCurrentValue<Uri>(uri));
            uri.SetPropertyIndexes(
                index: 238,
                originalValueIndex: 238,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    string (Uri v) => ((object)v).ToString(),
                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            uri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uriArray = runtimeEntityType.AddProperty(
                "UriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uriArray.SetGetter(
                Uri[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriArray(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriArray(instance) == null);
            uriArray.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri[] value) =>
                {
                    ManyTypesUnsafeAccessors.UriArray(instance) = value;
                    return instance;
                });
            uriArray.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri[] value) =>
                {
                    ManyTypesUnsafeAccessors.UriArray(instance) = value;
                    return instance;
                });
            uriArray.SetAccessors(
                Uri[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri[] (IInternalEntry entry) => ManyTypesUnsafeAccessors.UriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri[] (IInternalEntry entry) => entry.ReadOriginalValue<Uri[]>(uriArray, 239),
                Uri[] (IInternalEntry entry) => entry.GetCurrentValue<Uri[]>(uriArray));
            uriArray.SetPropertyIndexes(
                index: 239,
                originalValueIndex: 239,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v)),
                keyComparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            string (Uri v) => ((object)v).ToString(),
                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            string (Uri v) => ((object)v).ToString(),
                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (Uri v) => ((object)v).GetHashCode(),
                        Uri (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        int (Uri v) => ((object)v).GetHashCode(),
                        Uri (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        bool (string v1, string v2) => v1 == v2,
                        int (string v) => ((object)v).GetHashCode(),
                        string (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        unicode: true,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            string (Uri v) => ((object)v).ToString(),
                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
            uriArrayElementType.TypeMapping = uriArray.TypeMapping.ElementTypeMapping;
            uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                "UriToStringConverterProperty",
                typeof(Uri),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new UriToStringConverter());
            uriToStringConverterProperty.SetGetter(
                Uri (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(instance),
                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(instance) == null);
            uriToStringConverterProperty.SetSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri value) =>
                {
                    ManyTypesUnsafeAccessors.UriToStringConverterProperty(instance) = value;
                    return instance;
                });
            uriToStringConverterProperty.SetMaterializationSetter(
                CompiledModelTestBase.ManyTypes (CompiledModelTestBase.ManyTypes instance, Uri value) =>
                {
                    ManyTypesUnsafeAccessors.UriToStringConverterProperty(instance) = value;
                    return instance;
                });
            uriToStringConverterProperty.SetAccessors(
                Uri (IInternalEntry entry) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri (IInternalEntry entry) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                Uri (IInternalEntry entry) => entry.ReadOriginalValue<Uri>(uriToStringConverterProperty, 240),
                Uri (IInternalEntry entry) => entry.GetCurrentValue<Uri>(uriToStringConverterProperty));
            uriToStringConverterProperty.SetPropertyIndexes(
                index: 240,
                originalValueIndex: 240,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uriToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    unicode: true,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    string (Uri v) => ((object)v).ToString(),
                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            uriToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var id = runtimeEntityType.FindProperty("Id");
            var @bool = runtimeEntityType.FindProperty("Bool");
            var boolArray = runtimeEntityType.FindProperty("BoolArray");
            var boolReadOnlyCollection = runtimeEntityType.FindProperty("BoolReadOnlyCollection");
            var boolToStringConverterProperty = runtimeEntityType.FindProperty("BoolToStringConverterProperty");
            var boolToTwoValuesConverterProperty = runtimeEntityType.FindProperty("BoolToTwoValuesConverterProperty");
            var boolToZeroOneConverterProperty = runtimeEntityType.FindProperty("BoolToZeroOneConverterProperty");
            var bytes = runtimeEntityType.FindProperty("Bytes");
            var bytesArray = runtimeEntityType.FindProperty("BytesArray");
            var bytesToStringConverterProperty = runtimeEntityType.FindProperty("BytesToStringConverterProperty");
            var castingConverterProperty = runtimeEntityType.FindProperty("CastingConverterProperty");
            var @char = runtimeEntityType.FindProperty("Char");
            var charArray = runtimeEntityType.FindProperty("CharArray");
            var charToStringConverterProperty = runtimeEntityType.FindProperty("CharToStringConverterProperty");
            var dateOnly = runtimeEntityType.FindProperty("DateOnly");
            var dateOnlyArray = runtimeEntityType.FindProperty("DateOnlyArray");
            var dateOnlyToStringConverterProperty = runtimeEntityType.FindProperty("DateOnlyToStringConverterProperty");
            var dateTime = runtimeEntityType.FindProperty("DateTime");
            var dateTimeArray = runtimeEntityType.FindProperty("DateTimeArray");
            var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.FindProperty("DateTimeOffsetToBinaryConverterProperty");
            var dateTimeOffsetToBytesConverterProperty = runtimeEntityType.FindProperty("DateTimeOffsetToBytesConverterProperty");
            var dateTimeOffsetToStringConverterProperty = runtimeEntityType.FindProperty("DateTimeOffsetToStringConverterProperty");
            var dateTimeToBinaryConverterProperty = runtimeEntityType.FindProperty("DateTimeToBinaryConverterProperty");
            var dateTimeToStringConverterProperty = runtimeEntityType.FindProperty("DateTimeToStringConverterProperty");
            var dateTimeToTicksConverterProperty = runtimeEntityType.FindProperty("DateTimeToTicksConverterProperty");
            var @decimal = runtimeEntityType.FindProperty("Decimal");
            var decimalArray = runtimeEntityType.FindProperty("DecimalArray");
            var decimalNumberToBytesConverterProperty = runtimeEntityType.FindProperty("DecimalNumberToBytesConverterProperty");
            var decimalNumberToStringConverterProperty = runtimeEntityType.FindProperty("DecimalNumberToStringConverterProperty");
            var @double = runtimeEntityType.FindProperty("Double");
            var doubleArray = runtimeEntityType.FindProperty("DoubleArray");
            var doubleNumberToBytesConverterProperty = runtimeEntityType.FindProperty("DoubleNumberToBytesConverterProperty");
            var doubleNumberToStringConverterProperty = runtimeEntityType.FindProperty("DoubleNumberToStringConverterProperty");
            var enum16 = runtimeEntityType.FindProperty("Enum16");
            var enum16Array = runtimeEntityType.FindProperty("Enum16Array");
            var enum16AsString = runtimeEntityType.FindProperty("Enum16AsString");
            var enum16AsStringArray = runtimeEntityType.FindProperty("Enum16AsStringArray");
            var enum16AsStringCollection = runtimeEntityType.FindProperty("Enum16AsStringCollection");
            var enum16Collection = runtimeEntityType.FindProperty("Enum16Collection");
            var enum32 = runtimeEntityType.FindProperty("Enum32");
            var enum32Array = runtimeEntityType.FindProperty("Enum32Array");
            var enum32AsString = runtimeEntityType.FindProperty("Enum32AsString");
            var enum32AsStringArray = runtimeEntityType.FindProperty("Enum32AsStringArray");
            var enum32AsStringCollection = runtimeEntityType.FindProperty("Enum32AsStringCollection");
            var enum32Collection = runtimeEntityType.FindProperty("Enum32Collection");
            var enum64 = runtimeEntityType.FindProperty("Enum64");
            var enum64Array = runtimeEntityType.FindProperty("Enum64Array");
            var enum64AsString = runtimeEntityType.FindProperty("Enum64AsString");
            var enum64AsStringArray = runtimeEntityType.FindProperty("Enum64AsStringArray");
            var enum64AsStringCollection = runtimeEntityType.FindProperty("Enum64AsStringCollection");
            var enum64Collection = runtimeEntityType.FindProperty("Enum64Collection");
            var enum8 = runtimeEntityType.FindProperty("Enum8");
            var enum8Array = runtimeEntityType.FindProperty("Enum8Array");
            var enum8AsString = runtimeEntityType.FindProperty("Enum8AsString");
            var enum8AsStringArray = runtimeEntityType.FindProperty("Enum8AsStringArray");
            var enum8AsStringCollection = runtimeEntityType.FindProperty("Enum8AsStringCollection");
            var enum8Collection = runtimeEntityType.FindProperty("Enum8Collection");
            var enumToNumberConverterProperty = runtimeEntityType.FindProperty("EnumToNumberConverterProperty");
            var enumToStringConverterProperty = runtimeEntityType.FindProperty("EnumToStringConverterProperty");
            var enumU16 = runtimeEntityType.FindProperty("EnumU16");
            var enumU16Array = runtimeEntityType.FindProperty("EnumU16Array");
            var enumU16AsString = runtimeEntityType.FindProperty("EnumU16AsString");
            var enumU16AsStringArray = runtimeEntityType.FindProperty("EnumU16AsStringArray");
            var enumU16AsStringCollection = runtimeEntityType.FindProperty("EnumU16AsStringCollection");
            var enumU16Collection = runtimeEntityType.FindProperty("EnumU16Collection");
            var enumU32 = runtimeEntityType.FindProperty("EnumU32");
            var enumU32Array = runtimeEntityType.FindProperty("EnumU32Array");
            var enumU32AsString = runtimeEntityType.FindProperty("EnumU32AsString");
            var enumU32AsStringArray = runtimeEntityType.FindProperty("EnumU32AsStringArray");
            var enumU32AsStringCollection = runtimeEntityType.FindProperty("EnumU32AsStringCollection");
            var enumU32Collection = runtimeEntityType.FindProperty("EnumU32Collection");
            var enumU64 = runtimeEntityType.FindProperty("EnumU64");
            var enumU64Array = runtimeEntityType.FindProperty("EnumU64Array");
            var enumU64AsString = runtimeEntityType.FindProperty("EnumU64AsString");
            var enumU64AsStringArray = runtimeEntityType.FindProperty("EnumU64AsStringArray");
            var enumU64AsStringCollection = runtimeEntityType.FindProperty("EnumU64AsStringCollection");
            var enumU64Collection = runtimeEntityType.FindProperty("EnumU64Collection");
            var enumU8 = runtimeEntityType.FindProperty("EnumU8");
            var enumU8Array = runtimeEntityType.FindProperty("EnumU8Array");
            var enumU8AsString = runtimeEntityType.FindProperty("EnumU8AsString");
            var enumU8AsStringArray = runtimeEntityType.FindProperty("EnumU8AsStringArray");
            var enumU8AsStringCollection = runtimeEntityType.FindProperty("EnumU8AsStringCollection");
            var enumU8Collection = runtimeEntityType.FindProperty("EnumU8Collection");
            var @float = runtimeEntityType.FindProperty("Float");
            var floatArray = runtimeEntityType.FindProperty("FloatArray");
            var guid = runtimeEntityType.FindProperty("Guid");
            var guidArray = runtimeEntityType.FindProperty("GuidArray");
            var guidToBytesConverterProperty = runtimeEntityType.FindProperty("GuidToBytesConverterProperty");
            var guidToStringConverterProperty = runtimeEntityType.FindProperty("GuidToStringConverterProperty");
            var iPAddress = runtimeEntityType.FindProperty("IPAddress");
            var iPAddressArray = runtimeEntityType.FindProperty("IPAddressArray");
            var iPAddressReadOnlyCollection = runtimeEntityType.FindProperty("IPAddressReadOnlyCollection");
            var iPAddressToBytesConverterProperty = runtimeEntityType.FindProperty("IPAddressToBytesConverterProperty");
            var iPAddressToStringConverterProperty = runtimeEntityType.FindProperty("IPAddressToStringConverterProperty");
            var int16 = runtimeEntityType.FindProperty("Int16");
            var int16Array = runtimeEntityType.FindProperty("Int16Array");
            var int32 = runtimeEntityType.FindProperty("Int32");
            var int32Array = runtimeEntityType.FindProperty("Int32Array");
            var int32ReadOnlyCollection = runtimeEntityType.FindProperty("Int32ReadOnlyCollection");
            var int64 = runtimeEntityType.FindProperty("Int64");
            var int64Array = runtimeEntityType.FindProperty("Int64Array");
            var int8 = runtimeEntityType.FindProperty("Int8");
            var int8Array = runtimeEntityType.FindProperty("Int8Array");
            var intNumberToBytesConverterProperty = runtimeEntityType.FindProperty("IntNumberToBytesConverterProperty");
            var intNumberToStringConverterProperty = runtimeEntityType.FindProperty("IntNumberToStringConverterProperty");
            var nullIntToNullStringConverterProperty = runtimeEntityType.FindProperty("NullIntToNullStringConverterProperty");
            var nullableBool = runtimeEntityType.FindProperty("NullableBool");
            var nullableBoolArray = runtimeEntityType.FindProperty("NullableBoolArray");
            var nullableBytes = runtimeEntityType.FindProperty("NullableBytes");
            var nullableBytesArray = runtimeEntityType.FindProperty("NullableBytesArray");
            var nullableChar = runtimeEntityType.FindProperty("NullableChar");
            var nullableCharArray = runtimeEntityType.FindProperty("NullableCharArray");
            var nullableDateOnly = runtimeEntityType.FindProperty("NullableDateOnly");
            var nullableDateOnlyArray = runtimeEntityType.FindProperty("NullableDateOnlyArray");
            var nullableDateTime = runtimeEntityType.FindProperty("NullableDateTime");
            var nullableDateTimeArray = runtimeEntityType.FindProperty("NullableDateTimeArray");
            var nullableDecimal = runtimeEntityType.FindProperty("NullableDecimal");
            var nullableDecimalArray = runtimeEntityType.FindProperty("NullableDecimalArray");
            var nullableDouble = runtimeEntityType.FindProperty("NullableDouble");
            var nullableDoubleArray = runtimeEntityType.FindProperty("NullableDoubleArray");
            var nullableEnum16 = runtimeEntityType.FindProperty("NullableEnum16");
            var nullableEnum16Array = runtimeEntityType.FindProperty("NullableEnum16Array");
            var nullableEnum16AsString = runtimeEntityType.FindProperty("NullableEnum16AsString");
            var nullableEnum16AsStringArray = runtimeEntityType.FindProperty("NullableEnum16AsStringArray");
            var nullableEnum16AsStringCollection = runtimeEntityType.FindProperty("NullableEnum16AsStringCollection");
            var nullableEnum16Collection = runtimeEntityType.FindProperty("NullableEnum16Collection");
            var nullableEnum32 = runtimeEntityType.FindProperty("NullableEnum32");
            var nullableEnum32Array = runtimeEntityType.FindProperty("NullableEnum32Array");
            var nullableEnum32AsString = runtimeEntityType.FindProperty("NullableEnum32AsString");
            var nullableEnum32AsStringArray = runtimeEntityType.FindProperty("NullableEnum32AsStringArray");
            var nullableEnum32AsStringCollection = runtimeEntityType.FindProperty("NullableEnum32AsStringCollection");
            var nullableEnum32Collection = runtimeEntityType.FindProperty("NullableEnum32Collection");
            var nullableEnum64 = runtimeEntityType.FindProperty("NullableEnum64");
            var nullableEnum64Array = runtimeEntityType.FindProperty("NullableEnum64Array");
            var nullableEnum64AsString = runtimeEntityType.FindProperty("NullableEnum64AsString");
            var nullableEnum64AsStringArray = runtimeEntityType.FindProperty("NullableEnum64AsStringArray");
            var nullableEnum64AsStringCollection = runtimeEntityType.FindProperty("NullableEnum64AsStringCollection");
            var nullableEnum64Collection = runtimeEntityType.FindProperty("NullableEnum64Collection");
            var nullableEnum8 = runtimeEntityType.FindProperty("NullableEnum8");
            var nullableEnum8Array = runtimeEntityType.FindProperty("NullableEnum8Array");
            var nullableEnum8AsString = runtimeEntityType.FindProperty("NullableEnum8AsString");
            var nullableEnum8AsStringArray = runtimeEntityType.FindProperty("NullableEnum8AsStringArray");
            var nullableEnum8AsStringCollection = runtimeEntityType.FindProperty("NullableEnum8AsStringCollection");
            var nullableEnum8Collection = runtimeEntityType.FindProperty("NullableEnum8Collection");
            var nullableEnumU16 = runtimeEntityType.FindProperty("NullableEnumU16");
            var nullableEnumU16Array = runtimeEntityType.FindProperty("NullableEnumU16Array");
            var nullableEnumU16AsString = runtimeEntityType.FindProperty("NullableEnumU16AsString");
            var nullableEnumU16AsStringArray = runtimeEntityType.FindProperty("NullableEnumU16AsStringArray");
            var nullableEnumU16AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU16AsStringCollection");
            var nullableEnumU16Collection = runtimeEntityType.FindProperty("NullableEnumU16Collection");
            var nullableEnumU32 = runtimeEntityType.FindProperty("NullableEnumU32");
            var nullableEnumU32Array = runtimeEntityType.FindProperty("NullableEnumU32Array");
            var nullableEnumU32AsString = runtimeEntityType.FindProperty("NullableEnumU32AsString");
            var nullableEnumU32AsStringArray = runtimeEntityType.FindProperty("NullableEnumU32AsStringArray");
            var nullableEnumU32AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU32AsStringCollection");
            var nullableEnumU32Collection = runtimeEntityType.FindProperty("NullableEnumU32Collection");
            var nullableEnumU64 = runtimeEntityType.FindProperty("NullableEnumU64");
            var nullableEnumU64Array = runtimeEntityType.FindProperty("NullableEnumU64Array");
            var nullableEnumU64AsString = runtimeEntityType.FindProperty("NullableEnumU64AsString");
            var nullableEnumU64AsStringArray = runtimeEntityType.FindProperty("NullableEnumU64AsStringArray");
            var nullableEnumU64AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU64AsStringCollection");
            var nullableEnumU64Collection = runtimeEntityType.FindProperty("NullableEnumU64Collection");
            var nullableEnumU8 = runtimeEntityType.FindProperty("NullableEnumU8");
            var nullableEnumU8Array = runtimeEntityType.FindProperty("NullableEnumU8Array");
            var nullableEnumU8AsString = runtimeEntityType.FindProperty("NullableEnumU8AsString");
            var nullableEnumU8AsStringArray = runtimeEntityType.FindProperty("NullableEnumU8AsStringArray");
            var nullableEnumU8AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU8AsStringCollection");
            var nullableEnumU8Collection = runtimeEntityType.FindProperty("NullableEnumU8Collection");
            var nullableFloat = runtimeEntityType.FindProperty("NullableFloat");
            var nullableFloatArray = runtimeEntityType.FindProperty("NullableFloatArray");
            var nullableGuid = runtimeEntityType.FindProperty("NullableGuid");
            var nullableGuidArray = runtimeEntityType.FindProperty("NullableGuidArray");
            var nullableIPAddress = runtimeEntityType.FindProperty("NullableIPAddress");
            var nullableIPAddressArray = runtimeEntityType.FindProperty("NullableIPAddressArray");
            var nullableInt16 = runtimeEntityType.FindProperty("NullableInt16");
            var nullableInt16Array = runtimeEntityType.FindProperty("NullableInt16Array");
            var nullableInt32 = runtimeEntityType.FindProperty("NullableInt32");
            var nullableInt32Array = runtimeEntityType.FindProperty("NullableInt32Array");
            var nullableInt64 = runtimeEntityType.FindProperty("NullableInt64");
            var nullableInt64Array = runtimeEntityType.FindProperty("NullableInt64Array");
            var nullableInt8 = runtimeEntityType.FindProperty("NullableInt8");
            var nullableInt8Array = runtimeEntityType.FindProperty("NullableInt8Array");
            var nullablePhysicalAddress = runtimeEntityType.FindProperty("NullablePhysicalAddress");
            var nullablePhysicalAddressArray = runtimeEntityType.FindProperty("NullablePhysicalAddressArray");
            var nullableString = runtimeEntityType.FindProperty("NullableString");
            var nullableStringArray = runtimeEntityType.FindProperty("NullableStringArray");
            var nullableTimeOnly = runtimeEntityType.FindProperty("NullableTimeOnly");
            var nullableTimeOnlyArray = runtimeEntityType.FindProperty("NullableTimeOnlyArray");
            var nullableTimeSpan = runtimeEntityType.FindProperty("NullableTimeSpan");
            var nullableTimeSpanArray = runtimeEntityType.FindProperty("NullableTimeSpanArray");
            var nullableUInt16 = runtimeEntityType.FindProperty("NullableUInt16");
            var nullableUInt16Array = runtimeEntityType.FindProperty("NullableUInt16Array");
            var nullableUInt32 = runtimeEntityType.FindProperty("NullableUInt32");
            var nullableUInt32Array = runtimeEntityType.FindProperty("NullableUInt32Array");
            var nullableUInt64 = runtimeEntityType.FindProperty("NullableUInt64");
            var nullableUInt64Array = runtimeEntityType.FindProperty("NullableUInt64Array");
            var nullableUInt8 = runtimeEntityType.FindProperty("NullableUInt8");
            var nullableUInt8Array = runtimeEntityType.FindProperty("NullableUInt8Array");
            var nullableUri = runtimeEntityType.FindProperty("NullableUri");
            var nullableUriArray = runtimeEntityType.FindProperty("NullableUriArray");
            var physicalAddress = runtimeEntityType.FindProperty("PhysicalAddress");
            var physicalAddressArray = runtimeEntityType.FindProperty("PhysicalAddressArray");
            var physicalAddressToBytesConverterProperty = runtimeEntityType.FindProperty("PhysicalAddressToBytesConverterProperty");
            var physicalAddressToStringConverterProperty = runtimeEntityType.FindProperty("PhysicalAddressToStringConverterProperty");
            var @string = runtimeEntityType.FindProperty("String");
            var stringArray = runtimeEntityType.FindProperty("StringArray");
            var stringReadOnlyCollection = runtimeEntityType.FindProperty("StringReadOnlyCollection");
            var stringToBoolConverterProperty = runtimeEntityType.FindProperty("StringToBoolConverterProperty");
            var stringToBytesConverterProperty = runtimeEntityType.FindProperty("StringToBytesConverterProperty");
            var stringToCharConverterProperty = runtimeEntityType.FindProperty("StringToCharConverterProperty");
            var stringToDateOnlyConverterProperty = runtimeEntityType.FindProperty("StringToDateOnlyConverterProperty");
            var stringToDateTimeConverterProperty = runtimeEntityType.FindProperty("StringToDateTimeConverterProperty");
            var stringToDateTimeOffsetConverterProperty = runtimeEntityType.FindProperty("StringToDateTimeOffsetConverterProperty");
            var stringToDecimalNumberConverterProperty = runtimeEntityType.FindProperty("StringToDecimalNumberConverterProperty");
            var stringToDoubleNumberConverterProperty = runtimeEntityType.FindProperty("StringToDoubleNumberConverterProperty");
            var stringToEnumConverterProperty = runtimeEntityType.FindProperty("StringToEnumConverterProperty");
            var stringToGuidConverterProperty = runtimeEntityType.FindProperty("StringToGuidConverterProperty");
            var stringToIntNumberConverterProperty = runtimeEntityType.FindProperty("StringToIntNumberConverterProperty");
            var stringToTimeOnlyConverterProperty = runtimeEntityType.FindProperty("StringToTimeOnlyConverterProperty");
            var stringToTimeSpanConverterProperty = runtimeEntityType.FindProperty("StringToTimeSpanConverterProperty");
            var stringToUriConverterProperty = runtimeEntityType.FindProperty("StringToUriConverterProperty");
            var timeOnly = runtimeEntityType.FindProperty("TimeOnly");
            var timeOnlyArray = runtimeEntityType.FindProperty("TimeOnlyArray");
            var timeOnlyToStringConverterProperty = runtimeEntityType.FindProperty("TimeOnlyToStringConverterProperty");
            var timeOnlyToTicksConverterProperty = runtimeEntityType.FindProperty("TimeOnlyToTicksConverterProperty");
            var timeSpan = runtimeEntityType.FindProperty("TimeSpan");
            var timeSpanArray = runtimeEntityType.FindProperty("TimeSpanArray");
            var timeSpanToStringConverterProperty = runtimeEntityType.FindProperty("TimeSpanToStringConverterProperty");
            var timeSpanToTicksConverterProperty = runtimeEntityType.FindProperty("TimeSpanToTicksConverterProperty");
            var uInt16 = runtimeEntityType.FindProperty("UInt16");
            var uInt16Array = runtimeEntityType.FindProperty("UInt16Array");
            var uInt32 = runtimeEntityType.FindProperty("UInt32");
            var uInt32Array = runtimeEntityType.FindProperty("UInt32Array");
            var uInt64 = runtimeEntityType.FindProperty("UInt64");
            var uInt64Array = runtimeEntityType.FindProperty("UInt64Array");
            var uInt8 = runtimeEntityType.FindProperty("UInt8");
            var uInt8Array = runtimeEntityType.FindProperty("UInt8Array");
            var uInt8ReadOnlyCollection = runtimeEntityType.FindProperty("UInt8ReadOnlyCollection");
            var uri = runtimeEntityType.FindProperty("Uri");
            var uriArray = runtimeEntityType.FindProperty("UriArray");
            var uriToStringConverterProperty = runtimeEntityType.FindProperty("UriToStringConverterProperty");
            var key = runtimeEntityType.FindKey(new[] { id });
            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<CompiledModelTestBase.ManyTypesId>(key));
            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<CompiledModelTestBase.ManyTypesId>(key));
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg = ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId, bool, bool[], IReadOnlyCollection<bool>, bool, bool, bool, byte[], byte[][], byte[], int, char, char[], char, DateOnly, DateOnly[], DateOnly, DateTime, DateTime[], DateTimeOffset, DateTimeOffset, DateTimeOffset, DateTime, DateTime, DateTime, decimal, decimal[], decimal, decimal, double>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.ManyTypesId>(id)), ((ValueComparer<bool>)(((IProperty)@bool).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(@bool)), (((IEnumerable<bool>)(source.GetCurrentValue<bool[]>(boolArray))) == null ? null : ((bool[])(((ValueComparer<IEnumerable<bool>>)(((IProperty)boolArray).GetValueComparer())).Snapshot(((IEnumerable<bool>)(source.GetCurrentValue<bool[]>(boolArray))))))), (((IEnumerable<bool>)(source.GetCurrentValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<bool>)(((ValueComparer<IEnumerable<bool>>)(((IProperty)boolReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<bool>)(source.GetCurrentValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection))))))), ((ValueComparer<bool>)(((IProperty)boolToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(boolToStringConverterProperty)), ((ValueComparer<bool>)(((IProperty)boolToTwoValuesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(boolToTwoValuesConverterProperty)), ((ValueComparer<bool>)(((IProperty)boolToZeroOneConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(boolToZeroOneConverterProperty)), (source.GetCurrentValue<byte[]>(bytes) == null ? null : ((ValueComparer<byte[]>)(((IProperty)bytes).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(bytes))), (((object)(source.GetCurrentValue<byte[][]>(bytesArray))) == null ? null : ((byte[][])(((ValueComparer<object>)(((IProperty)bytesArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte[][]>(bytesArray))))))), (source.GetCurrentValue<byte[]>(bytesToStringConverterProperty) == null ? null : ((ValueComparer<byte[]>)(((IProperty)bytesToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(bytesToStringConverterProperty))), ((ValueComparer<int>)(((IProperty)castingConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(castingConverterProperty)), ((ValueComparer<char>)(((IProperty)@char).GetValueComparer())).Snapshot(source.GetCurrentValue<char>(@char)), (((IEnumerable<char>)(source.GetCurrentValue<char[]>(charArray))) == null ? null : ((char[])(((ValueComparer<IEnumerable<char>>)(((IProperty)charArray).GetValueComparer())).Snapshot(((IEnumerable<char>)(source.GetCurrentValue<char[]>(charArray))))))), ((ValueComparer<char>)(((IProperty)charToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<char>(charToStringConverterProperty)), ((ValueComparer<DateOnly>)(((IProperty)dateOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly>(dateOnly)), (((IEnumerable<DateOnly>)(source.GetCurrentValue<DateOnly[]>(dateOnlyArray))) == null ? null : ((DateOnly[])(((ValueComparer<IEnumerable<DateOnly>>)(((IProperty)dateOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<DateOnly>)(source.GetCurrentValue<DateOnly[]>(dateOnlyArray))))))), ((ValueComparer<DateOnly>)(((IProperty)dateOnlyToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly>(dateOnlyToStringConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTime).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTime)), (((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(dateTimeArray))) == null ? null : ((DateTime[])(((ValueComparer<IEnumerable<DateTime>>)(((IProperty)dateTimeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(dateTimeArray))))))), ((ValueComparer<DateTimeOffset>)(((IProperty)dateTimeOffsetToBinaryConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBinaryConverterProperty)), ((ValueComparer<DateTimeOffset>)(((IProperty)dateTimeOffsetToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBytesConverterProperty)), ((ValueComparer<DateTimeOffset>)(((IProperty)dateTimeOffsetToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToStringConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTimeToBinaryConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTimeToBinaryConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTimeToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTimeToStringConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTimeToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTimeToTicksConverterProperty)), ((ValueComparer<decimal>)(((IProperty)@decimal).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(@decimal)), (((IEnumerable<decimal>)(source.GetCurrentValue<decimal[]>(decimalArray))) == null ? null : ((decimal[])(((ValueComparer<IEnumerable<decimal>>)(((IProperty)decimalArray).GetValueComparer())).Snapshot(((IEnumerable<decimal>)(source.GetCurrentValue<decimal[]>(decimalArray))))))), ((ValueComparer<decimal>)(((IProperty)decimalNumberToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(decimalNumberToBytesConverterProperty)), ((ValueComparer<decimal>)(((IProperty)decimalNumberToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(decimalNumberToStringConverterProperty)), ((ValueComparer<double>)(((IProperty)@double).GetValueComparer())).Snapshot(source.GetCurrentValue<double>(@double)))));
                    var structuralType0 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg0 = ((ISnapshot)(new Snapshot<double[], double, double, CompiledModelTestBase.Enum16, CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16, CompiledModelTestBase.Enum16[], List<CompiledModelTestBase.Enum16>, List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum32, CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32, CompiledModelTestBase.Enum32[], List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum64, CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64, CompiledModelTestBase.Enum64[], List<CompiledModelTestBase.Enum64>, List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum8, CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8, CompiledModelTestBase.Enum8[], List<CompiledModelTestBase.Enum8>, List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum32, CompiledModelTestBase.Enum32, CompiledModelTestBase.EnumU16>((((IEnumerable<double>)(source.GetCurrentValue<double[]>(doubleArray))) == null ? null : ((double[])(((ValueComparer<IEnumerable<double>>)(((IProperty)doubleArray).GetValueComparer())).Snapshot(((IEnumerable<double>)(source.GetCurrentValue<double[]>(doubleArray))))))), ((ValueComparer<double>)(((IProperty)doubleNumberToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<double>(doubleNumberToBytesConverterProperty)), ((ValueComparer<double>)(((IProperty)doubleNumberToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<double>(doubleNumberToStringConverterProperty)), ((ValueComparer<CompiledModelTestBase.Enum16>)(((IProperty)enum16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16)), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16Array))) == null ? null : ((CompiledModelTestBase.Enum16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16Array))))))), ((ValueComparer<CompiledModelTestBase.Enum16>)(((IProperty)enum16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16AsString)), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16Collection))) == null ? null : ((List<CompiledModelTestBase.Enum16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16Collection))))))), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enum32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32)), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32Array))) == null ? null : ((CompiledModelTestBase.Enum32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32Array))))))), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enum32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32AsString)), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32Collection))) == null ? null : ((List<CompiledModelTestBase.Enum32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32Collection))))))), ((ValueComparer<CompiledModelTestBase.Enum64>)(((IProperty)enum64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64)), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64Array))) == null ? null : ((CompiledModelTestBase.Enum64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64Array))))))), ((ValueComparer<CompiledModelTestBase.Enum64>)(((IProperty)enum64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64AsString)), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64Collection))) == null ? null : ((List<CompiledModelTestBase.Enum64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64Collection))))))), ((ValueComparer<CompiledModelTestBase.Enum8>)(((IProperty)enum8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8)), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8Array))) == null ? null : ((CompiledModelTestBase.Enum8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8Array))))))), ((ValueComparer<CompiledModelTestBase.Enum8>)(((IProperty)enum8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8AsString)), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8Collection))) == null ? null : ((List<CompiledModelTestBase.Enum8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8Collection))))))), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enumToNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToNumberConverterProperty)), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enumToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToStringConverterProperty)), ((ValueComparer<CompiledModelTestBase.EnumU16>)(((IProperty)enumU16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16)))));
                    var structuralType1 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg1 = ((ISnapshot)(new Snapshot<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16, CompiledModelTestBase.EnumU16[], List<CompiledModelTestBase.EnumU16>, List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32[], List<CompiledModelTestBase.EnumU32>, List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU64, CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64, CompiledModelTestBase.EnumU64[], List<CompiledModelTestBase.EnumU64>, List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU8, CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8, CompiledModelTestBase.EnumU8[], List<CompiledModelTestBase.EnumU8>, List<CompiledModelTestBase.EnumU8>, float, float[], Guid, Guid[], Guid, Guid, IPAddress>((((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16Array))) == null ? null : ((CompiledModelTestBase.EnumU16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU16>)(((IProperty)enumU16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16AsString)), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection))))))), ((ValueComparer<CompiledModelTestBase.EnumU32>)(((IProperty)enumU32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32)), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32Array))) == null ? null : ((CompiledModelTestBase.EnumU32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU32>)(((IProperty)enumU32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32AsString)), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection))))))), ((ValueComparer<CompiledModelTestBase.EnumU64>)(((IProperty)enumU64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64)), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64Array))) == null ? null : ((CompiledModelTestBase.EnumU64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU64>)(((IProperty)enumU64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64AsString)), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection))))))), ((ValueComparer<CompiledModelTestBase.EnumU8>)(((IProperty)enumU8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8)), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8Array))) == null ? null : ((CompiledModelTestBase.EnumU8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU8>)(((IProperty)enumU8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8AsString)), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection))))))), ((ValueComparer<float>)(((IProperty)@float).GetValueComparer())).Snapshot(source.GetCurrentValue<float>(@float)), (((IEnumerable<float>)(source.GetCurrentValue<float[]>(floatArray))) == null ? null : ((float[])(((ValueComparer<IEnumerable<float>>)(((IProperty)floatArray).GetValueComparer())).Snapshot(((IEnumerable<float>)(source.GetCurrentValue<float[]>(floatArray))))))), ((ValueComparer<Guid>)(((IProperty)guid).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(guid)), (((IEnumerable<Guid>)(source.GetCurrentValue<Guid[]>(guidArray))) == null ? null : ((Guid[])(((ValueComparer<IEnumerable<Guid>>)(((IProperty)guidArray).GetValueComparer())).Snapshot(((IEnumerable<Guid>)(source.GetCurrentValue<Guid[]>(guidArray))))))), ((ValueComparer<Guid>)(((IProperty)guidToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(guidToBytesConverterProperty)), ((ValueComparer<Guid>)(((IProperty)guidToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(guidToStringConverterProperty)), (source.GetCurrentValue<IPAddress>(iPAddress) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)iPAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(iPAddress))))));
                    var structuralType2 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg2 = ((ISnapshot)(new Snapshot<IPAddress[], IReadOnlyCollection<IPAddress>, IPAddress, IPAddress, short, short[], int, int[], IReadOnlyCollection<int>, long, long[], sbyte, sbyte[], int, int, int?, bool?, bool? [], byte[], byte[][], char?, char? [], DateOnly?, DateOnly? [], DateTime?, DateTime? [], decimal?, decimal? [], double?, double? []>((((object)(source.GetCurrentValue<IPAddress[]>(iPAddressArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)iPAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(iPAddressArray))))))), (((object)(source.GetCurrentValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<IPAddress>)(((ValueComparer<object>)(((IProperty)iPAddressReadOnlyCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection))))))), (source.GetCurrentValue<IPAddress>(iPAddressToBytesConverterProperty) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)iPAddressToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(iPAddressToBytesConverterProperty))), (source.GetCurrentValue<IPAddress>(iPAddressToStringConverterProperty) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)iPAddressToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(iPAddressToStringConverterProperty))), ((ValueComparer<short>)(((IProperty)int16).GetValueComparer())).Snapshot(source.GetCurrentValue<short>(int16)), (((IEnumerable<short>)(source.GetCurrentValue<short[]>(int16Array))) == null ? null : ((short[])(((ValueComparer<IEnumerable<short>>)(((IProperty)int16Array).GetValueComparer())).Snapshot(((IEnumerable<short>)(source.GetCurrentValue<short[]>(int16Array))))))), ((ValueComparer<int>)(((IProperty)int32).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(int32)), (((IEnumerable<int>)(source.GetCurrentValue<int[]>(int32Array))) == null ? null : ((int[])(((ValueComparer<IEnumerable<int>>)(((IProperty)int32Array).GetValueComparer())).Snapshot(((IEnumerable<int>)(source.GetCurrentValue<int[]>(int32Array))))))), (((IEnumerable<int>)(source.GetCurrentValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<int>)(((ValueComparer<IEnumerable<int>>)(((IProperty)int32ReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<int>)(source.GetCurrentValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection))))))), ((ValueComparer<long>)(((IProperty)int64).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(int64)), (((IEnumerable<long>)(source.GetCurrentValue<long[]>(int64Array))) == null ? null : ((long[])(((ValueComparer<IEnumerable<long>>)(((IProperty)int64Array).GetValueComparer())).Snapshot(((IEnumerable<long>)(source.GetCurrentValue<long[]>(int64Array))))))), ((ValueComparer<sbyte>)(((IProperty)int8).GetValueComparer())).Snapshot(source.GetCurrentValue<sbyte>(int8)), (((IEnumerable<sbyte>)(source.GetCurrentValue<sbyte[]>(int8Array))) == null ? null : ((sbyte[])(((ValueComparer<IEnumerable<sbyte>>)(((IProperty)int8Array).GetValueComparer())).Snapshot(((IEnumerable<sbyte>)(source.GetCurrentValue<sbyte[]>(int8Array))))))), ((ValueComparer<int>)(((IProperty)intNumberToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(intNumberToBytesConverterProperty)), ((ValueComparer<int>)(((IProperty)intNumberToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(intNumberToStringConverterProperty)), (source.GetCurrentValue<int?>(nullIntToNullStringConverterProperty) == null ? null : ((ValueComparer<int?>)(((IProperty)nullIntToNullStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int?>(nullIntToNullStringConverterProperty))), (source.GetCurrentValue<bool?>(nullableBool) == null ? null : ((ValueComparer<bool?>)(((IProperty)nullableBool).GetValueComparer())).Snapshot(source.GetCurrentValue<bool?>(nullableBool))), (((IEnumerable<bool?>)(source.GetCurrentValue<bool? []>(nullableBoolArray))) == null ? null : ((bool? [])(((ValueComparer<IEnumerable<bool?>>)(((IProperty)nullableBoolArray).GetValueComparer())).Snapshot(((IEnumerable<bool?>)(source.GetCurrentValue<bool? []>(nullableBoolArray))))))), (source.GetCurrentValue<byte[]>(nullableBytes) == null ? null : ((ValueComparer<byte[]>)(((IProperty)nullableBytes).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(nullableBytes))), (((object)(source.GetCurrentValue<byte[][]>(nullableBytesArray))) == null ? null : ((byte[][])(((ValueComparer<object>)(((IProperty)nullableBytesArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte[][]>(nullableBytesArray))))))), (source.GetCurrentValue<char?>(nullableChar) == null ? null : ((ValueComparer<char?>)(((IProperty)nullableChar).GetValueComparer())).Snapshot(source.GetCurrentValue<char?>(nullableChar))), (((IEnumerable<char?>)(source.GetCurrentValue<char? []>(nullableCharArray))) == null ? null : ((char? [])(((ValueComparer<IEnumerable<char?>>)(((IProperty)nullableCharArray).GetValueComparer())).Snapshot(((IEnumerable<char?>)(source.GetCurrentValue<char? []>(nullableCharArray))))))), (source.GetCurrentValue<DateOnly?>(nullableDateOnly) == null ? null : ((ValueComparer<DateOnly?>)(((IProperty)nullableDateOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly?>(nullableDateOnly))), (((IEnumerable<DateOnly?>)(source.GetCurrentValue<DateOnly? []>(nullableDateOnlyArray))) == null ? null : ((DateOnly? [])(((ValueComparer<IEnumerable<DateOnly?>>)(((IProperty)nullableDateOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<DateOnly?>)(source.GetCurrentValue<DateOnly? []>(nullableDateOnlyArray))))))), (source.GetCurrentValue<DateTime?>(nullableDateTime) == null ? null : ((ValueComparer<DateTime?>)(((IProperty)nullableDateTime).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime?>(nullableDateTime))), (((IEnumerable<DateTime?>)(source.GetCurrentValue<DateTime? []>(nullableDateTimeArray))) == null ? null : ((DateTime? [])(((ValueComparer<IEnumerable<DateTime?>>)(((IProperty)nullableDateTimeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime?>)(source.GetCurrentValue<DateTime? []>(nullableDateTimeArray))))))), (source.GetCurrentValue<decimal?>(nullableDecimal) == null ? null : ((ValueComparer<decimal?>)(((IProperty)nullableDecimal).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal?>(nullableDecimal))), (((IEnumerable<decimal?>)(source.GetCurrentValue<decimal? []>(nullableDecimalArray))) == null ? null : ((decimal? [])(((ValueComparer<IEnumerable<decimal?>>)(((IProperty)nullableDecimalArray).GetValueComparer())).Snapshot(((IEnumerable<decimal?>)(source.GetCurrentValue<decimal? []>(nullableDecimalArray))))))), (source.GetCurrentValue<double?>(nullableDouble) == null ? null : ((ValueComparer<double?>)(((IProperty)nullableDouble).GetValueComparer())).Snapshot(source.GetCurrentValue<double?>(nullableDouble))), (((IEnumerable<double?>)(source.GetCurrentValue<double? []>(nullableDoubleArray))) == null ? null : ((double? [])(((ValueComparer<IEnumerable<double?>>)(((IProperty)nullableDoubleArray).GetValueComparer())).Snapshot(((IEnumerable<double?>)(source.GetCurrentValue<double? []>(nullableDoubleArray))))))))));
                    var structuralType3 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg3 = ((ISnapshot)(new Snapshot<CompiledModelTestBase.Enum16?, CompiledModelTestBase.Enum16? [], CompiledModelTestBase.Enum16?, CompiledModelTestBase.Enum16? [], List<CompiledModelTestBase.Enum16?>, List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum32?, CompiledModelTestBase.Enum32? [], CompiledModelTestBase.Enum32?, CompiledModelTestBase.Enum32? [], List<CompiledModelTestBase.Enum32?>, List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum64?, CompiledModelTestBase.Enum64? [], CompiledModelTestBase.Enum64?, CompiledModelTestBase.Enum64? [], List<CompiledModelTestBase.Enum64?>, List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum8?, CompiledModelTestBase.Enum8? [], CompiledModelTestBase.Enum8?, CompiledModelTestBase.Enum8? [], List<CompiledModelTestBase.Enum8?>, List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.EnumU16?, CompiledModelTestBase.EnumU16? [], CompiledModelTestBase.EnumU16?, CompiledModelTestBase.EnumU16? [], List<CompiledModelTestBase.EnumU16?>, List<CompiledModelTestBase.EnumU16?>>((source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum16?>)(((IProperty)nullableEnum16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array))) == null ? null : ((CompiledModelTestBase.Enum16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum16?>)(((IProperty)nullableEnum16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection))) == null ? null : ((List<CompiledModelTestBase.Enum16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum32?>)(((IProperty)nullableEnum32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array))) == null ? null : ((CompiledModelTestBase.Enum32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum32?>)(((IProperty)nullableEnum32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection))) == null ? null : ((List<CompiledModelTestBase.Enum32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum64?>)(((IProperty)nullableEnum64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array))) == null ? null : ((CompiledModelTestBase.Enum64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum64?>)(((IProperty)nullableEnum64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection))) == null ? null : ((List<CompiledModelTestBase.Enum64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum8?>)(((IProperty)nullableEnum8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array))) == null ? null : ((CompiledModelTestBase.Enum8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum8?>)(((IProperty)nullableEnum8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection))) == null ? null : ((List<CompiledModelTestBase.Enum8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU16?>)(((IProperty)nullableEnumU16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array))) == null ? null : ((CompiledModelTestBase.EnumU16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU16?>)(((IProperty)nullableEnumU16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection))))))))));
                    var structuralType4 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg4 = ((ISnapshot)(new Snapshot<CompiledModelTestBase.EnumU32?, CompiledModelTestBase.EnumU32? [], CompiledModelTestBase.EnumU32?, CompiledModelTestBase.EnumU32? [], List<CompiledModelTestBase.EnumU32?>, List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU64?, CompiledModelTestBase.EnumU64? [], CompiledModelTestBase.EnumU64?, CompiledModelTestBase.EnumU64? [], List<CompiledModelTestBase.EnumU64?>, List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU8?, CompiledModelTestBase.EnumU8? [], CompiledModelTestBase.EnumU8?, CompiledModelTestBase.EnumU8? [], List<CompiledModelTestBase.EnumU8?>, List<CompiledModelTestBase.EnumU8?>, float?, float? [], Guid?, Guid? [], IPAddress, IPAddress[], short?, short? [], int?, int? [], long?, long? []>((source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU32?>)(((IProperty)nullableEnumU32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array))) == null ? null : ((CompiledModelTestBase.EnumU32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU32?>)(((IProperty)nullableEnumU32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU64?>)(((IProperty)nullableEnumU64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array))) == null ? null : ((CompiledModelTestBase.EnumU64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU64?>)(((IProperty)nullableEnumU64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU8?>)(((IProperty)nullableEnumU8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array))) == null ? null : ((CompiledModelTestBase.EnumU8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU8?>)(((IProperty)nullableEnumU8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection))))))), (source.GetCurrentValue<float?>(nullableFloat) == null ? null : ((ValueComparer<float?>)(((IProperty)nullableFloat).GetValueComparer())).Snapshot(source.GetCurrentValue<float?>(nullableFloat))), (((IEnumerable<float?>)(source.GetCurrentValue<float? []>(nullableFloatArray))) == null ? null : ((float? [])(((ValueComparer<IEnumerable<float?>>)(((IProperty)nullableFloatArray).GetValueComparer())).Snapshot(((IEnumerable<float?>)(source.GetCurrentValue<float? []>(nullableFloatArray))))))), (source.GetCurrentValue<Guid?>(nullableGuid) == null ? null : ((ValueComparer<Guid?>)(((IProperty)nullableGuid).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid?>(nullableGuid))), (((IEnumerable<Guid?>)(source.GetCurrentValue<Guid? []>(nullableGuidArray))) == null ? null : ((Guid? [])(((ValueComparer<IEnumerable<Guid?>>)(((IProperty)nullableGuidArray).GetValueComparer())).Snapshot(((IEnumerable<Guid?>)(source.GetCurrentValue<Guid? []>(nullableGuidArray))))))), (source.GetCurrentValue<IPAddress>(nullableIPAddress) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)nullableIPAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(nullableIPAddress))), (((object)(source.GetCurrentValue<IPAddress[]>(nullableIPAddressArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)nullableIPAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(nullableIPAddressArray))))))), (source.GetCurrentValue<short?>(nullableInt16) == null ? null : ((ValueComparer<short?>)(((IProperty)nullableInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<short?>(nullableInt16))), (((IEnumerable<short?>)(source.GetCurrentValue<short? []>(nullableInt16Array))) == null ? null : ((short? [])(((ValueComparer<IEnumerable<short?>>)(((IProperty)nullableInt16Array).GetValueComparer())).Snapshot(((IEnumerable<short?>)(source.GetCurrentValue<short? []>(nullableInt16Array))))))), (source.GetCurrentValue<int?>(nullableInt32) == null ? null : ((ValueComparer<int?>)(((IProperty)nullableInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<int?>(nullableInt32))), (((IEnumerable<int?>)(source.GetCurrentValue<int? []>(nullableInt32Array))) == null ? null : ((int? [])(((ValueComparer<IEnumerable<int?>>)(((IProperty)nullableInt32Array).GetValueComparer())).Snapshot(((IEnumerable<int?>)(source.GetCurrentValue<int? []>(nullableInt32Array))))))), (source.GetCurrentValue<long?>(nullableInt64) == null ? null : ((ValueComparer<long?>)(((IProperty)nullableInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<long?>(nullableInt64))), (((IEnumerable<long?>)(source.GetCurrentValue<long? []>(nullableInt64Array))) == null ? null : ((long? [])(((ValueComparer<IEnumerable<long?>>)(((IProperty)nullableInt64Array).GetValueComparer())).Snapshot(((IEnumerable<long?>)(source.GetCurrentValue<long? []>(nullableInt64Array))))))))));
                    var structuralType5 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg5 = ((ISnapshot)(new Snapshot<sbyte?, sbyte? [], PhysicalAddress, PhysicalAddress[], string, string[], TimeOnly?, TimeOnly? [], TimeSpan?, TimeSpan? [], ushort?, ushort? [], uint?, uint? [], ulong?, ulong? [], byte?, byte? [], Uri, Uri[], PhysicalAddress, PhysicalAddress[], PhysicalAddress, PhysicalAddress, string, string[], IReadOnlyCollection<string>, string, string, string>((source.GetCurrentValue<sbyte?>(nullableInt8) == null ? null : ((ValueComparer<sbyte?>)(((IProperty)nullableInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<sbyte?>(nullableInt8))), (((IEnumerable<sbyte?>)(source.GetCurrentValue<sbyte? []>(nullableInt8Array))) == null ? null : ((sbyte? [])(((ValueComparer<IEnumerable<sbyte?>>)(((IProperty)nullableInt8Array).GetValueComparer())).Snapshot(((IEnumerable<sbyte?>)(source.GetCurrentValue<sbyte? []>(nullableInt8Array))))))), (source.GetCurrentValue<PhysicalAddress>(nullablePhysicalAddress) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)nullablePhysicalAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(nullablePhysicalAddress))), (((object)(source.GetCurrentValue<PhysicalAddress[]>(nullablePhysicalAddressArray))) == null ? null : ((PhysicalAddress[])(((ValueComparer<object>)(((IProperty)nullablePhysicalAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<PhysicalAddress[]>(nullablePhysicalAddressArray))))))), (source.GetCurrentValue<string>(nullableString) == null ? null : ((ValueComparer<string>)(((IProperty)nullableString).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(nullableString))), (((object)(source.GetCurrentValue<string[]>(nullableStringArray))) == null ? null : ((string[])(((ValueComparer<object>)(((IProperty)nullableStringArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[]>(nullableStringArray))))))), (source.GetCurrentValue<TimeOnly?>(nullableTimeOnly) == null ? null : ((ValueComparer<TimeOnly?>)(((IProperty)nullableTimeOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly?>(nullableTimeOnly))), (((IEnumerable<TimeOnly?>)(source.GetCurrentValue<TimeOnly? []>(nullableTimeOnlyArray))) == null ? null : ((TimeOnly? [])(((ValueComparer<IEnumerable<TimeOnly?>>)(((IProperty)nullableTimeOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<TimeOnly?>)(source.GetCurrentValue<TimeOnly? []>(nullableTimeOnlyArray))))))), (source.GetCurrentValue<TimeSpan?>(nullableTimeSpan) == null ? null : ((ValueComparer<TimeSpan?>)(((IProperty)nullableTimeSpan).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan?>(nullableTimeSpan))), (((IEnumerable<TimeSpan?>)(source.GetCurrentValue<TimeSpan? []>(nullableTimeSpanArray))) == null ? null : ((TimeSpan? [])(((ValueComparer<IEnumerable<TimeSpan?>>)(((IProperty)nullableTimeSpanArray).GetValueComparer())).Snapshot(((IEnumerable<TimeSpan?>)(source.GetCurrentValue<TimeSpan? []>(nullableTimeSpanArray))))))), (source.GetCurrentValue<ushort?>(nullableUInt16) == null ? null : ((ValueComparer<ushort?>)(((IProperty)nullableUInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort?>(nullableUInt16))), (((IEnumerable<ushort?>)(source.GetCurrentValue<ushort? []>(nullableUInt16Array))) == null ? null : ((ushort? [])(((ValueComparer<IEnumerable<ushort?>>)(((IProperty)nullableUInt16Array).GetValueComparer())).Snapshot(((IEnumerable<ushort?>)(source.GetCurrentValue<ushort? []>(nullableUInt16Array))))))), (source.GetCurrentValue<uint?>(nullableUInt32) == null ? null : ((ValueComparer<uint?>)(((IProperty)nullableUInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<uint?>(nullableUInt32))), (((IEnumerable<uint?>)(source.GetCurrentValue<uint? []>(nullableUInt32Array))) == null ? null : ((uint? [])(((ValueComparer<IEnumerable<uint?>>)(((IProperty)nullableUInt32Array).GetValueComparer())).Snapshot(((IEnumerable<uint?>)(source.GetCurrentValue<uint? []>(nullableUInt32Array))))))), (source.GetCurrentValue<ulong?>(nullableUInt64) == null ? null : ((ValueComparer<ulong?>)(((IProperty)nullableUInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong?>(nullableUInt64))), (((IEnumerable<ulong?>)(source.GetCurrentValue<ulong? []>(nullableUInt64Array))) == null ? null : ((ulong? [])(((ValueComparer<IEnumerable<ulong?>>)(((IProperty)nullableUInt64Array).GetValueComparer())).Snapshot(((IEnumerable<ulong?>)(source.GetCurrentValue<ulong? []>(nullableUInt64Array))))))), (source.GetCurrentValue<byte?>(nullableUInt8) == null ? null : ((ValueComparer<byte?>)(((IProperty)nullableUInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<byte?>(nullableUInt8))), (((IEnumerable<byte?>)(source.GetCurrentValue<byte? []>(nullableUInt8Array))) == null ? null : ((byte? [])(((ValueComparer<IEnumerable<byte?>>)(((IProperty)nullableUInt8Array).GetValueComparer())).Snapshot(((IEnumerable<byte?>)(source.GetCurrentValue<byte? []>(nullableUInt8Array))))))), (source.GetCurrentValue<Uri>(nullableUri) == null ? null : ((ValueComparer<Uri>)(((IProperty)nullableUri).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(nullableUri))), (((object)(source.GetCurrentValue<Uri[]>(nullableUriArray))) == null ? null : ((Uri[])(((ValueComparer<object>)(((IProperty)nullableUriArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<Uri[]>(nullableUriArray))))))), (source.GetCurrentValue<PhysicalAddress>(physicalAddress) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)physicalAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(physicalAddress))), (((object)(source.GetCurrentValue<PhysicalAddress[]>(physicalAddressArray))) == null ? null : ((PhysicalAddress[])(((ValueComparer<object>)(((IProperty)physicalAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<PhysicalAddress[]>(physicalAddressArray))))))), (source.GetCurrentValue<PhysicalAddress>(physicalAddressToBytesConverterProperty) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)physicalAddressToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(physicalAddressToBytesConverterProperty))), (source.GetCurrentValue<PhysicalAddress>(physicalAddressToStringConverterProperty) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)physicalAddressToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(physicalAddressToStringConverterProperty))), (source.GetCurrentValue<string>(@string) == null ? null : ((ValueComparer<string>)(((IProperty)@string).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(@string))), (((object)(source.GetCurrentValue<string[]>(stringArray))) == null ? null : ((string[])(((ValueComparer<object>)(((IProperty)stringArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[]>(stringArray))))))), (((object)(source.GetCurrentValue<IReadOnlyCollection<string>>(stringReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<string>)(((ValueComparer<object>)(((IProperty)stringReadOnlyCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IReadOnlyCollection<string>>(stringReadOnlyCollection))))))), (source.GetCurrentValue<string>(stringToBoolConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToBoolConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToBoolConverterProperty))), (source.GetCurrentValue<string>(stringToBytesConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToBytesConverterProperty))), (source.GetCurrentValue<string>(stringToCharConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToCharConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToCharConverterProperty))))));
                    var structuralType6 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    var liftedArg6 = ((ISnapshot)(new Snapshot<string, string, string, string, string, string, string, string, string, string, string, TimeOnly, TimeOnly[], TimeOnly, TimeOnly, TimeSpan, TimeSpan[], TimeSpan, TimeSpan, ushort, ushort[], uint, uint[], ulong, ulong[], byte, byte[], IReadOnlyCollection<byte>, Uri, Uri[]>((source.GetCurrentValue<string>(stringToDateOnlyConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDateOnlyConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDateOnlyConverterProperty))), (source.GetCurrentValue<string>(stringToDateTimeConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDateTimeConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDateTimeConverterProperty))), (source.GetCurrentValue<string>(stringToDateTimeOffsetConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDateTimeOffsetConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDateTimeOffsetConverterProperty))), (source.GetCurrentValue<string>(stringToDecimalNumberConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDecimalNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDecimalNumberConverterProperty))), (source.GetCurrentValue<string>(stringToDoubleNumberConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDoubleNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDoubleNumberConverterProperty))), (source.GetCurrentValue<string>(stringToEnumConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToEnumConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToEnumConverterProperty))), (source.GetCurrentValue<string>(stringToGuidConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToGuidConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToGuidConverterProperty))), (source.GetCurrentValue<string>(stringToIntNumberConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToIntNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToIntNumberConverterProperty))), (source.GetCurrentValue<string>(stringToTimeOnlyConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToTimeOnlyConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToTimeOnlyConverterProperty))), (source.GetCurrentValue<string>(stringToTimeSpanConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToTimeSpanConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToTimeSpanConverterProperty))), (source.GetCurrentValue<string>(stringToUriConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToUriConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToUriConverterProperty))), ((ValueComparer<TimeOnly>)(((IProperty)timeOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnly)), (((IEnumerable<TimeOnly>)(source.GetCurrentValue<TimeOnly[]>(timeOnlyArray))) == null ? null : ((TimeOnly[])(((ValueComparer<IEnumerable<TimeOnly>>)(((IProperty)timeOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<TimeOnly>)(source.GetCurrentValue<TimeOnly[]>(timeOnlyArray))))))), ((ValueComparer<TimeOnly>)(((IProperty)timeOnlyToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnlyToStringConverterProperty)), ((ValueComparer<TimeOnly>)(((IProperty)timeOnlyToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnlyToTicksConverterProperty)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpan).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpan)), (((IEnumerable<TimeSpan>)(source.GetCurrentValue<TimeSpan[]>(timeSpanArray))) == null ? null : ((TimeSpan[])(((ValueComparer<IEnumerable<TimeSpan>>)(((IProperty)timeSpanArray).GetValueComparer())).Snapshot(((IEnumerable<TimeSpan>)(source.GetCurrentValue<TimeSpan[]>(timeSpanArray))))))), ((ValueComparer<TimeSpan>)(((IProperty)timeSpanToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpanToStringConverterProperty)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpanToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpanToTicksConverterProperty)), ((ValueComparer<ushort>)(((IProperty)uInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(uInt16)), (((IEnumerable<ushort>)(source.GetCurrentValue<ushort[]>(uInt16Array))) == null ? null : ((ushort[])(((ValueComparer<IEnumerable<ushort>>)(((IProperty)uInt16Array).GetValueComparer())).Snapshot(((IEnumerable<ushort>)(source.GetCurrentValue<ushort[]>(uInt16Array))))))), ((ValueComparer<uint>)(((IProperty)uInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(uInt32)), (((IEnumerable<uint>)(source.GetCurrentValue<uint[]>(uInt32Array))) == null ? null : ((uint[])(((ValueComparer<IEnumerable<uint>>)(((IProperty)uInt32Array).GetValueComparer())).Snapshot(((IEnumerable<uint>)(source.GetCurrentValue<uint[]>(uInt32Array))))))), ((ValueComparer<ulong>)(((IProperty)uInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong>(uInt64)), (((IEnumerable<ulong>)(source.GetCurrentValue<ulong[]>(uInt64Array))) == null ? null : ((ulong[])(((ValueComparer<IEnumerable<ulong>>)(((IProperty)uInt64Array).GetValueComparer())).Snapshot(((IEnumerable<ulong>)(source.GetCurrentValue<ulong[]>(uInt64Array))))))), ((ValueComparer<byte>)(((IProperty)uInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<byte>(uInt8)), (source.GetCurrentValue<byte[]>(uInt8Array) == null ? null : ((ValueComparer<byte[]>)(((IProperty)uInt8Array).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(uInt8Array))), (((IEnumerable<byte>)(source.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)uInt8ReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection))))))), (source.GetCurrentValue<Uri>(uri) == null ? null : ((ValueComparer<Uri>)(((IProperty)uri).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(uri))), (((object)(source.GetCurrentValue<Uri[]>(uriArray))) == null ? null : ((Uri[])(((ValueComparer<object>)(((IProperty)uriArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<Uri[]>(uriArray))))))))));
                    var structuralType7 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    return ((ISnapshot)(new MultiSnapshot(new ISnapshot[] { liftedArg, liftedArg0, liftedArg1, liftedArg2, liftedArg3, liftedArg4, liftedArg5, liftedArg6, ((ISnapshot)(new Snapshot<Uri>((source.GetCurrentValue<Uri>(uriToStringConverterProperty) == null ? null : ((ValueComparer<Uri>)(((IProperty)uriToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(uriToStringConverterProperty)))))) })));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetValueComparer())).Snapshot(default(CompiledModelTestBase.ManyTypesId))))));
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (IInternalEntry source) => ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId>(default(CompiledModelTestBase.ManyTypesId)))));
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType8 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
                    return ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.ManyTypesId>(id)))));
                });
            runtimeEntityType.SetCounts(new PropertyCounts(
                propertyCount: 241,
                navigationCount: 0,
                complexPropertyCount: 0,
                complexCollectionCount: 0,
                originalValueCount: 241,
                shadowCount: 0,
                relationshipCount: 1,
                storeGeneratedCount: 1));
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyTypes");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
