// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using System.Text;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class ManyTypesEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
                typeof(CompiledModelTestBase.ManyTypes),
                baseEntityType,
                propertyCount: 236,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(CompiledModelTestBase.ManyTypesId),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueConverter: new CompiledModelTestBase.ManyTypesIdConverter());
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
                    (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
                    (CompiledModelTestBase.ManyTypesId v) => v.GetHashCode(),
                    (CompiledModelTestBase.ManyTypesId v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
                    (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
                    (CompiledModelTestBase.ManyTypesId v) => v.GetHashCode(),
                    (CompiledModelTestBase.ManyTypesId v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.ManyTypesId, int>(
                    (CompiledModelTestBase.ManyTypesId v) => v.Id,
                    (int v) => new CompiledModelTestBase.ManyTypesId(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.ManyTypesId, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.ManyTypesId, int>(
                        (CompiledModelTestBase.ManyTypesId v) => v.Id,
                        (int v) => new CompiledModelTestBase.ManyTypesId(v))));
            id.SetSentinelFromProviderValue(0);
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var @bool = runtimeEntityType.AddProperty(
                "Bool",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            @bool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v));
            @bool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolArray = runtimeEntityType.AddProperty(
                "BoolArray",
                typeof(bool[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                keyComparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v)));
            boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                "BoolToStringConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<bool, string>(
                    (bool v) => (string)(v ? "B" : "A"),
                    (string v) => !string.IsNullOrEmpty(v) && (int)v.ToUpperInvariant()[0] == (int)'B'),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<bool, string>(
                        (bool v) => (string)(v ? "B" : "A"),
                        (string v) => !string.IsNullOrEmpty(v) && (int)v.ToUpperInvariant()[0] == (int)'B')));
            boolToStringConverterProperty.SetSentinelFromProviderValue("A");
            boolToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolToTwoValuesConverterProperty = runtimeEntityType.AddProperty(
                "BoolToTwoValuesConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToTwoValuesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToTwoValuesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolToTwoValuesConverterProperty.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                converter: new ValueConverter<bool, byte>(
                    (bool v) => (byte)(v ? 1 : 0),
                    (byte v) => v == 1),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<bool, byte>(
                        (bool v) => (byte)(v ? 1 : 0),
                        (byte v) => v == 1)));
            boolToTwoValuesConverterProperty.SetSentinelFromProviderValue((byte)0);
            boolToTwoValuesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolToZeroOneConverterProperty = runtimeEntityType.AddProperty(
                "BoolToZeroOneConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToZeroOneConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToZeroOneConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new BoolToZeroOneConverter<short>());
            boolToZeroOneConverterProperty.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<bool, short>(
                    (bool v) => (short)(v ? 1 : 0),
                    (short v) => v == 1),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<bool, short>(
                        (bool v) => (short)(v ? 1 : 0),
                        (short v) => v == 1)));
            boolToZeroOneConverterProperty.SetSentinelFromProviderValue((short)0);
            boolToZeroOneConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytes = runtimeEntityType.AddProperty(
                "Bytes",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            bytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            bytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytesArray = runtimeEntityType.AddProperty(
                "BytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            bytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                "BytesToStringConverterProperty",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new BytesToStringConverter(),
                valueComparer: new ArrayStructuralComparer<byte>());
            bytesToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] v) => v.ToArray()),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] v) => v.ToArray()),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<byte[], string>(
                    (Byte[] v) => Convert.ToBase64String(v),
                    (string v) => Convert.FromBase64String(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<byte[], string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<byte[], string>(
                        (Byte[] v) => Convert.ToBase64String(v),
                        (string v) => Convert.FromBase64String(v))));
            bytesToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var castingConverterProperty = runtimeEntityType.AddProperty(
                "CastingConverterProperty",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CastingConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CastingConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new CastingConverter<int, decimal>());
            castingConverterProperty.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                converter: new ValueConverter<int, decimal>(
                    (int v) => (decimal)v,
                    (decimal v) => (int)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<int, decimal>(
                        (int v) => (decimal)v,
                        (decimal v) => (int)v)));
            castingConverterProperty.SetSentinelFromProviderValue(0m);
            castingConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @char = runtimeEntityType.AddProperty(
                "Char",
                typeof(char),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            @char.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            @char.SetSentinelFromProviderValue("\0");
            @char.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var charArray = runtimeEntityType.AddProperty(
                "CharArray",
                typeof(char[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            charArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                keyComparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionReaderWriter<char[], char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0])))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<char[], char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0]),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))));
            charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var charToStringConverterProperty = runtimeEntityType.AddProperty(
                "CharToStringConverterProperty",
                typeof(char),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new CharToStringConverter());
            charToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            charToStringConverterProperty.SetSentinelFromProviderValue("\0");
            charToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnly = runtimeEntityType.AddProperty(
                "DateOnly",
                typeof(DateOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v));
            dateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnlyArray = runtimeEntityType.AddProperty(
                "DateOnlyArray",
                typeof(DateOnly[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            dateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                keyComparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v)));
            dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateOnlyToStringConverterProperty",
                typeof(DateOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateOnlyToStringConverter());
            dateOnlyToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(10)",
                    size: 10,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<DateOnly, string>(
                    (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
                    (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateOnly, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateOnly, string>(
                        (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
                        (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
            dateOnlyToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01");
            dateOnlyToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTime = runtimeEntityType.AddProperty(
                "DateTime",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v));
            dateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeArray = runtimeEntityType.AddProperty(
                "DateTimeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            dateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToBinaryConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBinaryConverter());
            dateTimeOffsetToBinaryConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<DateTimeOffset, long>(
                    (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                    (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, long>(
                        (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                        (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v))));
            dateTimeOffsetToBinaryConverterProperty.SetSentinelFromProviderValue(0L);
            dateTimeOffsetToBinaryConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeOffsetToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToBytesConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBytesConverter());
            dateTimeOffsetToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(12)",
                    size: 12),
                converter: new ValueConverter<DateTimeOffset, byte[]>(
                    (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
                    (Byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, byte[]>(
                        (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
                        (Byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v))));
            dateTimeOffsetToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            dateTimeOffsetToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeOffsetToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToStringConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToStringConverter());
            dateTimeOffsetToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<DateTimeOffset, string>(
                    (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
                    (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, string>(
                        (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
                        (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture))));
            dateTimeOffsetToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00+00:00");
            dateTimeOffsetToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeToBinaryConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToBinaryConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeToBinaryConverter());
            dateTimeToBinaryConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<DateTime, long>(
                    (DateTime v) => v.ToBinary(),
                    (long v) => DateTime.FromBinary(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTime, long>(
                        (DateTime v) => v.ToBinary(),
                        (long v) => DateTime.FromBinary(v))));
            dateTimeToBinaryConverterProperty.SetSentinelFromProviderValue(0L);
            dateTimeToBinaryConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToStringConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeToStringConverter());
            dateTimeToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<DateTime, string>(
                    (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
                    (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateTime, string>(
                        (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
                        (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture))));
            dateTimeToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00");
            dateTimeToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeToTicksConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToTicksConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTimeToTicksConverterProperty.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v));
            dateTimeToTicksConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @decimal = runtimeEntityType.AddProperty(
                "Decimal",
                typeof(decimal),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0m);
            @decimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v));
            @decimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalArray = runtimeEntityType.AddProperty(
                "DecimalArray",
                typeof(decimal[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            decimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                keyComparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v)));
            decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DecimalNumberToBytesConverterProperty",
                typeof(decimal),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<decimal>());
            decimalNumberToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(16)",
                    size: 16),
                converter: new ValueConverter<decimal, byte[]>(
                    (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
                    (Byte[] v) => v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<decimal, byte[]>(
                        (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
                        (Byte[] v) => v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v))));
            decimalNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            decimalNumberToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "DecimalNumberToStringConverterProperty",
                typeof(decimal),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<decimal>());
            decimalNumberToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(64)",
                    size: 64,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<decimal, string>(
                    (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<decimal, string>(
                        (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            decimalNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
            decimalNumberToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @double = runtimeEntityType.AddProperty(
                "Double",
                typeof(double),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0.0);
            @double.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v));
            @double.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleArray = runtimeEntityType.AddProperty(
                "DoubleArray",
                typeof(double[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            doubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                keyComparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v)));
            doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DoubleNumberToBytesConverterProperty",
                typeof(double),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<double>());
            doubleNumberToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(8)",
                    size: 8),
                converter: new ValueConverter<double, byte[]>(
                    (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
                    (Byte[] v) => v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<double, byte[]>(
                        (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
                        (Byte[] v) => v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0))));
            doubleNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
            doubleNumberToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "DoubleNumberToStringConverterProperty",
                typeof(double),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<double>());
            doubleNumberToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(64)",
                    size: 64,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<double, string>(
                    (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v),
                    (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<double, string>(
                        (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v),
                        (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            doubleNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
            doubleNumberToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16 = runtimeEntityType.AddProperty(
                "Enum16",
                typeof(CompiledModelTestBase.Enum16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                    (CompiledModelTestBase.Enum16 value) => (short)value,
                    (short value) => (CompiledModelTestBase.Enum16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value)));
            enum16.SetSentinelFromProviderValue((short)0);
            enum16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16Array = runtimeEntityType.AddProperty(
                "Enum16Array",
                typeof(CompiledModelTestBase.Enum16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))));
            enum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16AsString = runtimeEntityType.AddProperty(
                "Enum16AsString",
                typeof(CompiledModelTestBase.Enum16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum16AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
                    (CompiledModelTestBase.Enum16 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, string>(
                        (CompiledModelTestBase.Enum16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))));
            enum16AsString.SetSentinelFromProviderValue("Default");
            enum16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16AsStringArray = runtimeEntityType.AddProperty(
                "Enum16AsStringArray",
                typeof(CompiledModelTestBase.Enum16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            (CompiledModelTestBase.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            (CompiledModelTestBase.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
                        (CompiledModelTestBase.Enum16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            (CompiledModelTestBase.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
            enum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16AsStringCollection = runtimeEntityType.AddProperty(
                "Enum16AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum16>, List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            (CompiledModelTestBase.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum16>, List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            (CompiledModelTestBase.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
                        (CompiledModelTestBase.Enum16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
                            (CompiledModelTestBase.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
            enum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum16Collection = runtimeEntityType.AddProperty(
                "Enum16Collection",
                typeof(List<CompiledModelTestBase.Enum16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
                    (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum16>, List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum16>, List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))));
            enum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32 = runtimeEntityType.AddProperty(
                "Enum32",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    (CompiledModelTestBase.Enum32 value) => (int)value,
                    (int value) => (CompiledModelTestBase.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value)));
            enum32.SetSentinelFromProviderValue(0);
            enum32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32Array = runtimeEntityType.AddProperty(
                "Enum32Array",
                typeof(CompiledModelTestBase.Enum32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))));
            enum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32AsString = runtimeEntityType.AddProperty(
                "Enum32AsString",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum32AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                    (CompiledModelTestBase.Enum32 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        (CompiledModelTestBase.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))));
            enum32AsString.SetSentinelFromProviderValue("Default");
            enum32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32AsStringArray = runtimeEntityType.AddProperty(
                "Enum32AsStringArray",
                typeof(CompiledModelTestBase.Enum32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            (CompiledModelTestBase.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            (CompiledModelTestBase.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        (CompiledModelTestBase.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            (CompiledModelTestBase.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
            enum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32AsStringCollection = runtimeEntityType.AddProperty(
                "Enum32AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            (CompiledModelTestBase.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            (CompiledModelTestBase.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        (CompiledModelTestBase.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
                            (CompiledModelTestBase.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
            enum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum32Collection = runtimeEntityType.AddProperty(
                "Enum32Collection",
                typeof(List<CompiledModelTestBase.Enum32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))));
            enum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64 = runtimeEntityType.AddProperty(
                "Enum64",
                typeof(CompiledModelTestBase.Enum64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                    (CompiledModelTestBase.Enum64 value) => (long)value,
                    (long value) => (CompiledModelTestBase.Enum64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value)));
            enum64.SetSentinelFromProviderValue(0L);
            enum64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64Array = runtimeEntityType.AddProperty(
                "Enum64Array",
                typeof(CompiledModelTestBase.Enum64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))));
            enum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64AsString = runtimeEntityType.AddProperty(
                "Enum64AsString",
                typeof(CompiledModelTestBase.Enum64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum64AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
                    (CompiledModelTestBase.Enum64 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, string>(
                        (CompiledModelTestBase.Enum64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))));
            enum64AsString.SetSentinelFromProviderValue("Default");
            enum64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64AsStringArray = runtimeEntityType.AddProperty(
                "Enum64AsStringArray",
                typeof(CompiledModelTestBase.Enum64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            (CompiledModelTestBase.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            (CompiledModelTestBase.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
                        (CompiledModelTestBase.Enum64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            (CompiledModelTestBase.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
            enum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64AsStringCollection = runtimeEntityType.AddProperty(
                "Enum64AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum64>, List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            (CompiledModelTestBase.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum64>, List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            (CompiledModelTestBase.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
                        (CompiledModelTestBase.Enum64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
                            (CompiledModelTestBase.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
            enum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum64Collection = runtimeEntityType.AddProperty(
                "Enum64Collection",
                typeof(List<CompiledModelTestBase.Enum64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
                    (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum64>, List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum64>, List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))));
            enum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8 = runtimeEntityType.AddProperty(
                "Enum8",
                typeof(CompiledModelTestBase.Enum8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                    (CompiledModelTestBase.Enum8 value) => (short)value,
                    (short value) => (CompiledModelTestBase.Enum8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value)));
            enum8.SetSentinelFromProviderValue((short)0);
            enum8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8Array = runtimeEntityType.AddProperty(
                "Enum8Array",
                typeof(CompiledModelTestBase.Enum8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))));
            enum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8AsString = runtimeEntityType.AddProperty(
                "Enum8AsString",
                typeof(CompiledModelTestBase.Enum8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum8AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
                    (CompiledModelTestBase.Enum8 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, string>(
                        (CompiledModelTestBase.Enum8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))));
            enum8AsString.SetSentinelFromProviderValue("Default");
            enum8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8AsStringArray = runtimeEntityType.AddProperty(
                "Enum8AsStringArray",
                typeof(CompiledModelTestBase.Enum8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            (CompiledModelTestBase.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            (CompiledModelTestBase.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
                        (CompiledModelTestBase.Enum8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            (CompiledModelTestBase.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
            enum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8AsStringCollection = runtimeEntityType.AddProperty(
                "Enum8AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum8>, List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            (CompiledModelTestBase.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum8>, List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            (CompiledModelTestBase.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
                        (CompiledModelTestBase.Enum8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
                            (CompiledModelTestBase.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
            enum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum8Collection = runtimeEntityType.AddProperty(
                "Enum8Collection",
                typeof(List<CompiledModelTestBase.Enum8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
                    (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum8>, List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.Enum8>, List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))));
            enum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                "EnumToNumberConverterProperty",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumToNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumToNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new EnumToNumberConverter<CompiledModelTestBase.Enum32, int>());
            enumToNumberConverterProperty.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    (CompiledModelTestBase.Enum32 value) => (int)value,
                    (int value) => (CompiledModelTestBase.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value)));
            enumToNumberConverterProperty.SetSentinelFromProviderValue(0);
            enumToNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumToStringConverterProperty = runtimeEntityType.AddProperty(
                "EnumToStringConverterProperty",
                typeof(CompiledModelTestBase.Enum32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new EnumToStringConverter<CompiledModelTestBase.Enum32>());
            enumToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                    (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.Enum32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
                    (CompiledModelTestBase.Enum32 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, string>(
                        (CompiledModelTestBase.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))));
            enumToStringConverterProperty.SetSentinelFromProviderValue("Default");
            enumToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16 = runtimeEntityType.AddProperty(
                "EnumU16",
                typeof(CompiledModelTestBase.EnumU16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                    (CompiledModelTestBase.EnumU16 value) => (int)value,
                    (int value) => (CompiledModelTestBase.EnumU16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value)));
            enumU16.SetSentinelFromProviderValue(0);
            enumU16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16Array = runtimeEntityType.AddProperty(
                "EnumU16Array",
                typeof(CompiledModelTestBase.EnumU16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))));
            enumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16AsString = runtimeEntityType.AddProperty(
                "EnumU16AsString",
                typeof(CompiledModelTestBase.EnumU16),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU16AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                    (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                        (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))));
            enumU16AsString.SetSentinelFromProviderValue("Min");
            enumU16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16AsStringArray = runtimeEntityType.AddProperty(
                "EnumU16AsStringArray",
                typeof(CompiledModelTestBase.EnumU16[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                        (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
            enumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU16AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU16>, List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU16>, List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                        (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                            (CompiledModelTestBase.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
            enumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU16Collection = runtimeEntityType.AddProperty(
                "EnumU16Collection",
                typeof(List<CompiledModelTestBase.EnumU16>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
                    (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU16>, List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU16>, List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))));
            enumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32 = runtimeEntityType.AddProperty(
                "EnumU32",
                typeof(CompiledModelTestBase.EnumU32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                    (CompiledModelTestBase.EnumU32 value) => (long)value,
                    (long value) => (CompiledModelTestBase.EnumU32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value)));
            enumU32.SetSentinelFromProviderValue(0L);
            enumU32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32Array = runtimeEntityType.AddProperty(
                "EnumU32Array",
                typeof(CompiledModelTestBase.EnumU32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))));
            enumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32AsString = runtimeEntityType.AddProperty(
                "EnumU32AsString",
                typeof(CompiledModelTestBase.EnumU32),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU32AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                    (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                        (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))));
            enumU32AsString.SetSentinelFromProviderValue("Min");
            enumU32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32AsStringArray = runtimeEntityType.AddProperty(
                "EnumU32AsStringArray",
                typeof(CompiledModelTestBase.EnumU32[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                        (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
            enumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU32AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU32>, List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU32>, List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                        (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                            (CompiledModelTestBase.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
            enumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU32Collection = runtimeEntityType.AddProperty(
                "EnumU32Collection",
                typeof(List<CompiledModelTestBase.EnumU32>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
                    (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU32>, List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU32>, List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))));
            enumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64 = runtimeEntityType.AddProperty(
                "EnumU64",
                typeof(CompiledModelTestBase.EnumU64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                    (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                    (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)));
            enumU64.SetSentinelFromProviderValue(0m);
            enumU64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64Array = runtimeEntityType.AddProperty(
                "EnumU64Array",
                typeof(CompiledModelTestBase.EnumU64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))));
            enumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64AsString = runtimeEntityType.AddProperty(
                "EnumU64AsString",
                typeof(CompiledModelTestBase.EnumU64),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU64AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                    (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                        (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))));
            enumU64AsString.SetSentinelFromProviderValue("Min");
            enumU64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64AsStringArray = runtimeEntityType.AddProperty(
                "EnumU64AsStringArray",
                typeof(CompiledModelTestBase.EnumU64[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                        (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
            enumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU64AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU64>, List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU64>, List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                        (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                            (CompiledModelTestBase.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
            enumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU64Collection = runtimeEntityType.AddProperty(
                "EnumU64Collection",
                typeof(List<CompiledModelTestBase.EnumU64>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
                    (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU64>, List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU64>, List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))));
            enumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8 = runtimeEntityType.AddProperty(
                "EnumU8",
                typeof(CompiledModelTestBase.EnumU8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                    (CompiledModelTestBase.EnumU8 value) => (byte)value,
                    (byte value) => (CompiledModelTestBase.EnumU8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value)));
            enumU8.SetSentinelFromProviderValue((byte)0);
            enumU8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8Array = runtimeEntityType.AddProperty(
                "EnumU8Array",
                typeof(CompiledModelTestBase.EnumU8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))));
            enumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8AsString = runtimeEntityType.AddProperty(
                "EnumU8AsString",
                typeof(CompiledModelTestBase.EnumU8),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU8AsString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                    (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                    (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                        (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))));
            enumU8AsString.SetSentinelFromProviderValue("Min");
            enumU8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8AsStringArray = runtimeEntityType.AddProperty(
                "EnumU8AsStringArray",
                typeof(CompiledModelTestBase.EnumU8[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                        (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
            enumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU8AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU8>, List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU8>, List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                        (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                            (CompiledModelTestBase.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
            enumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumU8Collection = runtimeEntityType.AddProperty(
                "EnumU8Collection",
                typeof(List<CompiledModelTestBase.EnumU8>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                keyComparer: new ListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
                    (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                    (CompiledModelTestBase.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU8>, List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CompiledModelTestBase.EnumU8>, List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))));
            enumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @float = runtimeEntityType.AddProperty(
                "Float",
                typeof(float),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0f);
            @float.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v));
            @float.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var floatArray = runtimeEntityType.AddProperty(
                "FloatArray",
                typeof(float[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            floatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                keyComparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v)));
            floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guid = runtimeEntityType.AddProperty(
                "Guid",
                typeof(Guid),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            guid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            guid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidArray = runtimeEntityType.AddProperty(
                "GuidArray",
                typeof(Guid[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            guidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                keyComparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                "GuidToBytesConverterProperty",
                typeof(Guid),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new GuidToBytesConverter());
            guidToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(16)",
                    size: 16),
                converter: new ValueConverter<Guid, byte[]>(
                    (Guid v) => v.ToByteArray(),
                    (Byte[] v) => new Guid(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<Guid, byte[]>(
                        (Guid v) => v.ToByteArray(),
                        (Byte[] v) => new Guid(v))));
            guidToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            guidToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidToStringConverterProperty = runtimeEntityType.AddProperty(
                "GuidToStringConverterProperty",
                typeof(Guid),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new GuidToStringConverter());
            guidToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(36)",
                    size: 36,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Guid, string>(
                    (Guid v) => v.ToString("D"),
                    (string v) => new Guid(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Guid, string>(
                        (Guid v) => v.ToString("D"),
                        (string v) => new Guid(v))));
            guidToStringConverterProperty.SetSentinelFromProviderValue("00000000-0000-0000-0000-000000000000");
            guidToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddress = runtimeEntityType.AddProperty(
                "IPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            iPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            iPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressArray = runtimeEntityType.AddProperty(
                "IPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            iPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                "IPAddressToBytesConverterProperty",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new IPAddressToBytesConverter());
            iPAddressToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(16)",
                    size: 16),
                converter: new ValueConverter<IPAddress, byte[]>(
                    (IPAddress v) => v.GetAddressBytes(),
                    (Byte[] v) => new IPAddress(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<IPAddress, byte[]>(
                        (IPAddress v) => v.GetAddressBytes(),
                        (Byte[] v) => new IPAddress(v))));
            iPAddressToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                "IPAddressToStringConverterProperty",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new IPAddressToStringConverter());
            iPAddressToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            iPAddressToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16 = runtimeEntityType.AddProperty(
                "Int16",
                typeof(short),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (short)0);
            int16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                keyComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v));
            int16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16Array = runtimeEntityType.AddProperty(
                "Int16Array",
                typeof(short[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32 = runtimeEntityType.AddProperty(
                "Int32",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            int32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            int32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32Array = runtimeEntityType.AddProperty(
                "Int32Array",
                typeof(int[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                keyComparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v)));
            int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64 = runtimeEntityType.AddProperty(
                "Int64",
                typeof(long),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0L);
            int64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            int64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64Array = runtimeEntityType.AddProperty(
                "Int64Array",
                typeof(long[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                keyComparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v)));
            int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8 = runtimeEntityType.AddProperty(
                "Int8",
                typeof(sbyte),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    (sbyte v) => (short)v,
                    (short v) => (sbyte)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v)));
            int8.SetSentinelFromProviderValue((short)0);
            int8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8Array = runtimeEntityType.AddProperty(
                "Int8Array",
                typeof(sbyte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            int8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                keyComparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))));
            int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "IntNumberToBytesConverterProperty",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IntNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IntNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<int>());
            intNumberToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(4)",
                    size: 4),
                converter: new ValueConverter<int, byte[]>(
                    (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
                    (Byte[] v) => v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt(v.Length == 0 ? new byte[4] : v), 0)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<int, byte[]>(
                        (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
                        (Byte[] v) => v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt(v.Length == 0 ? new byte[4] : v), 0))));
            intNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0 });
            intNumberToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var intNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "IntNumberToStringConverterProperty",
                typeof(int),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IntNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IntNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<int>());
            intNumberToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(64)",
                    size: 64,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<int, string>(
                    (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<int, string>(
                        (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            intNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
            intNumberToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullIntToNullStringConverterProperty = runtimeEntityType.AddProperty(
                "NullIntToNullStringConverterProperty",
                typeof(int?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullIntToNullStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullIntToNullStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new CompiledModelTestBase.NullIntToNullStringConverter());
            nullIntToNullStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1 == v2,
                    (Nullable<int> v) => (int)v,
                    (Nullable<int> v) => v),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1 == v2,
                    (Nullable<int> v) => (int)v,
                    (Nullable<int> v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<int?, string>(
                    (Nullable<int> v) => v == null ? null : v.ToString(),
                    (string v) => v == null || v == "<null>" ? null : (Nullable<int>)int.Parse(v),
                    convertsNulls: true),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int?, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<int?, string>(
                        (Nullable<int> v) => v == null ? null : v.ToString(),
                        (string v) => v == null || v == "<null>" ? null : (Nullable<int>)int.Parse(v),
                        convertsNulls: true)));
            nullIntToNullStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBool = runtimeEntityType.AddProperty(
                "NullableBool",
                typeof(bool?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)));
            nullableBool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBoolArray = runtimeEntityType.AddProperty(
                "NullableBoolArray",
                typeof(bool?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableBoolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                keyComparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool?>(new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v)));
            nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytes = runtimeEntityType.AddProperty(
                "NullableBytes",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            nullableBytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytesArray = runtimeEntityType.AddProperty(
                "NullableBytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableBytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableChar = runtimeEntityType.AddProperty(
                "NullableChar",
                typeof(char?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableChar.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                keyComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            nullableChar.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableCharArray = runtimeEntityType.AddProperty(
                "NullableCharArray",
                typeof(char?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableCharArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                keyComparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char?>(new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0])))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0]),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))));
            nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnly = runtimeEntityType.AddProperty(
                "NullableDateOnly",
                typeof(DateOnly?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)),
                keyComparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)),
                providerValueComparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)));
            nullableDateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                "NullableDateOnlyArray",
                typeof(DateOnly?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                keyComparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v)));
            nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTime = runtimeEntityType.AddProperty(
                "NullableDateTime",
                typeof(DateTime?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)),
                keyComparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)),
                providerValueComparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)));
            nullableDateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTimeArray = runtimeEntityType.AddProperty(
                "NullableDateTimeArray",
                typeof(DateTime?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                keyComparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimal = runtimeEntityType.AddProperty(
                "NullableDecimal",
                typeof(decimal?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)),
                keyComparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)),
                providerValueComparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)));
            nullableDecimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimalArray = runtimeEntityType.AddProperty(
                "NullableDecimalArray",
                typeof(decimal?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDecimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                keyComparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal?>(new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v)));
            nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDouble = runtimeEntityType.AddProperty(
                "NullableDouble",
                typeof(double?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDouble.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            nullableDouble.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDoubleArray = runtimeEntityType.AddProperty(
                "NullableDoubleArray",
                typeof(double?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableDoubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                keyComparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double?>(new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v)));
            nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16 = runtimeEntityType.AddProperty(
                "NullableEnum16",
                typeof(CompiledModelTestBase.Enum16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                    (CompiledModelTestBase.Enum16 value) => (short)value,
                    (short value) => (CompiledModelTestBase.Enum16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value)));
            nullableEnum16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16Array = runtimeEntityType.AddProperty(
                "NullableEnum16Array",
                typeof(CompiledModelTestBase.Enum16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))));
            nullableEnum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16AsString = runtimeEntityType.AddProperty(
                "NullableEnum16AsString",
                typeof(CompiledModelTestBase.Enum16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16AsString.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                    (CompiledModelTestBase.Enum16 value) => (short)value,
                    (short value) => (CompiledModelTestBase.Enum16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value)));
            nullableEnum16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum16AsStringArray",
                typeof(CompiledModelTestBase.Enum16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))));
            nullableEnum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum16AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum16?>, List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum16?>, List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))));
            nullableEnum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum16Collection = runtimeEntityType.AddProperty(
                "NullableEnum16Collection",
                typeof(List<CompiledModelTestBase.Enum16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16?>(
                    (Nullable<CompiledModelTestBase.Enum16> v1, Nullable<CompiledModelTestBase.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum16)v1, (object)(CompiledModelTestBase.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? ((CompiledModelTestBase.Enum16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum16>)(CompiledModelTestBase.Enum16)v : default(Nullable<CompiledModelTestBase.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum16?>, List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum16?>, List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
                        (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum16, short>(
                        (CompiledModelTestBase.Enum16 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum16, short>(
                            (CompiledModelTestBase.Enum16 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum16)value))));
            nullableEnum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32 = runtimeEntityType.AddProperty(
                "NullableEnum32",
                typeof(CompiledModelTestBase.Enum32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    (CompiledModelTestBase.Enum32 value) => (int)value,
                    (int value) => (CompiledModelTestBase.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value)));
            nullableEnum32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32Array = runtimeEntityType.AddProperty(
                "NullableEnum32Array",
                typeof(CompiledModelTestBase.Enum32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))));
            nullableEnum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32AsString = runtimeEntityType.AddProperty(
                "NullableEnum32AsString",
                typeof(CompiledModelTestBase.Enum32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32AsString.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                    (CompiledModelTestBase.Enum32 value) => (int)value,
                    (int value) => (CompiledModelTestBase.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value)));
            nullableEnum32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum32AsStringArray",
                typeof(CompiledModelTestBase.Enum32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))));
            nullableEnum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum32AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum32?>, List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum32?>, List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))));
            nullableEnum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum32Collection = runtimeEntityType.AddProperty(
                "NullableEnum32Collection",
                typeof(List<CompiledModelTestBase.Enum32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32?>(
                    (Nullable<CompiledModelTestBase.Enum32> v1, Nullable<CompiledModelTestBase.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum32)v1, (object)(CompiledModelTestBase.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? ((CompiledModelTestBase.Enum32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum32>)(CompiledModelTestBase.Enum32)v : default(Nullable<CompiledModelTestBase.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum32?>, List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum32?>, List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
                        (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
                        (CompiledModelTestBase.Enum32 value) => (int)value,
                        (int value) => (CompiledModelTestBase.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum32, int>(
                            (CompiledModelTestBase.Enum32 value) => (int)value,
                            (int value) => (CompiledModelTestBase.Enum32)value))));
            nullableEnum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64 = runtimeEntityType.AddProperty(
                "NullableEnum64",
                typeof(CompiledModelTestBase.Enum64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                    (CompiledModelTestBase.Enum64 value) => (long)value,
                    (long value) => (CompiledModelTestBase.Enum64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value)));
            nullableEnum64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64Array = runtimeEntityType.AddProperty(
                "NullableEnum64Array",
                typeof(CompiledModelTestBase.Enum64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))));
            nullableEnum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64AsString = runtimeEntityType.AddProperty(
                "NullableEnum64AsString",
                typeof(CompiledModelTestBase.Enum64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64AsString.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                    (CompiledModelTestBase.Enum64 value) => (long)value,
                    (long value) => (CompiledModelTestBase.Enum64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value)));
            nullableEnum64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum64AsStringArray",
                typeof(CompiledModelTestBase.Enum64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))));
            nullableEnum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum64AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum64?>, List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum64?>, List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))));
            nullableEnum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum64Collection = runtimeEntityType.AddProperty(
                "NullableEnum64Collection",
                typeof(List<CompiledModelTestBase.Enum64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64?>(
                    (Nullable<CompiledModelTestBase.Enum64> v1, Nullable<CompiledModelTestBase.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum64)v1, (object)(CompiledModelTestBase.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? ((CompiledModelTestBase.Enum64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum64>)(CompiledModelTestBase.Enum64)v : default(Nullable<CompiledModelTestBase.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum64?>, List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum64?>, List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
                        (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum64, long>(
                        (CompiledModelTestBase.Enum64 value) => (long)value,
                        (long value) => (CompiledModelTestBase.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum64, long>(
                            (CompiledModelTestBase.Enum64 value) => (long)value,
                            (long value) => (CompiledModelTestBase.Enum64)value))));
            nullableEnum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8 = runtimeEntityType.AddProperty(
                "NullableEnum8",
                typeof(CompiledModelTestBase.Enum8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                    (CompiledModelTestBase.Enum8 value) => (short)value,
                    (short value) => (CompiledModelTestBase.Enum8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value)));
            nullableEnum8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8Array = runtimeEntityType.AddProperty(
                "NullableEnum8Array",
                typeof(CompiledModelTestBase.Enum8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))));
            nullableEnum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8AsString = runtimeEntityType.AddProperty(
                "NullableEnum8AsString",
                typeof(CompiledModelTestBase.Enum8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8AsString.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                    (CompiledModelTestBase.Enum8 value) => (short)value,
                    (short value) => (CompiledModelTestBase.Enum8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value)));
            nullableEnum8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum8AsStringArray",
                typeof(CompiledModelTestBase.Enum8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))));
            nullableEnum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum8AsStringCollection",
                typeof(List<CompiledModelTestBase.Enum8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum8?>, List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum8?>, List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))));
            nullableEnum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnum8Collection = runtimeEntityType.AddProperty(
                "NullableEnum8Collection",
                typeof(List<CompiledModelTestBase.Enum8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnum8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8?>(
                    (Nullable<CompiledModelTestBase.Enum8> v1, Nullable<CompiledModelTestBase.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.Enum8)v1, (object)(CompiledModelTestBase.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? ((CompiledModelTestBase.Enum8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.Enum8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.Enum8>)(CompiledModelTestBase.Enum8)v : default(Nullable<CompiledModelTestBase.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum8?>, List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.Enum8?>, List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
                        (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.Enum8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.Enum8, short>(
                        (CompiledModelTestBase.Enum8 value) => (short)value,
                        (short value) => (CompiledModelTestBase.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.Enum8, short>(
                            (CompiledModelTestBase.Enum8 value) => (short)value,
                            (short value) => (CompiledModelTestBase.Enum8)value))));
            nullableEnum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16 = runtimeEntityType.AddProperty(
                "NullableEnumU16",
                typeof(CompiledModelTestBase.EnumU16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                    (CompiledModelTestBase.EnumU16 value) => (int)value,
                    (int value) => (CompiledModelTestBase.EnumU16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value)));
            nullableEnumU16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16Array = runtimeEntityType.AddProperty(
                "NullableEnumU16Array",
                typeof(CompiledModelTestBase.EnumU16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))));
            nullableEnumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                "NullableEnumU16AsString",
                typeof(CompiledModelTestBase.EnumU16?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16AsString.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                    (CompiledModelTestBase.EnumU16 value) => (int)value,
                    (int value) => (CompiledModelTestBase.EnumU16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value)));
            nullableEnumU16AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU16AsStringArray",
                typeof(CompiledModelTestBase.EnumU16?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))));
            nullableEnumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU16AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU16?>, List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU16?>, List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))));
            nullableEnumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                "NullableEnumU16Collection",
                typeof(List<CompiledModelTestBase.EnumU16?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU16Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16?>(
                    (Nullable<CompiledModelTestBase.EnumU16> v1, Nullable<CompiledModelTestBase.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU16)v1, (object)(CompiledModelTestBase.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? ((CompiledModelTestBase.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU16> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU16>)(CompiledModelTestBase.EnumU16)v : default(Nullable<CompiledModelTestBase.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU16?>, List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU16?>, List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
                        (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU16 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                        (CompiledModelTestBase.EnumU16 value) => (int)value,
                        (int value) => (CompiledModelTestBase.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                            (CompiledModelTestBase.EnumU16 value) => (int)value,
                            (int value) => (CompiledModelTestBase.EnumU16)value))));
            nullableEnumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32 = runtimeEntityType.AddProperty(
                "NullableEnumU32",
                typeof(CompiledModelTestBase.EnumU32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                    (CompiledModelTestBase.EnumU32 value) => (long)value,
                    (long value) => (CompiledModelTestBase.EnumU32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value)));
            nullableEnumU32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32Array = runtimeEntityType.AddProperty(
                "NullableEnumU32Array",
                typeof(CompiledModelTestBase.EnumU32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))));
            nullableEnumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                "NullableEnumU32AsString",
                typeof(CompiledModelTestBase.EnumU32?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32AsString.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                    (CompiledModelTestBase.EnumU32 value) => (long)value,
                    (long value) => (CompiledModelTestBase.EnumU32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value)));
            nullableEnumU32AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU32AsStringArray",
                typeof(CompiledModelTestBase.EnumU32?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))));
            nullableEnumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU32AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU32?>, List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU32?>, List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))));
            nullableEnumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                "NullableEnumU32Collection",
                typeof(List<CompiledModelTestBase.EnumU32?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU32Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32?>(
                    (Nullable<CompiledModelTestBase.EnumU32> v1, Nullable<CompiledModelTestBase.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU32)v1, (object)(CompiledModelTestBase.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? ((CompiledModelTestBase.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU32> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU32>)(CompiledModelTestBase.EnumU32)v : default(Nullable<CompiledModelTestBase.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU32?>, List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU32?>, List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
                        (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU32 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                        (CompiledModelTestBase.EnumU32 value) => (long)value,
                        (long value) => (CompiledModelTestBase.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                            (CompiledModelTestBase.EnumU32 value) => (long)value,
                            (long value) => (CompiledModelTestBase.EnumU32)value))));
            nullableEnumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64 = runtimeEntityType.AddProperty(
                "NullableEnumU64",
                typeof(CompiledModelTestBase.EnumU64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>)),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                    (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                    (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)));
            nullableEnumU64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64Array = runtimeEntityType.AddProperty(
                "NullableEnumU64Array",
                typeof(CompiledModelTestBase.EnumU64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))));
            nullableEnumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                "NullableEnumU64AsString",
                typeof(CompiledModelTestBase.EnumU64?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64AsString.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>)),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                    (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                    (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)));
            nullableEnumU64AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU64AsStringArray",
                typeof(CompiledModelTestBase.EnumU64?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))));
            nullableEnumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU64AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU64?>, List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU64?>, List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))));
            nullableEnumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                "NullableEnumU64Collection",
                typeof(List<CompiledModelTestBase.EnumU64?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU64Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64?>(
                    (Nullable<CompiledModelTestBase.EnumU64> v1, Nullable<CompiledModelTestBase.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU64)v1, (object)(CompiledModelTestBase.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? ((CompiledModelTestBase.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU64> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU64>)(CompiledModelTestBase.EnumU64)v : default(Nullable<CompiledModelTestBase.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU64?>, List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU64?>, List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
                        (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU64 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                        (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                        (decimal value) => (CompiledModelTestBase.EnumU64)(long)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                            (CompiledModelTestBase.EnumU64 value) => (decimal)(long)value,
                            (decimal value) => (CompiledModelTestBase.EnumU64)(long)value))));
            nullableEnumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8 = runtimeEntityType.AddProperty(
                "NullableEnumU8",
                typeof(CompiledModelTestBase.EnumU8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>)),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                    (CompiledModelTestBase.EnumU8 value) => (byte)value,
                    (byte value) => (CompiledModelTestBase.EnumU8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value)));
            nullableEnumU8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8Array = runtimeEntityType.AddProperty(
                "NullableEnumU8Array",
                typeof(CompiledModelTestBase.EnumU8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))));
            nullableEnumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                "NullableEnumU8AsString",
                typeof(CompiledModelTestBase.EnumU8?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8AsString.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>)),
                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>)),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                    (CompiledModelTestBase.EnumU8 value) => (byte)value,
                    (byte value) => (CompiledModelTestBase.EnumU8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value)));
            nullableEnumU8AsString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU8AsStringArray",
                typeof(CompiledModelTestBase.EnumU8?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8AsStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))));
            nullableEnumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU8AsStringCollection",
                typeof(List<CompiledModelTestBase.EnumU8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8AsStringCollection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU8?>, List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU8?>, List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))));
            nullableEnumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                "NullableEnumU8Collection",
                typeof(List<CompiledModelTestBase.EnumU8?>),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableEnumU8Collection.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8?>(
                    (Nullable<CompiledModelTestBase.EnumU8> v1, Nullable<CompiledModelTestBase.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CompiledModelTestBase.EnumU8)v1, (object)(CompiledModelTestBase.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? ((CompiledModelTestBase.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CompiledModelTestBase.EnumU8> v) => v.HasValue ? (Nullable<CompiledModelTestBase.EnumU8>)(CompiledModelTestBase.EnumU8)v : default(Nullable<CompiledModelTestBase.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU8?>, List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CompiledModelTestBase.EnumU8?>, List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
                        (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CompiledModelTestBase.EnumU8 v) => v.GetHashCode(),
                        (CompiledModelTestBase.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                        (CompiledModelTestBase.EnumU8 value) => (byte)value,
                        (byte value) => (CompiledModelTestBase.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                            (CompiledModelTestBase.EnumU8 value) => (byte)value,
                            (byte value) => (CompiledModelTestBase.EnumU8)value))));
            nullableEnumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloat = runtimeEntityType.AddProperty(
                "NullableFloat",
                typeof(float?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloat.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            nullableFloat.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloatArray = runtimeEntityType.AddProperty(
                "NullableFloatArray",
                typeof(float?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableFloatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                keyComparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float?>(new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v)));
            nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuid = runtimeEntityType.AddProperty(
                "NullableGuid",
                typeof(Guid?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                keyComparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                providerValueComparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            nullableGuid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuidArray = runtimeEntityType.AddProperty(
                "NullableGuidArray",
                typeof(Guid?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableGuidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                keyComparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid?>(new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddress = runtimeEntityType.AddProperty(
                "NullableIPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            nullableIPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddressArray = runtimeEntityType.AddProperty(
                "NullableIPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableIPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16 = runtimeEntityType.AddProperty(
                "NullableInt16",
                typeof(short?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                keyComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                providerValueComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)));
            nullableInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16Array = runtimeEntityType.AddProperty(
                "NullableInt16Array",
                typeof(short?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                keyComparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short?>(new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32 = runtimeEntityType.AddProperty(
                "NullableInt32",
                typeof(int?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            nullableInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32Array = runtimeEntityType.AddProperty(
                "NullableInt32Array",
                typeof(int?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                keyComparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int?>(new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v)));
            nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64 = runtimeEntityType.AddProperty(
                "NullableInt64",
                typeof(long?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            nullableInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64Array = runtimeEntityType.AddProperty(
                "NullableInt64Array",
                typeof(long?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                keyComparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long?>(new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v)));
            nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8 = runtimeEntityType.AddProperty(
                "NullableInt8",
                typeof(sbyte?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                keyComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    (sbyte v) => (short)v,
                    (short v) => (sbyte)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v)));
            nullableInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8Array = runtimeEntityType.AddProperty(
                "NullableInt8Array",
                typeof(sbyte?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                keyComparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))));
            nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                "NullablePhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            nullablePhysicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                "NullablePhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullablePhysicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));
            nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableString = runtimeEntityType.AddProperty(
                "NullableString",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            nullableString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableStringArray = runtimeEntityType.AddProperty(
                "NullableStringArray",
                typeof(string[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnly = runtimeEntityType.AddProperty(
                "NullableTimeOnly",
                typeof(TimeOnly?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)),
                keyComparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)),
                providerValueComparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)));
            nullableTimeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                "NullableTimeOnlyArray",
                typeof(TimeOnly?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableTimeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                keyComparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v)));
            nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpan = runtimeEntityType.AddProperty(
                "NullableTimeSpan",
                typeof(TimeSpan?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                keyComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                providerValueComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)));
            nullableTimeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                "NullableTimeSpanArray",
                typeof(TimeSpan?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableTimeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                keyComparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v)));
            nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16 = runtimeEntityType.AddProperty(
                "NullableUInt16",
                typeof(ushort?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                keyComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    (ushort v) => (int)v,
                    (int v) => (ushort)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v)));
            nullableUInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16Array = runtimeEntityType.AddProperty(
                "NullableUInt16Array",
                typeof(ushort?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                keyComparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort?>(new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))));
            nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32 = runtimeEntityType.AddProperty(
                "NullableUInt32",
                typeof(uint?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<uint, long>(
                    (uint v) => (long)v,
                    (long v) => (uint)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v)));
            nullableUInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32Array = runtimeEntityType.AddProperty(
                "NullableUInt32Array",
                typeof(uint?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                keyComparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint?>(new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))));
            nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64 = runtimeEntityType.AddProperty(
                "NullableUInt64",
                typeof(ulong?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>)),
                keyComparer: new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>)),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    (ulong v) => (decimal)v,
                    (decimal v) => (ulong)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v)));
            nullableUInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64Array = runtimeEntityType.AddProperty(
                "NullableUInt64Array",
                typeof(ulong?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                keyComparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong?>(new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))));
            nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8 = runtimeEntityType.AddProperty(
                "NullableUInt8",
                typeof(byte?),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)));
            nullableUInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8Array = runtimeEntityType.AddProperty(
                "NullableUInt8Array",
                typeof(byte?[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                keyComparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte?>(new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUri = runtimeEntityType.AddProperty(
                "NullableUri",
                typeof(Uri),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            nullableUri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUriArray = runtimeEntityType.AddProperty(
                "NullableUriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            nullableUriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddress = runtimeEntityType.AddProperty(
                "PhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            physicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            physicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressArray = runtimeEntityType.AddProperty(
                "PhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            physicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));
            physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                "PhysicalAddressToBytesConverterProperty",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new PhysicalAddressToBytesConverter());
            physicalAddressToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(8)",
                    size: 8),
                converter: new ValueConverter<PhysicalAddress, byte[]>(
                    (PhysicalAddress v) => v.GetAddressBytes(),
                    (Byte[] v) => new PhysicalAddress(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, byte[]>(
                        (PhysicalAddress v) => v.GetAddressBytes(),
                        (Byte[] v) => new PhysicalAddress(v))));
            physicalAddressToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                "PhysicalAddressToStringConverterProperty",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new PhysicalAddressToStringConverter());
            physicalAddressToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            physicalAddressToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @string = runtimeEntityType.AddProperty(
                "String",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            @string.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            @string.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringArray = runtimeEntityType.AddProperty(
                "StringArray",
                typeof(string[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            stringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                "StringToBoolConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToBoolConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToBoolConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToBoolConverter());
            stringToBoolConverterProperty.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                converter: new ValueConverter<string, bool>(
                    (string v) => Convert.ToBoolean(v),
                    (bool v) => Convert.ToString(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, bool>(
                    JsonBoolReaderWriter.Instance,
                    new ValueConverter<string, bool>(
                        (string v) => Convert.ToBoolean(v),
                        (bool v) => Convert.ToString(v))));
            stringToBoolConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToBytesConverterProperty = runtimeEntityType.AddProperty(
                "StringToBytesConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringToBytesConverterProperty.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                converter: new ValueConverter<string, byte[]>(
                    (string v) => Encoding.UTF32.GetBytes(v),
                    (Byte[] v) => Encoding.UTF32.GetString(v)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, byte[]>(
                    JsonByteArrayReaderWriter.Instance,
                    new ValueConverter<string, byte[]>(
                        (string v) => Encoding.UTF32.GetBytes(v),
                        (Byte[] v) => Encoding.UTF32.GetString(v))));
            stringToBytesConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToCharConverterProperty = runtimeEntityType.AddProperty(
                "StringToCharConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToCharConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToCharConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToCharConverter());
            stringToCharConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<string, string>(
                    (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)(v.Length < 1 ? '\0' : v[0])),
                    (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)(v.Length < 1 ? '\0' : v[0]))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<string, string>(
                        (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)(v.Length < 1 ? '\0' : v[0])),
                        (string v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)(v.Length < 1 ? '\0' : v[0])))));
            stringToCharConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDateOnlyConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateOnlyConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToDateOnlyConverter());
            stringToDateOnlyConverterProperty.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 10),
                converter: new ValueConverter<string, DateOnly>(
                    (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                    (DateOnly v) => v.ToString("yyyy\\-MM\\-dd")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateOnly>(
                    JsonDateOnlyReaderWriter.Instance,
                    new ValueConverter<string, DateOnly>(
                        (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                        (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"))));
            stringToDateOnlyConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDateTimeConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateTimeConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateTimeConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateTimeConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToDateTimeConverter());
            stringToDateTimeConverterProperty.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, DateTime>(
                    (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
                    (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTime>(
                    JsonDateTimeReaderWriter.Instance,
                    new ValueConverter<string, DateTime>(
                        (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
                        (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"))));
            stringToDateTimeConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDateTimeOffsetConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateTimeOffsetConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateTimeOffsetConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateTimeOffsetConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToDateTimeOffsetConverter());
            stringToDateTimeOffsetConverterProperty.TypeMapping = SqlServerDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, DateTimeOffset>(
                    (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
                    (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTimeOffset>(
                    JsonDateTimeOffsetReaderWriter.Instance,
                    new ValueConverter<string, DateTimeOffset>(
                        (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
                        (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"))));
            stringToDateTimeOffsetConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDecimalNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToDecimalNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDecimalNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDecimalNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToNumberConverter<decimal>());
            stringToDecimalNumberConverterProperty.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, decimal>(
                    (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<string, decimal>(
                        (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v))));
            stringToDecimalNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToDoubleNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToDoubleNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDoubleNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDoubleNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToNumberConverter<double>());
            stringToDoubleNumberConverterProperty.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, double>(
                    (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, double>(
                    JsonDoubleReaderWriter.Instance,
                    new ValueConverter<string, double>(
                        (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v))));
            stringToDoubleNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToEnumConverterProperty = runtimeEntityType.AddProperty(
                "StringToEnumConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToEnumConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToEnumConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToEnumConverter<CompiledModelTestBase.EnumU32>());
            stringToEnumConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<string, long>(
                    (string v) => (long)StringEnumConverter<string, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32>.ConvertToEnum(v),
                    (long value) => ((CompiledModelTestBase.EnumU32)value).ToString()),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<string, long>(
                        (string v) => (long)StringEnumConverter<string, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32>.ConvertToEnum(v),
                        (long value) => ((CompiledModelTestBase.EnumU32)value).ToString())));
            stringToEnumConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToGuidConverterProperty = runtimeEntityType.AddProperty(
                "StringToGuidConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToGuidConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToGuidConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            stringToGuidConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            stringToGuidConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToIntNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToIntNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToIntNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToIntNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToNumberConverter<int>());
            stringToIntNumberConverterProperty.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, int>(
                    (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<string, int>(
                        (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v))));
            stringToIntNumberConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToTimeOnlyConverterProperty = runtimeEntityType.AddProperty(
                "StringToTimeOnlyConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToTimeOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToTimeOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToTimeOnlyConverter());
            stringToTimeOnlyConverterProperty.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, TimeOnly>(
                    (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                    (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance,
                    new ValueConverter<string, TimeOnly>(
                        (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                        (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o"))));
            stringToTimeOnlyConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToTimeSpanConverterProperty = runtimeEntityType.AddProperty(
                "StringToTimeSpanConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToTimeSpanConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToTimeSpanConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToTimeSpanConverter());
            stringToTimeSpanConverterProperty.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, TimeSpan>(
                    (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
                    (TimeSpan v) => v.ToString("c")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance,
                    new ValueConverter<string, TimeSpan>(
                        (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
                        (TimeSpan v) => v.ToString("c"))));
            stringToTimeSpanConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringToUriConverterProperty = runtimeEntityType.AddProperty(
                "StringToUriConverterProperty",
                typeof(string),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToUriConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToUriConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new StringToUriConverter());
            stringToUriConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<string, string>(
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString()),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<string, string>(
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString())));
            stringToUriConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnly = runtimeEntityType.AddProperty(
                "TimeOnly",
                typeof(TimeOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeOnly(0, 0, 0));
            timeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v));
            timeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyArray = runtimeEntityType.AddProperty(
                "TimeOnlyArray",
                typeof(TimeOnly[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            timeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                keyComparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v)));
            timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                "TimeOnlyToStringConverterProperty",
                typeof(TimeOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeOnlyToStringConverter());
            timeOnlyToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<TimeOnly, string>(
                    (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o"),
                    (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<TimeOnly, string>(
                        (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o"),
                        (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
            timeOnlyToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");
            timeOnlyToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyToTicksConverterProperty = runtimeEntityType.AddProperty(
                "TimeOnlyToTicksConverterProperty",
                typeof(TimeOnly),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeOnlyToTicksConverter());
            timeOnlyToTicksConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<TimeOnly, long>(
                    (TimeOnly v) => v.Ticks,
                    (long v) => new TimeOnly(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<TimeOnly, long>(
                        (TimeOnly v) => v.Ticks,
                        (long v) => new TimeOnly(v))));
            timeOnlyToTicksConverterProperty.SetSentinelFromProviderValue(0L);
            timeOnlyToTicksConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpan = runtimeEntityType.AddProperty(
                "TimeSpan",
                typeof(TimeSpan),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeSpan(0, 0, 0, 0, 0));
            timeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v));
            timeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanArray = runtimeEntityType.AddProperty(
                "TimeSpanArray",
                typeof(TimeSpan[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            timeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                keyComparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v)));
            timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                "TimeSpanToStringConverterProperty",
                typeof(TimeSpan),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeSpanToStringConverter());
            timeSpanToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(48)",
                    size: 48,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<TimeSpan, string>(
                    (TimeSpan v) => v.ToString("c"),
                    (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<TimeSpan, string>(
                        (TimeSpan v) => v.ToString("c"),
                        (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture))));
            timeSpanToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");
            timeSpanToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanToTicksConverterProperty = runtimeEntityType.AddProperty(
                "TimeSpanToTicksConverterProperty",
                typeof(TimeSpan),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeSpanToTicksConverter());
            timeSpanToTicksConverterProperty.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<TimeSpan, long>(
                    (TimeSpan v) => v.Ticks,
                    (long v) => new TimeSpan(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<TimeSpan, long>(
                        (TimeSpan v) => v.Ticks,
                        (long v) => new TimeSpan(v))));
            timeSpanToTicksConverterProperty.SetSentinelFromProviderValue(0L);
            timeSpanToTicksConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16 = runtimeEntityType.AddProperty(
                "UInt16",
                typeof(ushort),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    (ushort v) => (int)v,
                    (int v) => (ushort)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v)));
            uInt16.SetSentinelFromProviderValue(0);
            uInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16Array = runtimeEntityType.AddProperty(
                "UInt16Array",
                typeof(ushort[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                keyComparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))));
            uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32 = runtimeEntityType.AddProperty(
                "UInt32",
                typeof(uint),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<uint, long>(
                    (uint v) => (long)v,
                    (long v) => (uint)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v)));
            uInt32.SetSentinelFromProviderValue(0L);
            uInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32Array = runtimeEntityType.AddProperty(
                "UInt32Array",
                typeof(uint[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                keyComparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))));
            uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64 = runtimeEntityType.AddProperty(
                "UInt64",
                typeof(ulong),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    (ulong v) => (decimal)v,
                    (decimal v) => (ulong)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v)));
            uInt64.SetSentinelFromProviderValue(0m);
            uInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64Array = runtimeEntityType.AddProperty(
                "UInt64Array",
                typeof(ulong[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                keyComparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))));
            uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8 = runtimeEntityType.AddProperty(
                "UInt8",
                typeof(byte),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (byte)0);
            uInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v));
            uInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8Array = runtimeEntityType.AddProperty(
                "UInt8Array",
                typeof(byte[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uInt8Array.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            uInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uri = runtimeEntityType.AddProperty(
                "Uri",
                typeof(Uri),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            uri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uriArray = runtimeEntityType.AddProperty(
                "UriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            uriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                "UriToStringConverterProperty",
                typeof(Uri),
                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new UriToStringConverter());
            uriToStringConverterProperty.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            uriToStringConverterProperty.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyTypes");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
