// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalBase",
                derivedTypesCount: 1,
                propertyCount: 15,
                complexPropertyCount: 1,
                navigationCount: 1,
                foreignKeyCount: 1,
                unnamedIndexCount: 1,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var discriminator = runtimeEntityType.AddProperty(
                "Discriminator",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                maxLength: 55,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            discriminator.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(55)",
                    size: 55,
                    dbType: System.Data.DbType.String));
            discriminator.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum1.SetSentinelFromProviderValue(0);
            enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum1.SetSentinelFromProviderValue(0);
            flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum2.SetSentinelFromProviderValue(0);
            flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long?),
                nullable: true);
            principalBaseId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            principalBaseId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            OwnedComplexProperty.Create(runtimeEntityType);
            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalBaseId });

            return runtimeEntityType;
        }

        private static class OwnedComplexProperty
        {
            public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
            {
                var complexProperty = declaringType.AddComplexProperty("Owned",
                    typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                    "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                    typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    propertyAccessMode: PropertyAccessMode.Field,
                    changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                    propertyCount: 10,
                    complexPropertyCount: 1);

                var complexType = complexProperty.ComplexType;
                var details = complexType.AddProperty(
                    "Details",
                    typeof(string),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                    nullable: true,
                    concurrencyToken: true,
                    valueGenerated: ValueGenerated.OnAddOrUpdate,
                    beforeSaveBehavior: PropertySaveBehavior.Ignore,
                    afterSaveBehavior: PropertySaveBehavior.Ignore,
                    maxLength: 64,
                    unicode: false,
                    precision: 3,
                    scale: 2,
                    sentinel: "");
                details.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varchar(64)",
                        size: 64,
                        precision: 3,
                        scale: 2));
                details.AddAnnotation("foo", "bar");
                details.AddAnnotation("Relational:ColumnName", "Deets");
                details.AddAnnotation("Relational:ColumnType", "varchar");
                details.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var number = complexType.AddProperty(
                    "Number",
                    typeof(int),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    sentinel: 0);
                number.TypeMapping = IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v));
                number.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeArray = complexType.AddProperty(
                    "RefTypeArray",
                    typeof(IPAddress[]),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v))))),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        keyComparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(45)",
                            size: 45,
                            dbType: System.Data.DbType.String),
                        converter: new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))));
                refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeEnumerable = complexType.AddProperty(
                    "RefTypeEnumerable",
                    typeof(IEnumerable<string>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    keyComparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        keyComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        storeTypePostfix: StoreTypePostfix.None));
                refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeIList = complexType.AddProperty(
                    "RefTypeIList",
                    typeof(IList<string>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    keyComparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        keyComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        storeTypePostfix: StoreTypePostfix.None));
                refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeList = complexType.AddProperty(
                    "RefTypeList",
                    typeof(List<IPAddress>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v))))),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        keyComparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(45)",
                            size: 45,
                            dbType: System.Data.DbType.String),
                        converter: new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))));
                refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeArray = complexType.AddProperty(
                    "ValueTypeArray",
                    typeof(DateTime[]),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)),
                    keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                        JsonDateTimeReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                        JsonDateTimeReaderWriter.Instance),
                    elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                        comparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        keyComparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        providerValueComparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)));
                valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeEnumerable = complexType.AddProperty(
                    "ValueTypeEnumerable",
                    typeof(IEnumerable<byte>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance),
                    elementMapping: SqlServerByteTypeMapping.Default.Clone(
                        comparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        keyComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        providerValueComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)));
                valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeIList = complexType.AddProperty(
                    "ValueTypeIList",
                    typeof(IList<byte>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance),
                    elementMapping: SqlServerByteTypeMapping.Default.Clone(
                        comparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        keyComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        providerValueComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)));
                valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeList = complexType.AddProperty(
                    "ValueTypeList",
                    typeof(List<short>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<short>(new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)),
                    keyComparer: new ListComparer<short>(new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                        JsonInt16ReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                        JsonInt16ReaderWriter.Instance),
                    elementMapping: SqlServerShortTypeMapping.Default.Clone(
                        comparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        keyComparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        providerValueComparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)));
                valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                PrincipalComplexProperty.Create(complexType);
                complexType.AddAnnotation("go", "brr");
                complexType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
                complexType.AddAnnotation("Relational:Schema", null);
                complexType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
                complexType.AddAnnotation("Relational:TableName", "PrincipalBase");
                complexType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
                complexType.AddAnnotation("Relational:ViewSchema", null);
                complexProperty.AddAnnotation("goo", "ber");
                return complexProperty;
            }

            private static class PrincipalComplexProperty
            {
                public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                {
                    var complexProperty = declaringType.AddComplexProperty("Principal",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType.Principal#PrincipalBase",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        propertyCount: 14);

                    var complexType = complexProperty.ComplexType;
                    var alternateId = complexType.AddProperty(
                        "AlternateId",
                        typeof(Guid),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
                    alternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                        comparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        keyComparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        providerValueComparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "uniqueidentifier"));
                    alternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var enum1 = complexType.AddProperty(
                        "Enum1",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
                    enum1.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
                    enum1.SetSentinelFromProviderValue(0);
                    enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var enum2 = complexType.AddProperty(
                        "Enum2",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    enum2.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
                    enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var flagsEnum1 = complexType.AddProperty(
                        "FlagsEnum1",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
                    flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
                    flagsEnum1.SetSentinelFromProviderValue(0);
                    flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var flagsEnum2 = complexType.AddProperty(
                        "FlagsEnum2",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
                    flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
                    flagsEnum2.SetSentinelFromProviderValue(0);
                    flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var id = complexType.AddProperty(
                        "Id",
                        typeof(long?),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                        comparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        keyComparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        providerValueComparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
                    id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeArray = complexType.AddProperty(
                        "RefTypeArray",
                        typeof(IPAddress[]),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v))))),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            keyComparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(45)",
                                size: 45,
                                dbType: System.Data.DbType.String),
                            converter: new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)),
                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))));
                    refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeEnumerable = complexType.AddProperty(
                        "RefTypeEnumerable",
                        typeof(IEnumerable<string>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        keyComparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            keyComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(max)",
                                dbType: System.Data.DbType.String),
                            storeTypePostfix: StoreTypePostfix.None));
                    refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeIList = complexType.AddProperty(
                        "RefTypeIList",
                        typeof(IList<string>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        keyComparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            keyComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(max)",
                                dbType: System.Data.DbType.String),
                            storeTypePostfix: StoreTypePostfix.None));
                    refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeList = complexType.AddProperty(
                        "RefTypeList",
                        typeof(List<IPAddress>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v))))),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            keyComparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(45)",
                                size: 45,
                                dbType: System.Data.DbType.String),
                            converter: new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)),
                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))));
                    refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeArray = complexType.AddProperty(
                        "ValueTypeArray",
                        typeof(DateTime[]),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)),
                        keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                            JsonDateTimeReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                            JsonDateTimeReaderWriter.Instance),
                        elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                            comparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            keyComparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            providerValueComparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v)));
                    valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeEnumerable = complexType.AddProperty(
                        "ValueTypeEnumerable",
                        typeof(IEnumerable<byte>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance),
                        elementMapping: SqlServerByteTypeMapping.Default.Clone(
                            comparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            keyComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            providerValueComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v)));
                    valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeIList = complexType.AddProperty(
                        "ValueTypeIList",
                        typeof(IList<byte>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance),
                        elementMapping: SqlServerByteTypeMapping.Default.Clone(
                            comparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            keyComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            providerValueComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v)));
                    valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeList = complexType.AddProperty(
                        "ValueTypeList",
                        typeof(List<short>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<short>(new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)),
                        keyComparer: new ListComparer<short>(new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                            JsonInt16ReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                            JsonInt16ReaderWriter.Instance),
                        elementMapping: SqlServerShortTypeMapping.Default.Clone(
                            comparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            keyComparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            providerValueComparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v)));
                    valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    complexType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
                    complexType.AddAnnotation("Relational:Schema", null);
                    complexType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
                    complexType.AddAnnotation("Relational:TableName", "PrincipalBase");
                    complexType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
                    complexType.AddAnnotation("Relational:ViewSchema", null);
                    return complexProperty;
                }
            }
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType);

            var deriveds = principalEntityType.AddNavigation("Deriveds",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var insertSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Insert",
                null,
                false);

            var principalBaseId = insertSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var enum1 = insertSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum2 = insertSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum1 = insertSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum2 = insertSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList = insertSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList = insertSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray = insertSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable = insertSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList = insertSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList = insertSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray = insertSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable = insertSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var discriminator = insertSproc.AddParameter(
                "Discriminator", System.Data.ParameterDirection.Input, false, "Discriminator", false);
            var id = insertSproc.AddParameter(
                "Id", System.Data.ParameterDirection.Output, false, "Id", false);
            runtimeEntityType.AddAnnotation("Relational:InsertStoredProcedure", insertSproc);

            var deleteSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Delete",
                null,
                true);

            var id0 = deleteSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:DeleteStoredProcedure", deleteSproc);

            var updateSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Update",
                null,
                false);

            var principalBaseId0 = updateSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var enum10 = updateSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum20 = updateSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum10 = updateSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum20 = updateSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList0 = updateSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList0 = updateSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray0 = updateSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable0 = updateSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList0 = updateSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList0 = updateSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray0 = updateSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable0 = updateSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var id1 = updateSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:UpdateStoredProcedure", updateSproc);

            runtimeEntityType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewDefinitionSql", null);
            runtimeEntityType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
