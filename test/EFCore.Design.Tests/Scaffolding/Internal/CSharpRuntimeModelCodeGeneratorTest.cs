// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections;
using System.ComponentModel;
using System.Data;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Cosmos.ValueGeneration.Internal;
using Microsoft.EntityFrameworkCore.Design.Internal;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
using Microsoft.EntityFrameworkCore.Sqlite.Design.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Design.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Metadata.Internal;
using Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity;
using Microsoft.EntityFrameworkCore.ValueGeneration.Internal;
using Microsoft.Extensions.Options;
using NetTopologySuite;
using NetTopologySuite.Geometries;
using Newtonsoft.Json.Linq;
using static Microsoft.EntityFrameworkCore.Migrations.Design.CSharpMigrationsGeneratorTest;
using static Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest;
using Index = Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index;

public class GlobalNamespaceContext : ContextBase
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity(
            "1", e =>
            {
                e.Property<int>("Id");
                e.HasKey("Id");
            });
    }
}

namespace Microsoft.EntityFrameworkCore.Scaffolding.Internal
{
    public class CSharpRuntimeModelCodeGeneratorTest
    {
        [ConditionalFact]
        public void Self_referential_property()
            => Test(
                new TestModel.Internal.SelfReferentialDbContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    Assert.Single(model.GetEntityTypes());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                }
            );


        [ConditionalFact]
        public void Empty_model()
            => Test(
                new EmptyContext(),
                new CompiledModelCodeGenerationOptions(),
                code =>
                    Assert.Collection(
                        code,
                        c => AssertFileContents(
                            "EmptyContextModel.cs",
                            @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.EmptyContext))]
    public partial class EmptyContextModel : RuntimeModel
    {
        static EmptyContextModel()
        {
            var model = new EmptyContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static EmptyContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                            c),
                        c => AssertFileContents(
                            "EmptyContextModelBuilder.cs",
                            @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class EmptyContextModel
    {
        partial void Initialize()
        {
        }
    }
}
",
                            c)),
                model =>
                {
                    Assert.Empty(model.GetEntityTypes());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                });

        public class EmptyContext : ContextBase
        {
        }

        [ConditionalFact]
        public void Global_namespace_works()
            => Test(
                new GlobalNamespaceContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = string.Empty },
                code =>
                {
                    Assert.All(code, f => Assert.DoesNotContain("namespace ", f.Code));
                },
                model =>
                {
                    Assert.NotNull(model.FindEntityType("1"));
                });

        [ConditionalFact]
        public void Throws_for_constructor_binding()
            => Test(
                new ConstructorBindingContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelConstructorBinding("Lazy", "Customize()", "LazyEntityType"));

        public class ConstructorBindingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "Lazy", e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        ((EntityType)e.Metadata).ConstructorBinding = new ConstructorBinding(
                            typeof(object).GetConstructor(Type.EmptyTypes)!,
                            Array.Empty<ParameterBinding>());
                    });
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => base.OnConfiguring(options.UseLazyLoadingProxies());
        }

        [ConditionalFact]
        public void Manual_lazy_loading()
            => Test(
                new LazyLoadingContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    var lazyConstructorEntity = model.FindEntityType(typeof(LazyConstructorEntity));
                    var lazyParameterBinding = lazyConstructorEntity.ConstructorBinding.ParameterBindings.Single();
                    Assert.Equal(typeof(ILazyLoader), lazyParameterBinding.ParameterType);
                    var lazyPropertyEntity = model.FindEntityType(typeof(LazyPropertyEntity));
                    var lazyServiceProperty = lazyPropertyEntity.GetServiceProperties().Single();
                    Assert.Equal(typeof(ILazyLoader), lazyServiceProperty.ClrType);
                });

        public class LazyLoadingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<LazyConstructorEntity>();
            }
        }

        public class LazyConstructorEntity
        {
            private readonly ILazyLoader _loader;

            public LazyConstructorEntity(ILazyLoader loader)
            {
                _loader = loader;
            }

            public int Id { get; set; }

            public LazyPropertyEntity LazyPropertyEntity { get; set; }
        }

        public class LazyPropertyEntity
        {
            public ILazyLoader Loader { get; set; }

            public int Id { get; set; }
            public int LazyConstructorEntityId { get; set; }

            public LazyConstructorEntity LazyConstructorEntity { get; set; }
        }

        [ConditionalFact]
        public void Lazy_loading_proxies()
            => Test(
                new LazyLoadingProxiesContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    Assert.Equal(
                        typeof(ILazyLoader), model.FindEntityType(typeof(LazyProxiesEntity1))!.GetServiceProperties().Single().ClrType);
                    Assert.Equal(
                        typeof(ILazyLoader), model.FindEntityType(typeof(LazyProxiesEntity1))!.GetServiceProperties().Single().ClrType);
                });

        public class LazyLoadingProxiesContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<LazyProxiesEntity1>();
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => base.OnConfiguring(options.UseLazyLoadingProxies());
        }

        public class LazyProxiesEntity1
        {
            public int Id { get; set; }

            public virtual LazyProxiesEntity2 ReferenceNavigation { get; set; }
        }

        public class LazyProxiesEntity2
        {
            public ILazyLoader Loader { get; set; }

            public int Id { get; set; }
            public virtual ICollection<LazyProxiesEntity1> CollectionNavigation { get; set; }
        }

        [ConditionalFact]
        public void Throws_for_query_filter()
            => Test(
                new QueryFilterContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelQueryFilter("QueryFilter"));

        public class QueryFilterContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "QueryFilter", e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        e.HasQueryFilter((Expression<Func<Dictionary<string, object>, bool>>)(e => e != null));
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_defining_query()
            => Test(
                new DefiningQueryContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelDefiningQuery("object"));

        public class DefiningQueryContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<object>(
                    e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        e.Metadata.SetInMemoryQuery(
                            (Expression<Func<IQueryable<object>>>)
                            (() => Set<object>()));
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_value_generator()
            => Test(
                new ValueGeneratorContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelValueGenerator(
                    "MyEntity", "Id", nameof(PropertyBuilder.HasValueGeneratorFactory)));

        public class ValueGeneratorContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasValueGenerator((p, e) => null);
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_value_converter()
            => Test(
                new ValueConverterContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelValueConverter(
                    "MyEntity", "Id", nameof(PropertyBuilder.HasConversion)));

        public class ValueConverterContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(i => i, i => i);
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_value_comparer()
            => Test(
                new ValueComparerContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelValueComparer(
                    "MyEntity", "Id", nameof(PropertyBuilder.HasConversion)));

        public class ValueComparerContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(typeof(int), new FakeValueComparer());
                        e.HasKey("Id");
                    });
            }
        }

        private class FakeValueComparer : ValueComparer<int>
        {
            public FakeValueComparer()
                : base(false)
            {
            }

            public override Type Type { get; } = typeof(int);

            public override bool Equals(object left, object right)
                => throw new NotImplementedException();

            public override int GetHashCode(object instance)
                => throw new NotImplementedException();

            public override object Snapshot(object instance)
                => throw new NotImplementedException();
        }

        [ConditionalFact]
        public void Throws_for_provider_value_comparer()
            => Test(
                new ProviderValueComparerContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelValueComparer(
                    "MyEntity", "Id", nameof(PropertyBuilder.HasConversion)));

        public class ProviderValueComparerContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(typeof(int), null, new FakeValueComparer());
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_custom_type_mapping()
            => Test(
                new TypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelTypeMapping(
                    "MyEntity", "Id", "Customize()", "MyEntityEntityType"));

        public class TypeMappingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").Metadata.SetTypeMapping(new InMemoryTypeMapping(typeof(int)));
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_custom_function_translation()
            => Test(
                new FunctionTranslationContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: RelationalStrings.CompiledModelFunctionTranslation("GetSqlFragmentStatic"));

        public class FunctionTranslationContext : SqlServerContextBase
        {
            public static string GetSqlFragmentStatic()
                => throw new NotImplementedException();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(typeof(FunctionTranslationContext).GetMethod(nameof(GetSqlFragmentStatic)))
                    .HasTranslation(args => new SqlFragmentExpression("NULL"));
            }
        }

        [ConditionalFact]
        public void Throws_for_custom_function_type_mapping()
            => Test(
                new FunctionTypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: RelationalStrings.CompiledModelFunctionTypeMapping(
                    "GetSqlFragmentStatic", "Customize()", "FunctionTypeMappingContextModel"));

        public class FunctionTypeMappingContext : SqlServerContextBase
        {
            public static string GetSqlFragmentStatic(string param)
                => throw new NotImplementedException();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(typeof(FunctionTypeMappingContext).GetMethod(nameof(GetSqlFragmentStatic)))
                    .Metadata.TypeMapping = new StringTypeMapping("varchar", DbType.AnsiString);
            }
        }

        [ConditionalFact]
        public void Throws_for_custom_function_parameter_type_mapping()
            => Test(
                new FunctionParameterTypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: RelationalStrings.CompiledModelFunctionParameterTypeMapping(
                    "GetSqlFragmentStatic", "param", "Customize()", "FunctionParameterTypeMappingContextModel"));

        public class FunctionParameterTypeMappingContext : SqlServerContextBase
        {
            public static string GetSqlFragmentStatic(string param)
                => throw new NotImplementedException();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(typeof(FunctionParameterTypeMappingContext).GetMethod(nameof(GetSqlFragmentStatic)))
                    .HasParameter("param").Metadata.TypeMapping = new StringTypeMapping("varchar", DbType.AnsiString);
            }
        }

        [ConditionalFact]
        public void Fully_qualified_model()
            => Test(
                new TestModel.Internal.DbContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = "Internal" },
                code =>
                    Assert.Collection(
                        code,
                        c => AssertFileContents(
                            "DbContextModel.cs",
                            @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    [DbContext(typeof(DbContext))]
    public partial class DbContextModel : RuntimeModel
    {
        static DbContextModel()
        {
            var model = new DbContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static DbContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                            c),
                        c => AssertFileContents(
                            "DbContextModelBuilder.cs",
                            @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    public partial class DbContextModel
    {
        partial void Initialize()
        {
            var index = IndexEntityType.Create(this);
            var @internal = InternalEntityType.Create(this);
            var identityUser = IdentityUserEntityType.Create(this);
            var identityUser0 = IdentityUser0EntityType.Create(this, identityUser);

            IndexEntityType.CreateAnnotations(index);
            InternalEntityType.CreateAnnotations(@internal);
            IdentityUserEntityType.CreateAnnotations(identityUser);
            IdentityUser0EntityType.CreateAnnotations(identityUser0);

        }
    }
}
",
                            c),
                        c => AssertFileContents(
                            "IndexEntityType.cs",
                            @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class IndexEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index"",
                typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(Guid),
                propertyInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index).GetProperty(""Id"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                            c),
                        c =>
                            AssertFileContents(
                                "InternalEntityType.cs",
                                @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class InternalEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal"",
                typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(long),
                propertyInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal).GetProperty(""Id"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                                c),
                        c => AssertFileContents(
                            "IdentityUserEntityType.cs",
                            @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class IdentityUserEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity.IdentityUser"",
                typeof(IdentityUser),
                baseEntityType,
                discriminatorProperty: ""Discriminator"",
                discriminatorValue: ""IdentityUser"");

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""Id"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var accessFailedCount = runtimeEntityType.AddProperty(
                ""AccessFailedCount"",
                typeof(int),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""AccessFailedCount"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<AccessFailedCount>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var concurrencyStamp = runtimeEntityType.AddProperty(
                ""ConcurrencyStamp"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""ConcurrencyStamp"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<ConcurrencyStamp>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var discriminator = runtimeEntityType.AddProperty(
                ""Discriminator"",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);

            var email = runtimeEntityType.AddProperty(
                ""Email"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""Email"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<Email>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var emailConfirmed = runtimeEntityType.AddProperty(
                ""EmailConfirmed"",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""EmailConfirmed"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<EmailConfirmed>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var lockoutEnabled = runtimeEntityType.AddProperty(
                ""LockoutEnabled"",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""LockoutEnabled"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<LockoutEnabled>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var lockoutEnd = runtimeEntityType.AddProperty(
                ""LockoutEnd"",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""LockoutEnd"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<LockoutEnd>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var normalizedEmail = runtimeEntityType.AddProperty(
                ""NormalizedEmail"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""NormalizedEmail"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<NormalizedEmail>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var normalizedUserName = runtimeEntityType.AddProperty(
                ""NormalizedUserName"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""NormalizedUserName"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<NormalizedUserName>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var passwordHash = runtimeEntityType.AddProperty(
                ""PasswordHash"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""PasswordHash"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<PasswordHash>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var phoneNumber = runtimeEntityType.AddProperty(
                ""PhoneNumber"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""PhoneNumber"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<PhoneNumber>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var phoneNumberConfirmed = runtimeEntityType.AddProperty(
                ""PhoneNumberConfirmed"",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""PhoneNumberConfirmed"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<PhoneNumberConfirmed>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var securityStamp = runtimeEntityType.AddProperty(
                ""SecurityStamp"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""SecurityStamp"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<SecurityStamp>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var twoFactorEnabled = runtimeEntityType.AddProperty(
                ""TwoFactorEnabled"",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""TwoFactorEnabled"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<TwoFactorEnabled>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var userName = runtimeEntityType.AddProperty(
                ""UserName"",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty(""UserName"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField(""<UserName>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                            c),
                        c =>
                            AssertFileContents(
                                "IdentityUser0EntityType.cs",
                                @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class IdentityUser0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.IdentityUser"",
                typeof(IdentityUser),
                baseEntityType,
                discriminatorProperty: ""Discriminator"",
                discriminatorValue: ""DerivedIdentityUser"");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                                c)),
                model =>
                {
                    Assert.Equal(4, model.GetEntityTypes().Count());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                },
                typeof(FullyQualifiedDesignTimeServices));

        private class FullyQualifiedDesignTimeServices : IDesignTimeServices
        {
            public void ConfigureDesignTimeServices(IServiceCollection serviceCollection)
                => serviceCollection.AddSingleton<ICSharpHelper, FullyQualifiedCSharpHelper>();
        }

        private class FullyQualifiedCSharpHelper : CSharpHelper
        {
            public FullyQualifiedCSharpHelper(ITypeMappingSource typeMappingSource)
                : base(typeMappingSource)
            {
            }

            protected override bool ShouldUseFullName(Type type)
                => base.ShouldUseFullName(type);

            protected override bool ShouldUseFullName(string shortTypeName)
                => base.ShouldUseFullName(shortTypeName)
                    || shortTypeName == nameof(Index)
                    || shortTypeName == nameof(Internal);
        }

        [ConditionalFact]
        [SqlServerConfiguredCondition]
        public void BigModel()
            => Test(
                new BigContext(),
                new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
                code =>
                    Assert.Collection(
                        code,
                        c => AssertFileContents(
                            "BigContextModel.cs",
                            @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.BigContext))]
    public partial class BigContextModel : RuntimeModel
    {
        static BigContextModel()
        {
            var model = new BigContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static BigContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
", c),
                        c => AssertFileContents(
                            "BigContextModelBuilder.cs",
                            @"// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    public partial class BigContextModel
    {
        partial void Initialize()
        {
            var dependentBase = DependentBaseEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var ownedType = OwnedTypeEntityType.Create(this);
            var ownedType0 = OwnedType0EntityType.Create(this);
            var principalBasePrincipalDerivedDependentBasebyte = PrincipalBasePrincipalDerivedDependentBasebyteEntityType.Create(this);
            var dependentDerived = DependentDerivedEntityType.Create(this, dependentBase);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalBase);
            DependentBaseEntityType.CreateForeignKey2(dependentBase, principalDerived);
            OwnedTypeEntityType.CreateForeignKey1(ownedType, principalBase);
            OwnedTypeEntityType.CreateForeignKey2(ownedType, ownedType);
            OwnedType0EntityType.CreateForeignKey1(ownedType0, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey1(principalBasePrincipalDerivedDependentBasebyte, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey2(principalBasePrincipalDerivedDependentBasebyte, principalBase);
            PrincipalDerivedEntityType.CreateForeignKey1(principalDerived, principalBase);

            PrincipalBaseEntityType.CreateSkipNavigation1(principalBase, principalDerived, principalBasePrincipalDerivedDependentBasebyte);
            PrincipalDerivedEntityType.CreateSkipNavigation1(principalDerived, principalBase, principalBasePrincipalDerivedDependentBasebyte);

            DependentBaseEntityType.CreateAnnotations(dependentBase);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            OwnedTypeEntityType.CreateAnnotations(ownedType);
            OwnedType0EntityType.CreateAnnotations(ownedType0);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateAnnotations(principalBasePrincipalDerivedDependentBasebyte);
            DependentDerivedEntityType.CreateAnnotations(dependentDerived);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
", c),
                        c => AssertFileContents(
                            "DependentBaseEntityType.cs", @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType,
                discriminatorProperty: ""EnumDiscriminator"",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.One);

            var principalId = runtimeEntityType.AddProperty(
                ""PrincipalId"",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var principalAlternateId = runtimeEntityType.AddProperty(
                ""PrincipalAlternateId"",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalAlternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var enumDiscriminator = runtimeEntityType.AddProperty(
                ""EnumDiscriminator"",
                typeof(CSharpMigrationsGeneratorTest.Enum1),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            enumDiscriminator.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty(""Id"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { principalId, principalAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalId"")!, declaringEntityType.FindProperty(""PrincipalAlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")!, principalEntityType.FindProperty(""AlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientNoAction,
                unique: true,
                required: true);

            var principal = declaringEntityType.AddNavigation(""Principal"",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty(""Principal"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField(""<Principal>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation(""Dependent"",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty(""Dependent"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField(""<Dependent>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""DiscriminatorMappingComplete"", false);
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:MappingStrategy"", ""TPH"");
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""DependentBase<byte?>"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "PrincipalBaseEntityType.cs", @"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorValue: ""PrincipalBase"");

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty(""Id"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var idPrincipalDerived = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.Table(""PrincipalDerived"", null),
                true,
                ""DerivedId"");
            overrides.Add(StoreObjectIdentifier.Table(""PrincipalDerived"", null), idPrincipalDerived);
            id.AddAnnotation(""Relational:RelationalOverrides"", overrides);

            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);

            var alternateId = runtimeEntityType.AddProperty(
                ""AlternateId"",
                typeof(Guid),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField(""AlternateId"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            alternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var point = runtimeEntityType.AddProperty(
                ""Point"",
                typeof(Point),
                nullable: true,
                valueGenerated: ValueGenerated.OnAdd,
                valueConverter: new CastingConverter<Point, Point>(),
                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>(),
                providerValueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
            point.AddAnnotation(""Relational:ColumnType"", ""geometry"");
            point.AddAnnotation(""Relational:DefaultValue"", (NetTopologySuite.Geometries.Point)new NetTopologySuite.IO.WKTReader().Read(""SRID=0;POINT Z(0 0 0)""));
            point.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });

            var key0 = runtimeEntityType.AddKey(
                new[] { id, alternateId });
            runtimeEntityType.SetPrimaryKey(key0);
            key0.AddAnnotation(""Relational:Name"", ""PK"");

            var index = runtimeEntityType.AddIndex(
                new[] { alternateId, id });

            return runtimeEntityType;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                ""Deriveds"",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty(""PrincipalsId"")!, joinEntityType.FindProperty(""PrincipalsAlternateId"")! },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty(""Id"")!, declaringEntityType.FindProperty(""AlternateId"")! })!,
                    declaringEntityType)!,
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty(""Deriveds"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField(""<Deriveds>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var inverse = targetEntityType.FindSkipNavigation(""Principals"");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:MappingStrategy"", ""TPT"");
            runtimeEntityType.AddAnnotation(""Relational:Schema"", ""mySchema"");
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""PrincipalBase"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "OwnedTypeEntityType.cs", @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class OwnedTypeEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true,
                changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);

            var principalBaseId = runtimeEntityType.AddProperty(
                ""PrincipalBaseId"",
                typeof(long),
                propertyAccessMode: PropertyAccessMode.Field,
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var principalBaseIdPrincipalBase = new RuntimeRelationalPropertyOverrides(
                principalBaseId,
                StoreObjectIdentifier.Table(""PrincipalBase"", ""mySchema""),
                false,
                null);
            principalBaseIdPrincipalBase.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
            overrides.Add(StoreObjectIdentifier.Table(""PrincipalBase"", ""mySchema""), principalBaseIdPrincipalBase);
            principalBaseId.AddAnnotation(""Relational:RelationalOverrides"", overrides);

            principalBaseId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);

            var principalBaseAlternateId = runtimeEntityType.AddProperty(
                ""PrincipalBaseAlternateId"",
                typeof(Guid),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalBaseAlternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var details = runtimeEntityType.AddProperty(
                ""Details"",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty(""Details"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField(""<Details>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);

            var overrides0 = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var detailsDetails = new RuntimeRelationalPropertyOverrides(
                details,
                StoreObjectIdentifier.Table(""Details"", null),
                false,
                null);
            overrides0.Add(StoreObjectIdentifier.Table(""Details"", null), detailsDetails);
            details.AddAnnotation(""Relational:RelationalOverrides"", overrides0);

            details.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var number = runtimeEntityType.AddProperty(
                ""Number"",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty(""Number"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField(""<Number>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field);
            number.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var context = runtimeEntityType.AddServiceProperty(
                ""Context"",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty(""Context"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var key = runtimeEntityType.AddKey(
                new[] { principalBaseId, principalBaseAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalBaseId"")!, declaringEntityType.FindProperty(""PrincipalBaseAlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")!, principalEntityType.FindProperty(""AlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true,
                ownership: true);

            var owned = principalEntityType.AddNavigation(""Owned"",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty(""Owned"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField(""_ownedField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalBaseId"")!, declaringEntityType.FindProperty(""PrincipalBaseAlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""PrincipalBaseId"")!, principalEntityType.FindProperty(""PrincipalBaseAlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var fragments = new StoreObjectDictionary<RuntimeEntityTypeMappingFragment>();
            var detailsFragment = new RuntimeEntityTypeMappingFragment(
                runtimeEntityType,
                StoreObjectIdentifier.Table(""Details"", null),
                null);
            fragments.Add(StoreObjectIdentifier.Table(""Details"", null), detailsFragment);
            runtimeEntityType.AddAnnotation(""Relational:MappingFragments"", fragments);
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", ""mySchema"");
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""PrincipalBase"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "OwnedType0EntityType.cs", @"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class OwnedType0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true);

            var principalDerivedId = runtimeEntityType.AddProperty(
                ""PrincipalDerivedId"",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalDerivedId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                ""PrincipalDerivedAlternateId"",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalDerivedAlternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);

            var details = runtimeEntityType.AddProperty(
                ""Details"",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty(""Details"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField(""<Details>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            details.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var number = runtimeEntityType.AddProperty(
                ""Number"",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty(""Number"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField(""<Number>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            number.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var context = runtimeEntityType.AddServiceProperty(
                ""Context"",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty(""Context"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var key = runtimeEntityType.AddKey(
                new[] { principalDerivedId, principalDerivedAlternateId, id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalDerivedId"")!, declaringEntityType.FindProperty(""PrincipalDerivedAlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")!, principalEntityType.FindProperty(""AlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var manyOwned = principalEntityType.AddNavigation(""ManyOwned"",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.OwnedType>),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField(""ManyOwned"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""ManyOwned"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);
            runtimeEntityType.AddAnnotation(""SqlServer:MemoryOptimized"", true);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs", @"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class PrincipalBasePrincipalDerivedDependentBasebyteEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""PrincipalBasePrincipalDerived<DependentBase<byte?>>"",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var derivedsId = runtimeEntityType.AddProperty(
                ""DerivedsId"",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var derivedsAlternateId = runtimeEntityType.AddProperty(
                ""DerivedsAlternateId"",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsAlternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var principalsId = runtimeEntityType.AddProperty(
                ""PrincipalsId"",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var principalsAlternateId = runtimeEntityType.AddProperty(
                ""PrincipalsAlternateId"",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsAlternateId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var rowid = runtimeEntityType.AddProperty(
                ""rowid"",
                typeof(byte[]),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            rowid.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalsId, principalsAlternateId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""DerivedsId"")!, declaringEntityType.FindProperty(""DerivedsAlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")!, principalEntityType.FindProperty(""AlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalsId"")!, declaringEntityType.FindProperty(""PrincipalsAlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")!, principalEntityType.FindProperty(""AlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientCascade,
                required: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""PrincipalBasePrincipalDerived<DependentBase<byte?>>"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "DependentDerivedEntityType.cs", @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class DependentDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>),
                baseEntityType,
                discriminatorProperty: ""EnumDiscriminator"",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.Two);

            var data = runtimeEntityType.AddProperty(
                ""Data"",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetProperty(""Data"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetField(""<Data>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 20,
                unicode: false);
            data.AddAnnotation(""Relational:IsFixedLength"", true);
            data.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var money = runtimeEntityType.AddProperty(
                ""Money"",
                typeof(decimal),
                precision: 9,
                scale: 3);
            money.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""DependentBase<byte?>"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "PrincipalDerivedEntityType.cs", @"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorValue: ""PrincipalDerived<DependentBase<byte?>>"");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""Id"")!, declaringEntityType.FindProperty(""AlternateId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")!, principalEntityType.FindProperty(""AlternateId"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                ""Principals"",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty(""DerivedsId"")!, joinEntityType.FindProperty(""DerivedsAlternateId"")! },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty(""Id"")!, declaringEntityType.FindProperty(""AlternateId"")! })!,
                    declaringEntityType)!,
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty(""Principals"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField(""<Principals>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            var inverse = targetEntityType.FindSkipNavigation(""Deriveds"");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""PrincipalDerived"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c)),
                model =>
                {
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetCollation()).Message);
                    Assert.Equal(new[]
                        {
                            RelationalAnnotationNames.MaxIdentifierLength,
                            SqlServerAnnotationNames.ValueGenerationStrategy
                        },
                        model.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, model.GetValueGenerationStrategy());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPropertyAccessMode()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.IdentitySeed]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetIdentitySeed()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.IdentityIncrement]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetIdentityIncrement()).Message);

                    Assert.Null(model.FindEntityType(typeof(AbstractBase)));
                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    Assert.Equal(typeof(PrincipalBase).FullName, principalBase.Name);
                    Assert.False(principalBase.HasSharedClrType);
                    Assert.False(principalBase.IsPropertyBag);
                    Assert.False(principalBase.IsOwned());
                    Assert.Null(principalBase.BaseType);
                    Assert.IsType<ConstructorBinding>(principalBase.ConstructorBinding);
                    Assert.Null(principalBase.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalBase.GetChangeTrackingStrategy());
                    Assert.Null(principalBase.GetQueryFilter());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Equal("mySchema", principalBase.GetSchema());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalBase.GetSeedData()).Message);

                    var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id));
                    Assert.Equal(new[]
                        {
                            RelationalAnnotationNames.RelationalOverrides,
                            SqlServerAnnotationNames.ValueGenerationStrategy
                        },
                        principalId.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(long?), principalId.ClrType);
                    Assert.Equal(typeof(long?), principalId.PropertyInfo.PropertyType);
                    Assert.Equal(typeof(long?), principalId.FieldInfo.FieldType);
                    Assert.False(principalId.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, principalId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, principalId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, principalId.GetBeforeSaveBehavior());
                    Assert.Null(principalId[CoreAnnotationNames.BeforeSaveBehavior]);
                    Assert.Null(principalId[CoreAnnotationNames.AfterSaveBehavior]);
                    Assert.Equal("Id", principalId.GetColumnName());
                    Assert.Equal("Id", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalBase", "mySchema")));
                    Assert.Equal("DerivedId", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalDerived")));
                    Assert.Equal("bigint", principalId.GetColumnType());
                    Assert.Null(principalId.GetValueConverter());
                    Assert.NotNull(principalId.GetValueComparer());
                    Assert.NotNull(principalId.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, principalId.GetValueGenerationStrategy());
                    Assert.Null(principalId[SqlServerAnnotationNames.IdentitySeed]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed()).Message);
                    Assert.Null(principalId[SqlServerAnnotationNames.IdentityIncrement]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement()).Message);

                    var pointProperty = principalBase.FindProperty("Point");
                    Assert.Equal(typeof(Point), pointProperty.ClrType);
                    Assert.True(pointProperty.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, pointProperty.ValueGenerated);
                    Assert.Equal("Point", pointProperty.GetColumnName());
                    Assert.Equal("geometry", pointProperty.GetColumnType());
                    Assert.Equal(0, ((Point)pointProperty.GetDefaultValue()).SRID);
                    Assert.IsType<CastingConverter<Point, Point>>(pointProperty.GetValueConverter());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetKeyValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetProviderValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, pointProperty.GetValueGenerationStrategy());
                    Assert.Null(pointProperty[CoreAnnotationNames.PropertyAccessMode]);

                    Assert.Null(principalBase.FindDiscriminatorProperty());

                    var principalAlternateId = principalBase.FindProperty(nameof(PrincipalBase.AlternateId));
                    var compositeIndex = principalBase.GetIndexes().Single();
                    Assert.Equal(PropertyAccessMode.FieldDuringConstruction, principalAlternateId.GetPropertyAccessMode());
                    Assert.Empty(compositeIndex.GetAnnotations());
                    Assert.Equal(new[] { principalAlternateId, principalId }, compositeIndex.Properties);
                    Assert.False(compositeIndex.IsUnique);
                    Assert.Null(compositeIndex.Name);
                    Assert.Equal("IX_PrincipalBase_AlternateId_Id", compositeIndex.GetDatabaseName());

                    Assert.Equal(new[] { compositeIndex }, principalAlternateId.GetContainingIndexes());

                    Assert.Equal(2, principalBase.GetKeys().Count());

                    var principalAlternateKey = principalBase.GetKeys().First();
                    Assert.Same(principalId, principalAlternateKey.Properties.Single());
                    Assert.False(principalAlternateKey.IsPrimaryKey());
                    Assert.Equal("AK_PrincipalBase_Id", principalAlternateKey.GetName());

                    var principalKey = principalBase.GetKeys().Last();
                    Assert.Equal(new[]
                        {
                            RelationalAnnotationNames.Name
                        },
                        principalKey.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(new[] { principalId, principalAlternateId }, principalKey.Properties);
                    Assert.True(principalKey.IsPrimaryKey());
                    Assert.Equal("PK", principalKey.GetName());
                    Assert.Null(principalKey[SqlServerAnnotationNames.Clustered]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalKey.IsClustered()).Message);

                    Assert.Equal(new[] { principalAlternateKey, principalKey }, principalId.GetContainingKeys());

                    var referenceOwnedNavigation = principalBase.GetNavigations().Single();
                    Assert.Equal(new[]
                        {
                            CoreAnnotationNames.EagerLoaded
                        },
                        referenceOwnedNavigation.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.Name);
                    Assert.False(referenceOwnedNavigation.IsCollection);
                    Assert.True(referenceOwnedNavigation.IsEagerLoaded);
                    Assert.False(referenceOwnedNavigation.IsOnDependent);
                    Assert.Equal(typeof(OwnedType), referenceOwnedNavigation.ClrType);
                    Assert.Equal("_ownedField", referenceOwnedNavigation.FieldInfo.Name);
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.PropertyInfo.Name);
                    Assert.Null(referenceOwnedNavigation.Inverse);
                    Assert.Equal(principalBase, referenceOwnedNavigation.DeclaringEntityType);
                    Assert.Equal(PropertyAccessMode.Field, referenceOwnedNavigation.GetPropertyAccessMode());
                    Assert.Null(referenceOwnedNavigation[CoreAnnotationNames.PropertyAccessMode]);

                    var referenceOwnedType = referenceOwnedNavigation.TargetEntityType;
                    Assert.Equal(typeof(PrincipalBase).FullName + ".Owned#OwnedType", referenceOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), referenceOwnedType.ClrType);
                    Assert.True(referenceOwnedType.HasSharedClrType);
                    Assert.False(referenceOwnedType.IsPropertyBag);
                    Assert.True(referenceOwnedType.IsOwned());
                    Assert.Null(referenceOwnedType.BaseType);
                    Assert.False(referenceOwnedType.IsMemoryOptimized());
                    Assert.IsType<ConstructorBinding>(referenceOwnedType.ConstructorBinding);
                    Assert.Null(referenceOwnedType.FindIndexerPropertyInfo());
                    Assert.Equal(
                        ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                        referenceOwnedType.GetChangeTrackingStrategy());
                    Assert.Null(referenceOwnedType.GetQueryFilter());
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.PropertyAccessMode]);
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.NavigationAccessMode]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetPropertyAccessMode()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetNavigationAccessMode()).Message);

                    var principalTable = StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value;

                    var ownedId = referenceOwnedType.FindProperty("PrincipalBaseId");
                    Assert.True(ownedId.IsPrimaryKey());
                    Assert.Equal(
                        SqlServerValueGenerationStrategy.IdentityColumn,
                        principalId.GetValueGenerationStrategy(principalTable));
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement(principalTable)).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed(principalTable)).Message);

                    var detailsProperty = referenceOwnedType.FindProperty(nameof(OwnedType.Details));
                    Assert.Null(detailsProperty[SqlServerAnnotationNames.Sparse]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.IsSparse()).Message);
                    Assert.Null(detailsProperty[RelationalAnnotationNames.Collation]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetCollation()).Message);

                    var ownedFragment = referenceOwnedType.GetMappingFragments().Single();
                    Assert.Equal(nameof(OwnedType.Details), detailsProperty.GetColumnName(ownedFragment.StoreObject));
                    Assert.Null(detailsProperty.GetColumnName(principalTable));

                    var referenceOwnership = referenceOwnedNavigation.ForeignKey;
                    Assert.Empty(referenceOwnership.GetAnnotations());
                    Assert.Same(referenceOwnership, referenceOwnedType.FindOwnership());
                    Assert.True(referenceOwnership.IsOwnership);
                    Assert.True(referenceOwnership.IsRequired);
                    Assert.True(referenceOwnership.IsRequiredDependent);
                    Assert.True(referenceOwnership.IsUnique);
                    Assert.Null(referenceOwnership.DependentToPrincipal);
                    Assert.Same(referenceOwnedNavigation, referenceOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, referenceOwnership.DeleteBehavior);
                    Assert.Equal(2, referenceOwnership.Properties.Count());
                    Assert.Same(principalKey, referenceOwnership.PrincipalKey);

                    var ownedServiceProperty = referenceOwnedType.GetServiceProperties().Single();
                    Assert.Empty(ownedServiceProperty.GetAnnotations());
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.ClrType);
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.PropertyInfo.PropertyType);
                    Assert.Null(ownedServiceProperty.FieldInfo);
                    Assert.Same(referenceOwnedType, ownedServiceProperty.DeclaringEntityType);
                    var ownedServicePropertyBinding = ownedServiceProperty.ParameterBinding;
                    Assert.IsType<ContextParameterBinding>(ownedServicePropertyBinding);
                    Assert.Equal(typeof(DbContext), ownedServicePropertyBinding.ServiceType);
                    Assert.Equal(ownedServiceProperty, ownedServicePropertyBinding.ConsumedProperties.Single());
                    Assert.Equal(PropertyAccessMode.PreferField, ownedServiceProperty.GetPropertyAccessMode());
                    Assert.Null(ownedServiceProperty[CoreAnnotationNames.PropertyAccessMode]);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);
                    Assert.Equal(
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+"
                        + "PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                        principalDerived.Name);
                    Assert.False(principalDerived.IsOwned());
                    Assert.IsType<ConstructorBinding>(principalDerived.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalDerived.GetChangeTrackingStrategy());
                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());

                    var tptForeignKey = principalDerived.GetForeignKeys().Single();
                    Assert.False(tptForeignKey.IsOwnership);
                    Assert.True(tptForeignKey.IsRequired);
                    Assert.False(tptForeignKey.IsRequiredDependent);
                    Assert.True(tptForeignKey.IsUnique);
                    Assert.Null(tptForeignKey.DependentToPrincipal);
                    Assert.Null(tptForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, tptForeignKey.DeleteBehavior);
                    Assert.Equal(principalKey.Properties, tptForeignKey.Properties);
                    Assert.Same(principalKey, tptForeignKey.PrincipalKey);

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.True(dependentNavigation.IsEagerLoaded);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var ownedCollectionNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.Name);
                    Assert.Null(ownedCollectionNavigation.PropertyInfo);
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<OwnedType>), ownedCollectionNavigation.ClrType);
                    Assert.True(ownedCollectionNavigation.IsCollection);
                    Assert.True(ownedCollectionNavigation.IsEagerLoaded);
                    Assert.False(ownedCollectionNavigation.IsOnDependent);
                    Assert.Null(ownedCollectionNavigation.Inverse);
                    Assert.Equal(principalDerived, ownedCollectionNavigation.DeclaringEntityType);

                    var collectionOwnedType = ownedCollectionNavigation.TargetEntityType;
                    Assert.Equal(principalDerived.Name + ".ManyOwned#OwnedType", collectionOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), collectionOwnedType.ClrType);
                    Assert.True(collectionOwnedType.HasSharedClrType);
                    Assert.False(collectionOwnedType.IsPropertyBag);
                    Assert.True(collectionOwnedType.IsOwned());
                    Assert.True(collectionOwnedType.IsMemoryOptimized());
                    Assert.Null(collectionOwnedType[RelationalAnnotationNames.IsTableExcludedFromMigrations]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => collectionOwnedType.IsTableExcludedFromMigrations()).Message);
                    Assert.Null(collectionOwnedType.BaseType);
                    Assert.IsType<ConstructorBinding>(collectionOwnedType.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, collectionOwnedType.GetChangeTrackingStrategy());

                    var collectionOwnership = ownedCollectionNavigation.ForeignKey;
                    Assert.Same(collectionOwnership, collectionOwnedType.FindOwnership());
                    Assert.True(collectionOwnership.IsOwnership);
                    Assert.True(collectionOwnership.IsRequired);
                    Assert.False(collectionOwnership.IsRequiredDependent);
                    Assert.False(collectionOwnership.IsUnique);
                    Assert.Null(collectionOwnership.DependentToPrincipal);
                    Assert.Same(ownedCollectionNavigation, collectionOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, collectionOwnership.DeleteBehavior);
                    Assert.Equal(2, collectionOwnership.Properties.Count());

                    var derivedSkipNavigation = principalDerived.GetDeclaredSkipNavigations().Single();
                    Assert.Equal("Principals", derivedSkipNavigation.Name);
                    Assert.Equal("Principals", derivedSkipNavigation.PropertyInfo.Name);
                    Assert.Equal("<Principals>k__BackingField", derivedSkipNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<PrincipalBase>), derivedSkipNavigation.ClrType);
                    Assert.True(derivedSkipNavigation.IsCollection);
                    Assert.True(derivedSkipNavigation.IsEagerLoaded);
                    Assert.False(derivedSkipNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, derivedSkipNavigation.DeclaringEntityType);
                    Assert.Equal("Deriveds", derivedSkipNavigation.Inverse.Name);
                    Assert.Same(principalBase.GetSkipNavigations().Single(), derivedSkipNavigation.Inverse);

                    Assert.Same(derivedSkipNavigation, derivedSkipNavigation.ForeignKey.GetReferencingSkipNavigations().Single());
                    Assert.Same(
                        derivedSkipNavigation.Inverse, derivedSkipNavigation.Inverse.ForeignKey.GetReferencingSkipNavigations().Single());

                    Assert.Equal(new[] { derivedSkipNavigation.Inverse, derivedSkipNavigation }, principalDerived.GetSkipNavigations());

                    var joinType = derivedSkipNavigation.JoinEntityType;

                    Assert.Equal("PrincipalBasePrincipalDerived<DependentBase<byte?>>", joinType.Name);
                    Assert.Equal(typeof(Dictionary<string, object>), joinType.ClrType);
                    Assert.True(joinType.HasSharedClrType);
                    Assert.True(joinType.IsPropertyBag);
                    Assert.False(joinType.IsOwned());
                    Assert.Null(joinType.BaseType);
                    Assert.IsType<ConstructorBinding>(joinType.ConstructorBinding);
                    Assert.Equal("Item", joinType.FindIndexerPropertyInfo().Name);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, joinType.GetChangeTrackingStrategy());
                    Assert.Null(joinType[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => joinType.GetComment()).Message);
                    Assert.Null(joinType.GetQueryFilter());

                    var rowid = joinType.GetProperties().Single(p => !p.IsForeignKey());
                    Assert.Equal(typeof(byte[]), rowid.ClrType);
                    Assert.True(rowid.IsIndexerProperty());
                    Assert.Same(joinType.FindIndexerPropertyInfo(), rowid.PropertyInfo);
                    Assert.Null(rowid.FieldInfo);
                    Assert.True(rowid.IsNullable);
                    Assert.False(rowid.IsShadowProperty());
                    Assert.True(rowid.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, rowid.ValueGenerated);
                    Assert.Equal("rowid", rowid.GetColumnName());
                    Assert.Equal("rowversion", rowid.GetColumnType());
                    Assert.Null(rowid[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetComment()).Message);
                    Assert.Null(rowid[RelationalAnnotationNames.ColumnOrder]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetColumnOrder()).Message);
                    Assert.Null(rowid.GetValueConverter());
                    Assert.NotNull(rowid.GetValueComparer());
                    Assert.NotNull(rowid.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, rowid.GetValueGenerationStrategy());

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.True(dependentForeignKey.IsRequired);
                    Assert.False(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientNoAction, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId", "PrincipalAlternateId" }, dependentForeignKey.Properties.Select(p => p.Name));
                    Assert.Same(principalKey, dependentForeignKey.PrincipalKey);

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.False(dependentBase.GetIsDiscriminatorMappingComplete());
                    var principalDiscriminator = dependentBase.FindDiscriminatorProperty();
                    Assert.IsType<DiscriminatorValueGenerator>(
                        principalDiscriminator.GetValueGeneratorFactory()(principalDiscriminator, dependentBase));
                    Assert.Equal(Enum1.One, dependentBase.GetDiscriminatorValue());

                    var dependentBaseForeignKey = dependentBase.GetForeignKeys().Single(fk => fk != dependentForeignKey);
                    var dependentForeignKeyProperty = dependentBaseForeignKey.Properties.Single();

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, dependentForeignKey }, dependentForeignKeyProperty.GetContainingForeignKeys());

                    var dependentDerived = dependentBase.GetDerivedTypes().Single();
                    Assert.Equal(Enum1.Two, dependentDerived.GetDiscriminatorValue());

                    Assert.Equal(2, dependentDerived.GetDeclaredProperties().Count());

                    var dependentData = dependentDerived.GetDeclaredProperties().First();
                    Assert.Equal(typeof(string), dependentData.ClrType);
                    Assert.Equal("Data", dependentData.Name);
                    Assert.Equal("Data", dependentData.PropertyInfo.Name);
                    Assert.Equal("<Data>k__BackingField", dependentData.FieldInfo.Name);
                    Assert.True(dependentData.IsNullable);
                    Assert.False(dependentData.IsShadowProperty());
                    Assert.False(dependentData.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentData.ValueGenerated);
                    Assert.Equal("Data", dependentData.GetColumnName());
                    Assert.Equal("char(20)", dependentData.GetColumnType());
                    Assert.Equal(20, dependentData.GetMaxLength());
                    Assert.False(dependentData.IsUnicode());
                    Assert.True(dependentData.IsFixedLength());
                    Assert.Null(dependentData.GetPrecision());
                    Assert.Null(dependentData.GetScale());

                    var dependentMoney = dependentDerived.GetDeclaredProperties().Last();
                    Assert.Equal(typeof(decimal), dependentMoney.ClrType);
                    Assert.Equal("Money", dependentMoney.Name);
                    Assert.Null(dependentMoney.PropertyInfo);
                    Assert.Null(dependentMoney.FieldInfo);
                    Assert.False(dependentMoney.IsNullable);
                    Assert.True(dependentMoney.IsShadowProperty());
                    Assert.False(dependentMoney.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentMoney.ValueGenerated);
                    Assert.Equal("Money", dependentMoney.GetColumnName());
                    Assert.Equal("decimal(9,3)", dependentMoney.GetColumnType());
                    Assert.Null(dependentMoney.GetMaxLength());
                    Assert.Null(dependentMoney.IsUnicode());
                    Assert.Null(dependentMoney.IsFixedLength());
                    Assert.Equal(9, dependentMoney.GetPrecision());
                    Assert.Equal(3, dependentMoney.GetScale());

                    Assert.Equal(
                        new[]
                        {
                            derivedSkipNavigation.ForeignKey,
                            tptForeignKey,
                            referenceOwnership,
                            collectionOwnership,
                            dependentForeignKey,
                            derivedSkipNavigation.Inverse.ForeignKey
                        },
                        principalKey.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, tptForeignKey, referenceOwnership, derivedSkipNavigation.Inverse.ForeignKey },
                        principalBase.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { derivedSkipNavigation.ForeignKey, collectionOwnership, dependentForeignKey },
                        principalDerived.GetDeclaredReferencingForeignKeys());

                    Assert.Equal(
                        new[]
                        {
                            dependentBase,
                            dependentDerived,
                            principalBase,
                            referenceOwnedType,
                            principalDerived,
                            collectionOwnedType,
                            joinType
                        },
                        model.GetEntityTypes());
                },
                typeof(SqlServerNetTopologySuiteDesignTimeServices),
                c =>
                {
                    c.Set<PrincipalDerived<DependentBase<byte?>>>().Add(
                        new PrincipalDerived<DependentBase<byte?>>
                        {
                            AlternateId = new Guid(),
                            Dependent = new DependentBase<byte?>(1),
                            Owned = new OwnedType(c)
                        });

                    c.SaveChanges();
                });

        public class BigContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder
                    .UseCollation("Latin1_General_CS_AS")
                    .UseIdentityColumns(3, 2);

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        eb.Property(e => e.Id).UseIdentityColumn(2, 3)
                            .Metadata.SetColumnName("DerivedId", StoreObjectIdentifier.Table("PrincipalDerived"));

                        eb.Property(e => e.AlternateId)
                            .UsePropertyAccessMode(PropertyAccessMode.FieldDuringConstruction);

                        eb.Property<Point>("Point")
                            .HasColumnType("geometry")
                            .HasDefaultValue(
                                NtsGeometryServices.Instance.CreateGeometryFactory(srid: 0).CreatePoint(new CoordinateZM(0, 0, 0, 0)))
                            .HasConversion<CastingConverter<Point, Point>, CustomValueComparer<Point>, CustomValueComparer<Point>>();

                        eb.HasIndex(e => new { e.AlternateId, e.Id });

                        eb.HasKey(e => new { e.Id, e.AlternateId })
                            .HasName("PK")
                            .IsClustered();

                        eb.HasAlternateKey(e => e.Id);

                        eb.OwnsOne(
                            e => e.Owned, ob =>
                            {
                                ob.HasChangeTrackingStrategy(ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);
                                ob.UsePropertyAccessMode(PropertyAccessMode.Field);
                                ob.Property(e => e.Details)
                                    .IsSparse()
                                    .UseCollation("Latin1_General_CI_AI");

                                ob.ToTable("PrincipalBase", "mySchema",
                                    t => t.Property("PrincipalBaseId").UseIdentityColumn(2, 3));

                                ob.SplitToTable("Details", s => s.Property(e => e.Details));

                                ob.HasData(new { Number = 10, PrincipalBaseId = 1L, PrincipalBaseAlternateId = new Guid() });
                            });

                        eb.Navigation(e => e.Owned).IsRequired().HasField("_ownedField")
                            .UsePropertyAccessMode(PropertyAccessMode.Field);

                        eb.HasData(new PrincipalBase { Id = 1, AlternateId = new Guid() });

                        eb.ToTable("PrincipalBase", "mySchema");
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        eb.HasOne(e => e.Dependent).WithOne(e => e.Principal)
                            .HasForeignKey<DependentBase<byte?>>()
                            .OnDelete(DeleteBehavior.ClientNoAction);

                        eb.Navigation(e => e.Dependent).AutoInclude();

                        eb.OwnsMany(
                            typeof(OwnedType).FullName, "ManyOwned", ob =>
                            {
                                ob.ToTable("ManyOwned", t => t.IsMemoryOptimized().ExcludeFromMigrations());
                            });

                        eb.HasMany(e => e.Principals).WithMany(e => (ICollection<PrincipalDerived<DependentBase<byte?>>>)e.Deriveds)
                            .UsingEntity(
                                jb =>
                                {
                                    jb.ToTable(tb => tb.HasComment("Join table"));
                                    jb.Property<byte[]>("rowid")
                                        .IsRowVersion()
                                        .HasComment("RowVersion")
                                        .HasColumnOrder(1);
                                });

                        eb.Navigation(e => e.Principals).AutoInclude();

                        eb.ToTable("PrincipalDerived");
                    });

                modelBuilder.Entity<DependentBase<byte?>>(
                    eb =>
                    {
                        eb.Property<byte?>("Id");

                        eb.HasKey("PrincipalId", "PrincipalAlternateId");

                        eb.HasOne<PrincipalBase>().WithOne()
                            .HasForeignKey<DependentBase<byte?>>("PrincipalId")
                            .HasPrincipalKey<PrincipalBase>(e => e.Id);

                        eb.HasDiscriminator<Enum1>("EnumDiscriminator")
                            .HasValue(Enum1.One)
                            .HasValue<DependentDerived<byte?>>(Enum1.Two)
                            .IsComplete(false);
                    });

                modelBuilder.Entity<DependentDerived<byte?>>(
                    eb =>
                    {
                        eb.Property<string>("Data")
                            .HasMaxLength(20)
                            .IsFixedLength()
                            .IsUnicode(false);

                        eb.Property<decimal>("Money")
                            .HasPrecision(9, 3);
                    });
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
            {
                SqlServerTestStore.Create("RuntimeModelTest" + GetType().Name).AddProviderOptions(options);
                new SqlServerDbContextOptionsBuilder(options).UseNetTopologySuite();
            }
        }

        [ConditionalFact]
        public void TPC_model()
            => Test(
                new TpcContext(),
                new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
                code =>
                    Assert.Collection(
                        code,
                        c => AssertFileContents(
                            "TpcContextModel.cs",
                            @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TpcContext))]
    public partial class TpcContextModel : RuntimeModel
    {
        static TpcContextModel()
        {
            var model = new TpcContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static TpcContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
", c),
                        c => AssertFileContents(
                            "TpcContextModelBuilder.cs",
                            @"// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    public partial class TpcContextModel
    {
        partial void Initialize()
        {
            var dependentBase = DependentBaseEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalDerived);
            PrincipalBaseEntityType.CreateForeignKey1(principalBase, principalBase);
            PrincipalBaseEntityType.CreateForeignKey2(principalBase, principalDerived);

            DependentBaseEntityType.CreateAnnotations(dependentBase);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            var sequences = new SortedDictionary<(string, string?), ISequence>();
            var principalBaseSequence = new RuntimeSequence(
                ""PrincipalBaseSequence"",
                this,
                typeof(long),
                schema: ""TPC"",
                modelSchemaIsNull: true);

            sequences[(""PrincipalBaseSequence"", null)] = principalBaseSequence;

            AddAnnotation(""Relational:Sequences"", sequences);
            AddAnnotation(""Relational:DefaultSchema"", ""TPC"");
            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
", c),
                        c => AssertFileContents(
                            "DependentBaseEntityType.cs", @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty(""Id"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var principalId = runtimeEntityType.AddProperty(
                ""PrincipalId"",
                typeof(long?),
                nullable: true);
            principalId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")! })!,
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientCascade,
                unique: true,
                requiredDependent: true);

            var principal = declaringEntityType.AddNavigation(""Principal"",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty(""Principal"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField(""<Principal>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation(""Dependent"",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty(""Dependent"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField(""<Dependent>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", ""TPC"");
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""DependentBase<byte?>"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "PrincipalBaseEntityType.cs", @"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorValue: ""PrincipalBase"");

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty(""Id"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField(""<Id>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var idDerivedInsert = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.InsertStoredProcedure(""Derived_Insert"", ""TPC""),
                true,
                ""DerivedId"");
            overrides.Add(StoreObjectIdentifier.InsertStoredProcedure(""Derived_Insert"", ""TPC""), idDerivedInsert);
            var idPrincipalBaseView = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.View(""PrincipalBaseView"", ""TPC""),
                false,
                null);
            idPrincipalBaseView.AddAnnotation(""foo"", ""bar2"");
            overrides.Add(StoreObjectIdentifier.View(""PrincipalBaseView"", ""TPC""), idPrincipalBaseView);
            id.AddAnnotation(""Relational:RelationalOverrides"", overrides);

            id.AddAnnotation(""Relational:DefaultValueSql"", ""NEXT VALUE FOR [TPC].[PrincipalBaseSequence]"");
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.Sequence);

            var principalBaseId = runtimeEntityType.AddProperty(
                ""PrincipalBaseId"",
                typeof(long?),
                nullable: true);
            principalBaseId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var principalDerivedId = runtimeEntityType.AddProperty(
                ""PrincipalDerivedId"",
                typeof(long?),
                nullable: true);
            principalDerivedId.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalDerivedId });

            var principalIndex = runtimeEntityType.AddIndex(
                new[] { principalBaseId },
                name: ""PrincipalIndex"",
                unique: true);
            principalIndex.AddAnnotation(""Relational:Name"", ""PIX"");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalBaseId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")! })!,
                principalEntityType);

            var deriveds = principalEntityType.AddNavigation(""Deriveds"",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty(""Deriveds"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField(""<Deriveds>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty(""PrincipalDerivedId"")! },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty(""Id"")! })!,
                principalEntityType);

            var principals = principalEntityType.AddNavigation(""Principals"",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty(""Principals"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField(""<Principals>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var insertSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                ""PrincipalBase_Insert"",
                ""TPC"",
                false);

            var principalBaseId = insertSproc.AddParameter(
                ""PrincipalBaseId"", ParameterDirection.Input, false, ""PrincipalBaseId"", false);
            var principalDerivedId = insertSproc.AddParameter(
                ""PrincipalDerivedId"", ParameterDirection.Input, false, ""PrincipalDerivedId"", false);
            var baseId = insertSproc.AddParameter(
                ""BaseId"", ParameterDirection.Output, false, ""Id"", false);
            baseId.AddAnnotation(""foo"", ""bar"");
            insertSproc.AddAnnotation(""foo"", ""bar1"");
            runtimeEntityType.AddAnnotation(""Relational:InsertStoredProcedure"", insertSproc);

            var deleteSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                ""PrincipalBase_Delete"",
                ""TPC"",
                true);

            var id = deleteSproc.AddParameter(
                ""Id"", ParameterDirection.Input, false, ""Id"", false);
            runtimeEntityType.AddAnnotation(""Relational:DeleteStoredProcedure"", deleteSproc);

            var updateSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                ""PrincipalBase_Update"",
                ""TPC"",
                false);

            var principalBaseId0 = updateSproc.AddParameter(
                ""PrincipalBaseId"", ParameterDirection.Input, false, ""PrincipalBaseId"", false);
            var principalDerivedId0 = updateSproc.AddParameter(
                ""PrincipalDerivedId"", ParameterDirection.Input, false, ""PrincipalDerivedId"", false);
            var id0 = updateSproc.AddParameter(
                ""Id"", ParameterDirection.Input, false, ""Id"", false);
            runtimeEntityType.AddAnnotation(""Relational:UpdateStoredProcedure"", updateSproc);

            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:MappingStrategy"", ""TPC"");
            runtimeEntityType.AddAnnotation(""Relational:Schema"", ""TPC"");
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""PrincipalBase"");
            runtimeEntityType.AddAnnotation(""Relational:ViewDefinitionSql"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", ""PrincipalBaseView"");
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", ""TPC"");

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c),
                        c => AssertFileContents(
                            "PrincipalDerivedEntityType.cs", @"// <auto-generated />
using System;
using System.Data;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable enable

namespace TestNamespace
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorValue: ""PrincipalDerived<DependentBase<byte?>>"");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var insertSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                ""Derived_Insert"",
                ""TPC"",
                false);

            var principalBaseId = insertSproc.AddParameter(
                ""PrincipalBaseId"", ParameterDirection.Input, false, ""PrincipalBaseId"", false);
            var principalDerivedId = insertSproc.AddParameter(
                ""PrincipalDerivedId"", ParameterDirection.Input, false, ""PrincipalDerivedId"", false);
            var derivedId = insertSproc.AddResultColumn(
                ""DerivedId"", false, ""Id"");
            derivedId.AddAnnotation(""foo"", ""bar3"");
            runtimeEntityType.AddAnnotation(""Relational:InsertStoredProcedure"", insertSproc);

            var deleteSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                ""Derived_Delete"",
                ""TPC"",
                false);

            var id = deleteSproc.AddParameter(
                ""Id"", ParameterDirection.Input, false, ""Id"", false);
            runtimeEntityType.AddAnnotation(""Relational:DeleteStoredProcedure"", deleteSproc);

            var updateSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                ""Derived_Update"",
                ""Derived"",
                false);

            var principalBaseId0 = updateSproc.AddParameter(
                ""PrincipalBaseId"", ParameterDirection.Input, false, ""PrincipalBaseId"", false);
            var principalDerivedId0 = updateSproc.AddParameter(
                ""PrincipalDerivedId"", ParameterDirection.Input, false, ""PrincipalDerivedId"", false);
            var id0 = updateSproc.AddParameter(
                ""Id"", ParameterDirection.Input, false, ""Id"", false);
            runtimeEntityType.AddAnnotation(""Relational:UpdateStoredProcedure"", updateSproc);

            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", ""TPC"");
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""PrincipalDerived"");
            runtimeEntityType.AddAnnotation(""Relational:ViewDefinitionSql"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", ""PrincipalDerivedView"");
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", ""TPC"");

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
", c)),
                model =>
                {
                    Assert.Equal("TPC", model.GetDefaultSchema());
                    Assert.Null(model[SqlServerAnnotationNames.MaxDatabaseSize]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetDatabaseMaxSize()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.PerformanceLevelSql]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPerformanceLevelSql()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.ServiceTierSql]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetServiceTierSql()).Message);

                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    var id = principalBase.FindProperty("Id");

                    Assert.Equal("Id", id.GetColumnName());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Equal("TPC", principalBase.GetSchema());
                    Assert.Equal("Id", id.GetColumnName(StoreObjectIdentifier.Create(principalBase, StoreObjectType.Table).Value));
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.Table).Value));

                    Assert.Equal("PrincipalBaseView", principalBase.GetViewName());
                    Assert.Equal("TPC", principalBase.GetViewSchema());
                    Assert.Equal("Id", id.GetColumnName(StoreObjectIdentifier.Create(principalBase, StoreObjectType.View).Value));
                    Assert.Equal(
                        "bar2",
                        id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.View).Value)["foo"]);

                    var principalBaseId = principalBase.FindProperty("PrincipalBaseId");

                    var alternateIndex = principalBase.GetIndexes().Last();
                    Assert.Same(principalBaseId, alternateIndex.Properties.Single());
                    Assert.True(alternateIndex.IsUnique);
                    Assert.Equal("PrincipalIndex", alternateIndex.Name);
                    Assert.Equal("PIX", alternateIndex.GetDatabaseName());
                    Assert.Null(alternateIndex[RelationalAnnotationNames.Filter]);
                    Assert.Null(alternateIndex.GetFilter());
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.Clustered]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.IsClustered()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.CreatedOnline]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.IsCreatedOnline()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.FillFactor]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetFillFactor()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.Include]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetIncludeProperties()).Message);

                    Assert.Equal(new[] { alternateIndex }, principalBaseId.GetContainingIndexes());

                    var insertSproc = principalBase.GetInsertStoredProcedure()!;
                    Assert.Equal("PrincipalBase_Insert", insertSproc.Name);
                    Assert.Equal("TPC", insertSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Id" }, insertSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(insertSproc.ResultColumns);
                    Assert.False(insertSproc.IsRowsAffectedReturned);
                    Assert.Equal("bar1", insertSproc["foo"]);
                    Assert.Same(principalBase, insertSproc.EntityType);
                    Assert.Equal("BaseId", insertSproc.Parameters.Last().Name);
                    Assert.Equal("bar", insertSproc.Parameters.Last()["foo"]);
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.InsertStoredProcedure).Value));

                    var updateSproc = principalBase.GetUpdateStoredProcedure()!;
                    Assert.Equal("PrincipalBase_Update", updateSproc.Name);
                    Assert.Equal("TPC", updateSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Id" }, updateSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(updateSproc.ResultColumns);
                    Assert.False(updateSproc.IsRowsAffectedReturned);
                    Assert.Empty(updateSproc.GetAnnotations());
                    Assert.Same(principalBase, updateSproc.EntityType);
                    Assert.Equal("Id", updateSproc.Parameters.Last().Name);
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.UpdateStoredProcedure).Value));

                    var deleteSproc = principalBase.GetDeleteStoredProcedure()!;
                    Assert.Equal("PrincipalBase_Delete", deleteSproc.Name);
                    Assert.Equal("TPC", deleteSproc.Schema);
                    Assert.Equal(new[] { "Id" }, deleteSproc.Parameters.Select(p => p.Name));
                    Assert.Empty(deleteSproc.ResultColumns);
                    Assert.True(deleteSproc.IsRowsAffectedReturned);
                    Assert.Same(principalBase, deleteSproc.EntityType);
                    Assert.Equal("Id", deleteSproc.Parameters.Last().Name);
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.DeleteStoredProcedure).Value));

                    Assert.Equal("PrincipalBase", principalBase.GetDiscriminatorValue());
                    Assert.Null(principalBase.FindDiscriminatorProperty());
                    Assert.Equal("TPC", principalBase.GetMappingStrategy());

                    var selfRefNavigation = principalBase.GetDeclaredNavigations().Last();
                    Assert.Equal("Deriveds", selfRefNavigation.Name);
                    Assert.True(selfRefNavigation.IsCollection);
                    Assert.False(selfRefNavigation.IsOnDependent);
                    Assert.Equal(principalBase, selfRefNavigation.TargetEntityType);
                    Assert.Null(selfRefNavigation.Inverse);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);

                    Assert.Equal("PrincipalDerived", principalDerived.GetTableName());
                    Assert.Equal("TPC", principalDerived.GetSchema());
                    Assert.Equal("PrincipalDerivedView", principalDerived.GetViewName());
                    Assert.Equal("TPC", principalBase.GetViewSchema());

                    insertSproc = principalDerived.GetInsertStoredProcedure()!;
                    Assert.Equal("Derived_Insert", insertSproc.Name);
                    Assert.Equal("TPC", insertSproc.Schema);
                    Assert.Equal(new[] { "PrincipalBaseId", "PrincipalDerivedId" }, insertSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Equal(new[] { "Id" }, insertSproc.ResultColumns.Select(p => p.PropertyName));
                    Assert.Null(insertSproc["foo"]);
                    Assert.Same(principalDerived, insertSproc.EntityType);
                    Assert.Equal("DerivedId", insertSproc.ResultColumns.Last().Name);
                    Assert.Equal(
                        "DerivedId",
                        id.GetColumnName(StoreObjectIdentifier.Create(principalDerived, StoreObjectType.InsertStoredProcedure).Value));
                    Assert.Equal("bar3", insertSproc.ResultColumns.Last()["foo"]);
                    Assert.Null(
                        id.FindOverrides(
                            StoreObjectIdentifier.Create(principalDerived, StoreObjectType.InsertStoredProcedure).Value)["foo"]);

                    updateSproc = principalDerived.GetUpdateStoredProcedure()!;
                    Assert.Equal("Derived_Update", updateSproc.Name);
                    Assert.Equal("Derived", updateSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Id" }, updateSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(updateSproc.ResultColumns);
                    Assert.Empty(updateSproc.GetAnnotations());
                    Assert.Same(principalDerived, updateSproc.EntityType);
                    Assert.Equal("Id", updateSproc.Parameters.Last().Name);
                    Assert.Null(
                        id.FindOverrides(StoreObjectIdentifier.Create(principalDerived, StoreObjectType.UpdateStoredProcedure).Value));

                    deleteSproc = principalDerived.GetDeleteStoredProcedure()!;
                    Assert.Equal("Derived_Delete", deleteSproc.Name);
                    Assert.Equal("TPC", deleteSproc.Schema);
                    Assert.Equal(new[] { "Id" }, deleteSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(deleteSproc.ResultColumns);
                    Assert.Same(principalDerived, deleteSproc.EntityType);
                    Assert.Equal("Id", deleteSproc.Parameters.Last().Name);
                    Assert.Null(
                        id.FindOverrides(StoreObjectIdentifier.Create(principalDerived, StoreObjectType.DeleteStoredProcedure).Value));

                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());
                    Assert.Null(principalDerived.FindDiscriminatorProperty());
                    Assert.Equal("TPC", principalDerived.GetMappingStrategy());

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var derivedNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("Principals", derivedNavigation.Name);
                    Assert.True(derivedNavigation.IsCollection);
                    Assert.False(derivedNavigation.IsOnDependent);
                    Assert.Equal(principalBase, derivedNavigation.TargetEntityType);
                    Assert.Null(derivedNavigation.Inverse);

                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.False(dependentNavigation.IsEagerLoaded);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.False(dependentForeignKey.IsRequired);
                    Assert.True(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(principalDerived, dependentForeignKey.PrincipalEntityType);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientCascade, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId" }, dependentForeignKey.Properties.Select(p => p.Name));

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.True(dependentBase.GetIsDiscriminatorMappingComplete());
                    Assert.Null(dependentBase.FindDiscriminatorProperty());

                    Assert.Same(dependentForeignKey, dependentBase.GetForeignKeys().Single());

                    Assert.Equal(
                        new[] { dependentBase, principalBase, principalDerived },
                        model.GetEntityTypes());

                    var principalBaseSequence = model.FindSequence("PrincipalBaseSequence");
                    Assert.Equal("TPC", principalBaseSequence.Schema);
                },
                typeof(SqlServerNetTopologySuiteDesignTimeServices));

        public class TpcContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDefaultSchema("TPC")
                    .HasDatabaseMaxSize("20TB")
                    .HasPerformanceLevel("High")
                    .HasServiceTier("AB");

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        eb.Ignore(e => e.Owned);

                        eb.UseTpcMappingStrategy();

                        eb.ToTable("PrincipalBase");
                        eb.ToView("PrincipalBaseView", tb => tb.Property(e => e.Id).HasAnnotation("foo", "bar2"));

                        eb.InsertUsingStoredProcedure(s => s
                            .HasParameter("PrincipalBaseId")
                            .HasParameter("PrincipalDerivedId")
                            .HasParameter(p => p.Id, pb => pb.HasName("BaseId").IsOutput().HasAnnotation("foo", "bar"))
                            .HasAnnotation("foo", "bar1"));
                        eb.UpdateUsingStoredProcedure(s => s
                            .HasParameter("PrincipalBaseId")
                            .HasParameter("PrincipalDerivedId")
                            .HasParameter(p => p.Id));
                        eb.DeleteUsingStoredProcedure(s => s
                            .HasRowsAffectedReturnValue()
                            .HasParameter(p => p.Id));

                        eb.HasIndex(new[] { "PrincipalBaseId" }, "PrincipalIndex")
                            .IsUnique()
                            .HasDatabaseName("PIX")
                            .IsClustered()
                            .HasFilter("AlternateId <> NULL")
                            .IsCreatedOnline()
                            .HasFillFactor(40)
                            .IncludeProperties(e => e.Id);
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        eb.HasOne(e => e.Dependent).WithOne(e => e.Principal)
                            .HasForeignKey<DependentBase<byte?>>()
                            .OnDelete(DeleteBehavior.ClientCascade);

                        eb.Navigation(e => e.Dependent).IsRequired();

                        eb.ToTable("PrincipalDerived");
                        eb.ToView("PrincipalDerivedView");

                        eb.InsertUsingStoredProcedure("Derived_Insert", s => s
                            .HasParameter("PrincipalBaseId")
                            .HasParameter("PrincipalDerivedId")
                            .HasResultColumn(p => p.Id, pb => pb.HasName("DerivedId").HasAnnotation("foo", "bar3")));
                        eb.UpdateUsingStoredProcedure("Derived_Update", "Derived", s => s
                            .HasParameter("PrincipalBaseId")
                            .HasParameter("PrincipalDerivedId")
                            .HasParameter(p => p.Id));
                        eb.DeleteUsingStoredProcedure("Derived_Delete", s => s
                            .HasParameter(p => p.Id));
                    });

                modelBuilder.Entity<DependentBase<byte?>>(
                    eb =>
                    {
                        eb.Property<byte?>("Id");
                    });
            }
        }

        public class CustomValueComparer<T> : ValueComparer<T>
        {
            public CustomValueComparer()
                : base(false)
            {
            }
        }

        public abstract class AbstractBase
        {
            public int Id { get; set; }
        }

        public class PrincipalBase : AbstractBase
        {
            public new long? Id { get; set; }
            public Guid AlternateId;

            private OwnedType _ownedField;
            public OwnedType Owned { get => _ownedField; set => _ownedField = value; }
            public ICollection<PrincipalBase> Deriveds { get; set; }
        }

        public class PrincipalDerived<TDependent> : PrincipalBase
        {
            public TDependent Dependent { get; set; }
            protected ICollection<OwnedType> ManyOwned;
            public ICollection<PrincipalBase> Principals { get; set; }
        }

        public class DependentBase<TKey> : AbstractBase
        {
            public DependentBase(TKey id)
            {
                Id = id;
            }

            private new TKey Id { get; init; }

            public PrincipalDerived<DependentBase<TKey>> Principal { get; set; }
        }

        public class DependentDerived<TKey> : DependentBase<TKey>
        {
            public DependentDerived(TKey id)
                : base(id)
            {
            }

            private string Data { get; set; }
        }

        public class OwnedType : INotifyPropertyChanged, INotifyPropertyChanging
        {
            private DbContext _context;

            public OwnedType(DbContext context)
            {
                Context = context;
            }

            public DbContext Context
            {
                get => _context;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Context"));
                    _context = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs("Context"));
                }
            }

            public int Number { get; set; }
            public string Details { get; set; }

            public event PropertyChangedEventHandler PropertyChanged;
            public event PropertyChangingEventHandler PropertyChanging;
        }

        [ConditionalFact]
        public void DbFunctions()
            => Test(
                new DbFunctionContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "DbFunctionContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext))]
    public partial class DbFunctionContextModel : RuntimeModel
    {
        static DbFunctionContextModel()
        {
            var model = new DbFunctionContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static DbFunctionContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DbFunctionContextModelBuilder.cs",
                        @"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class DbFunctionContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);
            var @object = ObjectEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);
            ObjectEntityType.CreateAnnotations(@object);

            var type = this.AddTypeMappingConfiguration(
                typeof(string),
                maxLength: 256);
            type.AddAnnotation(""Relational:IsFixedLength"", true);

            var functions = new SortedDictionary<string, IDbFunction>();
            var getBlobs = new RuntimeDbFunction(
                ""GetBlobs()"",
                this,
                typeof(IQueryable<object>),
                ""GetBlobs"",
                schema: ""dbo"");

            functions[""GetBlobs()""] = getBlobs;

            var getCount = new RuntimeDbFunction(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetCount(System.Guid?,string)"",
                this,
                typeof(int),
                ""CustomerOrderCount"",
                schema: ""dbf"",
                storeType: ""int"",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    ""GetCount"",
                    BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(Guid?), typeof(string) },
                    null),
                scalar: true);

            var id = getCount.AddParameter(
                ""id"",
                typeof(Guid?),
                true,
                ""uniqueidentifier"");
            id.AddAnnotation(""MyAnnotation"", new[] { 1L });

            var condition = getCount.AddParameter(
                ""condition"",
                typeof(string),
                false,
                ""nchar(256)"");

            functions[""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetCount(System.Guid?,string)""] = getCount;

            var getData = new RuntimeDbFunction(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()"",
                this,
                typeof(IQueryable<CSharpRuntimeModelCodeGeneratorTest.Data>),
                ""GetAllData"",
                schema: ""dbo"",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    ""GetData"",
                    BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] {  },
                    null));

            functions[""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()""] = getData;

            var getData0 = new RuntimeDbFunction(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData(int)"",
                this,
                typeof(IQueryable<CSharpRuntimeModelCodeGeneratorTest.Data>),
                ""GetData"",
                schema: ""dbo"",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    ""GetData"",
                    BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(int) },
                    null));

            var id0 = getData0.AddParameter(
                ""id"",
                typeof(int),
                false,
                ""int"");

            functions[""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData(int)""] = getData0;

            var isDateStatic = new RuntimeDbFunction(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.IsDateStatic(string)"",
                this,
                typeof(bool),
                ""IsDate"",
                storeType: ""bit"",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    ""IsDateStatic"",
                    BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(string) },
                    null),
                scalar: true,
                nullable: true,
                builtIn: true);

            var date = isDateStatic.AddParameter(
                ""date"",
                typeof(string),
                false,
                ""nchar(256)"");

            isDateStatic.AddAnnotation(""MyGuid"", new Guid(""00000000-0000-0000-0000-000000000000""));
            functions[""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.IsDateStatic(string)""] = isDateStatic;

            AddAnnotation(""Relational:DbFunctions"", functions);
            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()"");
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c),
                    c => AssertFileContents(
                        "ObjectEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class ObjectEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""object"",
                typeof(object),
                baseEntityType);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", ""GetBlobs()"");
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    Assert.Equal(5, model.GetDbFunctions().Count());

                    var getCount = model.FindDbFunction(
                        typeof(DbFunctionContext)
                            .GetMethod("GetCount", BindingFlags.NonPublic | BindingFlags.Instance));
                    Assert.Equal("CustomerOrderCount", getCount.Name);
                    Assert.Same(model, getCount.Model);
                    Assert.Same(model, ((IReadOnlyDbFunction)getCount).Model);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".GetCount(System.Guid?,string)", getCount.ModelName);
                    Assert.Equal("dbf", getCount.Schema);
                    Assert.False(getCount.IsNullable);
                    Assert.True(getCount.IsScalar);
                    Assert.False(getCount.IsBuiltIn);
                    Assert.False(getCount.IsAggregate);
                    Assert.Null(getCount.Translation);
                    Assert.Equal("int", getCount.TypeMapping?.StoreType);
                    Assert.Equal(typeof(int), getCount.ReturnType);
                    Assert.Equal("GetCount", getCount.MethodInfo.Name);
                    Assert.Empty(getCount.GetAnnotations());
                    Assert.Empty(getCount.GetRuntimeAnnotations());
                    Assert.Equal("CustomerOrderCount", getCount.StoreFunction.Name);
                    Assert.False(getCount.StoreFunction.IsShared);
                    Assert.NotNull(getCount.ToString());
                    Assert.Equal(getCount.Parameters, ((IReadOnlyDbFunction)getCount).Parameters);
                    Assert.Equal(2, getCount.Parameters.Count);

                    var getCountParameter1 = getCount.Parameters[0];
                    Assert.Same(getCount, getCountParameter1.Function);
                    Assert.Same(getCount, ((IReadOnlyDbFunctionParameter)getCountParameter1).Function);
                    Assert.Equal("id", getCountParameter1.Name);
                    Assert.Equal("uniqueidentifier", getCountParameter1.StoreType);
                    Assert.Equal("uniqueidentifier", ((IReadOnlyDbFunctionParameter)getCountParameter1).StoreType);
                    Assert.True(getCountParameter1.PropagatesNullability);
                    Assert.Equal(typeof(Guid?), getCountParameter1.ClrType);
                    Assert.Equal("uniqueidentifier", getCountParameter1.TypeMapping.StoreType);
                    Assert.Single((IEnumerable)getCountParameter1.GetAnnotations());
                    Assert.Equal(new[] { 1L }, getCountParameter1["MyAnnotation"]);
                    Assert.Equal("id", getCountParameter1.StoreFunctionParameter.Name);
                    Assert.Equal("uniqueidentifier", getCountParameter1.StoreFunctionParameter.Type);
                    Assert.NotNull(getCountParameter1.ToString());

                    var getCountParameter2 = getCount.Parameters[1];
                    Assert.Same(getCount, getCountParameter2.Function);
                    Assert.Equal("condition", getCountParameter2.Name);
                    Assert.Equal("nchar(256)", getCountParameter2.StoreType);
                    Assert.False(getCountParameter2.PropagatesNullability);
                    Assert.Equal(typeof(string), getCountParameter2.ClrType);
                    Assert.Equal("nchar(256)", getCountParameter2.TypeMapping.StoreType);
                    Assert.Equal("condition", getCountParameter2.StoreFunctionParameter.Name);
                    Assert.Equal("nchar(256)", getCountParameter2.StoreFunctionParameter.Type);
                    Assert.NotNull(getCountParameter2.ToString());

                    var isDate = model.FindDbFunction(typeof(DbFunctionContext).GetMethod("IsDateStatic"));
                    Assert.Equal("IsDate", isDate.Name);
                    Assert.Null(isDate.Schema);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".IsDateStatic(string)", isDate.ModelName);
                    Assert.True(isDate.IsNullable);
                    Assert.True(isDate.IsScalar);
                    Assert.True(isDate.IsBuiltIn);
                    Assert.False(isDate.IsAggregate);
                    Assert.Null(isDate.Translation);
                    Assert.Equal(typeof(bool), isDate.ReturnType);
                    Assert.Equal("IsDateStatic", isDate.MethodInfo.Name);
                    Assert.Single((IEnumerable)isDate.GetAnnotations());
                    Assert.Equal(new Guid(), isDate["MyGuid"]);
                    Assert.Empty(isDate.GetRuntimeAnnotations());
                    Assert.Equal("bit", isDate.StoreFunction.ReturnType);
                    Assert.Empty(isDate.StoreFunction.EntityTypeMappings);
                    Assert.Single((IEnumerable)isDate.Parameters);

                    var isDateParameter = isDate.Parameters[0];
                    Assert.Same(isDate, isDateParameter.Function);
                    Assert.Equal("date", isDateParameter.Name);
                    Assert.Equal("nchar(256)", isDateParameter.StoreType);
                    Assert.False(isDateParameter.PropagatesNullability);
                    Assert.Equal(typeof(string), isDateParameter.ClrType);
                    Assert.Equal("nchar(256)", isDateParameter.TypeMapping.StoreType);
                    Assert.Equal("date", isDateParameter.StoreFunctionParameter.Name);
                    Assert.Equal("nchar(256)", isDateParameter.StoreFunctionParameter.Type);

                    var getData = model.FindDbFunction(
                        typeof(DbFunctionContext)
                            .GetMethod("GetData", new[] { typeof(int) }));
                    Assert.Equal("GetData", getData.Name);
                    Assert.Equal("dbo", getData.Schema);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".GetData(int)", getData.ModelName);
                    Assert.False(getData.IsNullable);
                    Assert.False(getData.IsScalar);
                    Assert.False(getData.IsBuiltIn);
                    Assert.False(getData.IsAggregate);
                    Assert.Null(getData.Translation);
                    Assert.Equal(typeof(IQueryable<Data>), getData.ReturnType);
                    Assert.Equal("GetData", getData.MethodInfo.Name);
                    Assert.Empty(getData.GetAnnotations());
                    Assert.Empty(getData.GetRuntimeAnnotations());
                    Assert.Null(getData.TypeMapping?.StoreType);
                    Assert.Null(getData.StoreFunction.ReturnType);
                    Assert.Equal(typeof(Data), getData.StoreFunction.EntityTypeMappings.Single().EntityType.ClrType);
                    Assert.Single((IEnumerable)getData.Parameters);

                    var getDataParameter = getData.Parameters[0];
                    Assert.Same(getData, getDataParameter.Function);
                    Assert.Equal("id", getDataParameter.Name);
                    Assert.Equal("int", getDataParameter.StoreType);
                    Assert.False(getDataParameter.PropagatesNullability);
                    Assert.Equal(typeof(int), getDataParameter.ClrType);
                    Assert.Equal("int", getDataParameter.TypeMapping.StoreType);
                    Assert.Equal("id", getDataParameter.StoreFunctionParameter.Name);
                    Assert.Equal("int", getDataParameter.StoreFunctionParameter.Type);

                    var getDataParameterless = model.FindDbFunction(
                        typeof(DbFunctionContext)
                            .GetMethod("GetData", new Type[0]));
                    Assert.Equal("GetAllData", getDataParameterless.Name);
                    Assert.Equal("dbo", getDataParameterless.Schema);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".GetData()", getDataParameterless.ModelName);
                    Assert.False(getDataParameterless.IsNullable);
                    Assert.False(getDataParameterless.IsScalar);
                    Assert.False(getDataParameterless.IsBuiltIn);
                    Assert.False(getDataParameterless.IsAggregate);
                    Assert.Null(getDataParameterless.Translation);
                    Assert.Equal(typeof(IQueryable<Data>), getDataParameterless.ReturnType);
                    Assert.Equal("GetData", getDataParameterless.MethodInfo.Name);
                    Assert.Empty(getDataParameterless.GetAnnotations());
                    Assert.Empty(getDataParameterless.GetRuntimeAnnotations());
                    Assert.False(getDataParameterless.StoreFunction.IsBuiltIn);
                    Assert.Equal(typeof(Data), getDataParameterless.StoreFunction.EntityTypeMappings.Single().EntityType.ClrType);
                    Assert.Equal(0, getDataParameterless.Parameters.Count);

                    Assert.Equal(2, model.GetEntityTypes().Count());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Null(dataEntity.FindPrimaryKey());
                    var dataEntityFunctionMapping = dataEntity.GetFunctionMappings().Single(m => m.IsDefaultFunctionMapping);
                    Assert.True(dataEntityFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(dataEntityFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(dataEntityFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(getDataParameterless, dataEntityFunctionMapping.DbFunction);

                    var getDataStoreFunction = dataEntityFunctionMapping.StoreFunction;
                    Assert.Same(getDataParameterless, getDataStoreFunction.DbFunctions.Single());
                    Assert.False(getDataStoreFunction.IsOptional(dataEntity));

                    var dataEntityOtherFunctionMapping = dataEntity.GetFunctionMappings().Single(m => !m.IsDefaultFunctionMapping);
                    Assert.True(dataEntityOtherFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(dataEntityOtherFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(dataEntityOtherFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(getData, dataEntityOtherFunctionMapping.DbFunction);

                    var getDataOtherStoreFunction = dataEntityOtherFunctionMapping.StoreFunction;
                    Assert.Same(getData, getDataOtherStoreFunction.DbFunctions.Single());
                    Assert.False(getDataOtherStoreFunction.IsOptional(dataEntity));

                    var getBlobs = model.FindDbFunction("GetBlobs()");
                    Assert.Equal("dbo", getBlobs.Schema);
                    Assert.False(getBlobs.IsNullable);
                    Assert.False(getBlobs.IsScalar);
                    Assert.False(getBlobs.IsBuiltIn);
                    Assert.False(getBlobs.IsAggregate);
                    Assert.Null(getBlobs.Translation);
                    Assert.Null(getBlobs.TypeMapping);
                    Assert.Equal(typeof(IQueryable<object>), getBlobs.ReturnType);
                    Assert.Null(getBlobs.MethodInfo);
                    Assert.Empty(getBlobs.GetAnnotations());
                    Assert.Empty(getBlobs.GetRuntimeAnnotations());
                    Assert.Equal("GetBlobs", getBlobs.StoreFunction.Name);
                    Assert.False(getBlobs.StoreFunction.IsShared);
                    Assert.NotNull(getBlobs.ToString());
                    Assert.Empty(getBlobs.Parameters);

                    var objectEntity = model.FindEntityType(typeof(object));
                    Assert.Null(objectEntity.FindPrimaryKey());
                    var objectEntityFunctionMapping = objectEntity.GetFunctionMappings().Single(m => m.IsDefaultFunctionMapping);
                    Assert.True(objectEntityFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(objectEntityFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(objectEntityFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(getBlobs, objectEntityFunctionMapping.DbFunction);
                });

        public class DbFunctionContext : SqlServerContextBase
        {
            public static bool IsDateStatic(string date)
                => throw new NotImplementedException();

            private int GetCount(Guid? id, string condition)
                => throw new NotImplementedException();

            public IQueryable<Data> GetData(int id)
                => FromExpression(() => GetData(id));

            public IQueryable<Data> GetData()
                => FromExpression(() => GetData());

            protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
                => configurationBuilder.DefaultTypeMapping<string>().HasMaxLength(256).IsFixedLength();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(
                        typeof(DbFunctionContext).GetMethod(nameof(GetCount), BindingFlags.NonPublic | BindingFlags.Instance))
                    .HasName("CustomerOrderCount").HasSchema("dbf").IsNullable(false)
                    .HasParameter("id").PropagatesNullability().Metadata.SetAnnotation("MyAnnotation", new[] { 1L });

                modelBuilder.HasDbFunction(typeof(DbFunctionContext).GetMethod(nameof(IsDateStatic))).HasName("IsDate").IsBuiltIn()
                    .Metadata.SetAnnotation("MyGuid", new Guid());

                modelBuilder.HasDbFunction(typeof(DbFunctionContext).GetMethod(nameof(GetData), new[] { typeof(int) }));
                modelBuilder.HasDbFunction(typeof(DbFunctionContext).GetMethod(nameof(GetData), new Type[0]));

                modelBuilder.Entity<Data>().ToFunction(typeof(DbFunctionContext).FullName + ".GetData()", f => f.HasName("GetAllData"))
                    .HasNoKey();

                modelBuilder.Entity<object>().ToFunction("GetBlobs()", f => f.HasName("GetBlobs")).HasNoKey();
            }
        }

        [ConditionalFact]
        public void Sequences()
            => Test(
                new SequencesContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "SequencesContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.SequencesContext))]
    public partial class SequencesContextModel : RuntimeModel
    {
        static SequencesContextModel()
        {
            var model = new SequencesContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static SequencesContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "SequencesContextModelBuilder.cs",
                        @"// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class SequencesContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            var sequences = new SortedDictionary<(string, string), ISequence>();
            var hL = new RuntimeSequence(
                ""HL"",
                this,
                typeof(long),
                schema: ""S"",
                incrementBy: 10);

            sequences[(""HL"", ""S"")] = hL;

            var @long = new RuntimeSequence(
                ""Long"",
                this,
                typeof(long),
                startValue: -4L,
                incrementBy: 2,
                cyclic: true,
                minValue: -2L,
                maxValue: 2L);

            sequences[(""Long"", null)] = @long;

            AddAnnotation(""Relational:Sequences"", sequences);
            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.AddAnnotation(""SqlServer:HiLoSequenceName"", ""HL"");
            id.AddAnnotation(""SqlServer:HiLoSequenceSchema"", ""S"");
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.SequenceHiLo);

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""Data"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    Assert.Equal(2, model.GetSequences().Count());

                    var longSequence = model.FindSequence("Long");
                    Assert.Same(model, longSequence.Model);
                    Assert.Equal(typeof(long), longSequence.Type);
                    Assert.True(longSequence.IsCyclic);
                    Assert.Equal(-4, longSequence.StartValue);
                    Assert.Equal(-2, longSequence.MinValue);
                    Assert.Equal(2, longSequence.MaxValue);
                    Assert.Equal(2, longSequence.IncrementBy);
                    Assert.NotNull(longSequence.ToString());

                    var hiLo = model.FindSequence("HL", "S");
                    Assert.Same(model, ((IReadOnlySequence)hiLo).Model);
                    Assert.Equal("HL", hiLo.Name);
                    Assert.Equal("S", hiLo.Schema);
                    Assert.False(hiLo.IsCyclic);
                    Assert.Equal(1, hiLo.StartValue);
                    Assert.Null(hiLo.MinValue);
                    Assert.Null(hiLo.MaxValue);
                    Assert.Equal(10, hiLo.IncrementBy);
                    Assert.NotNull(hiLo.ToString());

                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Same(hiLo, dataEntity.FindPrimaryKey().Properties.Single().FindHiLoSequence());
                });

        public class SequencesContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasSequence<long>("Long")
                    .HasMin(-2)
                    .HasMax(2)
                    .IsCyclic()
                    .IncrementsBy(2)
                    .StartsAt(-4);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id").UseHiLo("HL", "S");
                        eb.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Key_sequences()
            => Test(
                new KeySequencesContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "KeySequencesContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.KeySequencesContext))]
    public partial class KeySequencesContextModel : RuntimeModel
    {
        static KeySequencesContextModel()
        {
            var model = new KeySequencesContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static KeySequencesContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "KeySequencesContextModelBuilder.cs",
                        @"// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class KeySequencesContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            var sequences = new SortedDictionary<(string, string), ISequence>();
            var keySeq = new RuntimeSequence(
                ""KeySeq"",
                this,
                typeof(long),
                schema: ""KeySeqSchema"");

            sequences[(""KeySeq"", ""KeySeqSchema"")] = keySeq;

            AddAnnotation(""Relational:Sequences"", sequences);
            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.AddAnnotation(""Relational:DefaultValueSql"", ""NEXT VALUE FOR [KeySeqSchema].[KeySeq]"");
            id.AddAnnotation(""SqlServer:SequenceName"", ""KeySeq"");
            id.AddAnnotation(""SqlServer:SequenceSchema"", ""KeySeqSchema"");
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.Sequence);

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""Data"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    Assert.Single(model.GetSequences());

                    var keySequence = model.FindSequence("KeySeq", "KeySeqSchema")!;
                    Assert.Same(model, ((IReadOnlySequence)keySequence).Model);
                    Assert.Equal("KeySeq", keySequence.Name);
                    Assert.Equal("KeySeqSchema", keySequence.Schema);
                    Assert.False(keySequence.IsCyclic);
                    Assert.Equal(1, keySequence.StartValue);
                    Assert.Null(keySequence.MinValue);
                    Assert.Null(keySequence.MaxValue);
                    Assert.Equal(1, keySequence.IncrementBy);
                    Assert.NotNull(keySequence.ToString());

                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Same(keySequence, dataEntity!.FindPrimaryKey().Properties.Single().FindSequence());
                });

        public class KeySequencesContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id").UseSequence("KeySeq", "KeySeqSchema");
                        eb.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void CheckConstraints()
            => Test(
                new ConstraintsContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ConstraintsContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ConstraintsContext))]
    public partial class ConstraintsContextModel : RuntimeModel
    {
        static ConstraintsContextModel()
        {
            var model = new ConstraintsContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static ConstraintsContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "ConstraintsContextModelBuilder.cs",
                        @"// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ConstraintsContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""Data"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    var dataEntity = model.GetEntityTypes().Single();

                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => dataEntity.GetCheckConstraints()).Message);
                });

        public class ConstraintsContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.ToTable(tb => tb.HasCheckConstraint("idConstraint", "Id <> 0"));
                        eb.ToTable(tb => tb.HasCheckConstraint("anotherConstraint", "Id <> -1"));
                    });
            }
        }

        [ConditionalFact]
        public void Triggers()
            => Test(
                new TriggersContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "TriggersContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TriggersContext))]
    public partial class TriggersContextModel : RuntimeModel
    {
        static TriggersContextModel()
        {
            var model = new TriggersContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static TriggersContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "TriggersContextModelBuilder.cs",
                        @"// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class TriggersContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            AddAnnotation(""Relational:MaxIdentifierLength"", 128);
            AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);
        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.IdentityColumn);

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.AddAnnotation(""SqlServer:ValueGenerationStrategy"", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var trigger1 = runtimeEntityType.AddTrigger(
                ""Trigger1"");

            var trigger2 = runtimeEntityType.AddTrigger(
                ""Trigger2"");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""Data"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    var dataEntity = model.GetEntityTypes().Single();

                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => dataEntity.GetCheckConstraints()).Message);
                });

        public class TriggersContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.ToTable(
                            tb =>
                                {
                                    tb.HasTrigger("Trigger1");
                                    tb.HasTrigger("Trigger2");
                                });
                    });
            }
        }

        [ConditionalFact]
        public void Sqlite()
            => Test(
                new SqliteContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = "Microsoft.EntityFrameworkCore.Metadata" },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "SqliteContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.SqliteContext))]
    public partial class SqliteContextModel : RuntimeModel
    {
        static SqliteContextModel()
        {
            var model = new SqliteContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static SqliteContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "SqliteContextModelBuilder.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    public partial class SqliteContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);

            var point = runtimeEntityType.AddProperty(
                ""Point"",
                typeof(Point),
                nullable: true);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Relational:FunctionName"", null);
            runtimeEntityType.AddAnnotation(""Relational:Schema"", null);
            runtimeEntityType.AddAnnotation(""Relational:SqlQuery"", null);
            runtimeEntityType.AddAnnotation(""Relational:TableName"", ""Data"");
            runtimeEntityType.AddAnnotation(""Relational:ViewName"", null);
            runtimeEntityType.AddAnnotation(""Relational:ViewSchema"", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));

                    Assert.Equal(typeof(Data).FullName, dataEntity.Name);
                    Assert.False(dataEntity.HasSharedClrType);
                    Assert.False(dataEntity.IsPropertyBag);
                    Assert.False(dataEntity.IsOwned());
                    Assert.IsType<ConstructorBinding>(dataEntity.ConstructorBinding);
                    Assert.Null(dataEntity.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, dataEntity.GetChangeTrackingStrategy());
                    Assert.Equal("Data", dataEntity.GetTableName());
                    Assert.Null(dataEntity.GetSchema());

                    var point = dataEntity.FindProperty("Point");
                    Assert.Equal(typeof(Point), point.ClrType);
                    Assert.True(point.IsNullable);
                    Assert.Equal(ValueGenerated.Never, point.ValueGenerated);
                    Assert.Equal("Point", point.GetColumnName());
                    Assert.Equal("POINT", point.GetColumnType());
                    Assert.Null(point.GetValueConverter());
                    Assert.IsType<GeometryValueComparer<Point>>(point.GetValueComparer());
                    Assert.IsType<GeometryValueComparer<Point>>(point.GetKeyValueComparer());
                    Assert.Null(point.GetSrid());
                },
                typeof(SqliteNetTopologySuiteDesignTimeServices));

        public class SqliteContext : DbContext
        {
            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseSqlite(o => o.UseNetTopologySuite());

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.Property<Point>("Point")
                            .HasSrid(1101);
                    });
            }
        }

        [ConditionalFact]
        public void Cosmos()
            => Test(
                new CosmosContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "CosmosContextModel.cs",
                        @"// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.CosmosContext))]
    public partial class CosmosContextModel : RuntimeModel
    {
        static CosmosContextModel()
        {
            var model = new CosmosContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static CosmosContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
",
                        c),
                    c => AssertFileContents(
                        "CosmosContextModelBuilder.cs",
                        @"// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class CosmosContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            AddAnnotation(""Cosmos:ContainerName"", ""Default"");
        }
    }
}
",
                        c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        @"// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Cosmos.ValueGeneration;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Newtonsoft.Json.Linq;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                ""Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data"",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                ""Id"",
                typeof(int),
                afterSaveBehavior: PropertySaveBehavior.Throw);

            var partitionId = runtimeEntityType.AddProperty(
                ""PartitionId"",
                typeof(long?),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                providerPropertyType: typeof(string));

            var blob = runtimeEntityType.AddProperty(
                ""Blob"",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty(""Blob"", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField(""<Blob>k__BackingField"", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.AddAnnotation(""Cosmos:PropertyName"", ""JsonBlob"");

            var id0 = runtimeEntityType.AddProperty(
                ""__id"",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new IdValueGeneratorFactory().Create);
            id0.AddAnnotation(""Cosmos:PropertyName"", ""id"");

            var jObject = runtimeEntityType.AddProperty(
                ""__jObject"",
                typeof(JObject),
                nullable: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            jObject.AddAnnotation(""Cosmos:PropertyName"", """");

            var etag = runtimeEntityType.AddProperty(
                ""_etag"",
                typeof(string),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);

            var key = runtimeEntityType.AddKey(
                new[] { id, partitionId });
            runtimeEntityType.SetPrimaryKey(key);

            var key0 = runtimeEntityType.AddKey(
                new[] { id0, partitionId });

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation(""Cosmos:ContainerName"", ""DataContainer"");
            runtimeEntityType.AddAnnotation(""Cosmos:ETagName"", ""_etag"");
            runtimeEntityType.AddAnnotation(""Cosmos:PartitionKeyName"", ""PartitionId"");

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
",
                        c)),
                model =>
                {
                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Equal(typeof(Data).FullName, dataEntity.Name);
                    Assert.False(dataEntity.HasSharedClrType);
                    Assert.False(dataEntity.IsPropertyBag);
                    Assert.False(dataEntity.IsOwned());
                    Assert.IsType<ConstructorBinding>(dataEntity.ConstructorBinding);
                    Assert.Null(dataEntity.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, dataEntity.GetChangeTrackingStrategy());
                    Assert.Equal("DataContainer", dataEntity.GetContainer());
                    Assert.Null(dataEntity.FindDiscriminatorProperty());

                    var id = dataEntity.FindProperty("Id");
                    Assert.Equal(typeof(int), id.ClrType);
                    Assert.Null(id.PropertyInfo);
                    Assert.Null(id.FieldInfo);
                    Assert.False(id.IsNullable);
                    Assert.False(id.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, id.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, id.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, id.GetBeforeSaveBehavior());
                    Assert.Equal("Id", CosmosPropertyExtensions.GetJsonPropertyName(id));
                    Assert.Null(id.GetValueGeneratorFactory());
                    Assert.Null(id.GetValueConverter());
                    Assert.NotNull(id.GetValueComparer());
                    Assert.NotNull(id.GetKeyValueComparer());

                    var storeId = dataEntity.FindProperty("__id");
                    Assert.Equal(typeof(string), storeId.ClrType);
                    Assert.Null(storeId.PropertyInfo);
                    Assert.Null(storeId.FieldInfo);
                    Assert.False(storeId.IsNullable);
                    Assert.False(storeId.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, storeId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, storeId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, storeId.GetBeforeSaveBehavior());
                    Assert.Equal("id", CosmosPropertyExtensions.GetJsonPropertyName(storeId));
                    Assert.IsType<IdValueGenerator>(storeId.GetValueGeneratorFactory()(storeId, dataEntity));
                    Assert.Null(storeId.GetValueConverter());
                    Assert.NotNull(storeId.GetValueComparer());
                    Assert.NotNull(storeId.GetKeyValueComparer());

                    var partitionId = dataEntity.FindProperty("PartitionId");
                    Assert.Equal(typeof(long?), partitionId.ClrType);
                    Assert.Null(partitionId.PropertyInfo);
                    Assert.Null(partitionId.FieldInfo);
                    Assert.False(partitionId.IsNullable);
                    Assert.False(partitionId.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, partitionId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, partitionId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, partitionId.GetBeforeSaveBehavior());
                    Assert.Equal("PartitionId", CosmosPropertyExtensions.GetJsonPropertyName(partitionId));
                    Assert.Null(partitionId.GetValueGeneratorFactory());
                    Assert.Null(partitionId.GetValueConverter());
                    Assert.IsType<NumberToStringConverter<long>>(partitionId.FindTypeMapping().Converter);
                    Assert.NotNull(partitionId.GetValueComparer());
                    Assert.NotNull(partitionId.GetKeyValueComparer());

                    var eTag = dataEntity.FindProperty("_etag");
                    Assert.Equal(typeof(string), eTag.ClrType);
                    Assert.Null(eTag.PropertyInfo);
                    Assert.Null(eTag.FieldInfo);
                    Assert.True(eTag.IsNullable);
                    Assert.True(eTag.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, eTag.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Ignore, eTag.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Ignore, eTag.GetBeforeSaveBehavior());
                    Assert.Equal("_etag", CosmosPropertyExtensions.GetJsonPropertyName(eTag));
                    Assert.Null(eTag.GetValueGeneratorFactory());
                    Assert.Null(eTag.GetValueConverter());
                    Assert.NotNull(eTag.GetValueComparer());
                    Assert.NotNull(eTag.GetKeyValueComparer());
                    Assert.Equal("_etag", dataEntity.GetETagPropertyName());
                    Assert.Same(eTag, dataEntity.GetETagProperty());

                    var blob = dataEntity.FindProperty(nameof(Data.Blob));
                    Assert.Equal(typeof(byte[]), blob.ClrType);
                    Assert.Equal(nameof(Data.Blob), blob.PropertyInfo.Name);
                    Assert.Equal("<Blob>k__BackingField", blob.FieldInfo.Name);
                    Assert.True(blob.IsNullable);
                    Assert.False(blob.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, blob.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Save, blob.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, blob.GetBeforeSaveBehavior());
                    Assert.Equal("JsonBlob", CosmosPropertyExtensions.GetJsonPropertyName(blob));
                    Assert.Null(blob.GetValueGeneratorFactory());
                    Assert.Null(blob.GetValueConverter());
                    Assert.NotNull(blob.GetValueComparer());
                    Assert.NotNull(blob.GetKeyValueComparer());

                    var jObject = dataEntity.FindProperty("__jObject");
                    Assert.Equal(typeof(JObject), jObject.ClrType);
                    Assert.Null(jObject.PropertyInfo);
                    Assert.Null(jObject.FieldInfo);
                    Assert.True(jObject.IsNullable);
                    Assert.False(jObject.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, jObject.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Ignore, jObject.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Ignore, jObject.GetBeforeSaveBehavior());
                    Assert.Equal("", CosmosPropertyExtensions.GetJsonPropertyName(jObject));
                    Assert.Null(jObject.GetValueGeneratorFactory());
                    Assert.Null(jObject.GetValueConverter());
                    Assert.NotNull(jObject.GetValueComparer());
                    Assert.NotNull(jObject.GetKeyValueComparer());

                    Assert.Equal(2, dataEntity.GetKeys().Count());

                    Assert.Equal(new[] { id, partitionId, blob, storeId, jObject, eTag }, dataEntity.GetProperties());
                });

        public class CosmosContext : DbContext
        {
            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseCosmos("localhost", "_", "_");

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

                modelBuilder.HasDefaultContainer("Default");

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.Property<long?>("PartitionId").HasConversion<string>();
                        eb.HasPartitionKey("PartitionId");
                        eb.HasKey("Id", "PartitionId");
                        eb.ToContainer("DataContainer");
                        eb.UseETagConcurrency();
                        eb.HasNoDiscriminator();
                        eb.Property(d => d.Blob).ToJsonProperty("JsonBlob");
                    });
            }
        }

        public class Data
        {
            public byte[] Blob { get; set; }
        }

        public abstract class ContextBase : DbContext
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
                => modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseInMemoryDatabase(nameof(CSharpRuntimeModelCodeGeneratorTest));
        }

        public abstract class SqlServerContextBase : DbContext
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
                => modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseSqlServer(o => o.UseNetTopologySuite());
        }

        protected void Test(
            DbContext context,
            CompiledModelCodeGenerationOptions options,
            Action<IReadOnlyCollection<ScaffoldedFile>> assertScaffold = null,
            Action<IModel> assertModel = null,
            Type additionalDesignTimeServices = null,
            Action<DbContext> useContext = null,
            string expectedExceptionMessage = null)
        {
            var model = context.GetService<IDesignTimeModel>().Model;

            options.ModelNamespace ??= "TestNamespace";
            options.ContextType = context.GetType();

            var generator = DesignTestHelpers.Instance.CreateDesignServiceProvider(
                    context.GetService<IDatabaseProvider>().Name,
                    additionalDesignTimeServices: additionalDesignTimeServices)
                .GetRequiredService<ICompiledModelCodeGeneratorSelector>()
                .Select(options);

            if (expectedExceptionMessage != null)
            {
                Assert.Equal(
                    expectedExceptionMessage,
                    Assert.Throws<InvalidOperationException>(
                        () => generator.GenerateModel(
                            model,
                            options)).Message);
                return;
            }

            var scaffoldedFiles = generator.GenerateModel(
                model,
                options);

            var build = new BuildSource
            {
                References =
                {
                    BuildReference.ByName("Microsoft.EntityFrameworkCore"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Abstractions"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Cosmos"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.InMemory"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Proxies"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Relational"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Sqlite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Sqlite.NetTopologySuite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.SqlServer"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.SqlServer.NetTopologySuite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Specification.Tests"),
                    BuildReference.ByName("NetTopologySuite"),
                    BuildReference.ByName("Newtonsoft.Json"),
                    BuildReference.ByName(typeof(CSharpRuntimeModelCodeGeneratorTest).Assembly.GetName().Name)
                },
                Sources = scaffoldedFiles.ToDictionary(f => f.Path, f => f.Code),
                NullableReferenceTypes = options.UseNullableReferenceTypes
            };

            var assembly = build.BuildInMemory();

            var modelType = assembly.GetType(options.ModelNamespace + "." + options.ContextType.Name + "Model");
            var instancePropertyInfo = modelType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
            var compiledModel = (IModel)instancePropertyInfo.GetValue(null);

            var modelRuntimeInitializer = context.GetService<IModelRuntimeInitializer>();
            compiledModel = modelRuntimeInitializer.Initialize(compiledModel, designTime: false);
            assertModel(compiledModel);

            if (assertScaffold != null)
            {
                assertScaffold(scaffoldedFiles);
            }

            if (useContext != null)
            {
                using var testStore = SqlServerTestStore.Create("RuntimeModelTest" + context.GetType().Name);
                testStore.Clean(context);

                var optionsBuilder = testStore.AddProviderOptions(new DbContextOptionsBuilder().UseModel(compiledModel));
                new SqlServerDbContextOptionsBuilder(optionsBuilder).UseNetTopologySuite();
                var newContext = new DbContext(optionsBuilder.Options);

                newContext.Database.CreateExecutionStrategy().Execute(
                    newContext,
                    c =>
                    {
                        using var transaction = context.Database.BeginTransaction();
                        useContext(c);
                    });
            }
        }

        protected static void AssertFileContents(
            string expectedPath,
            string expectedCode,
            ScaffoldedFile file)
        {
            Assert.Equal(expectedPath, file.Path);
            Assert.Equal(expectedCode, file.Code, ignoreLineEndingDifferences: true);
        }
    }

    public class Internal
    {
        public long Id { get; set; }
    }

    public class Index
    {
        public Guid Id { get; set; }
    }

    public class IdentityUser : TestModels.AspNetIdentity.IdentityUser
    {
    }


    public class SelfReferentialEntity
    {
        public long Id { get; set; }

        public SelfReferentialProperty Collection { get; set; }
    }

    public class SelfReferentialProperty : List<SelfReferentialProperty>
    {
    }
}

namespace Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal
{
    public class DbContext : ContextBase
    {
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Index>();
            modelBuilder.Entity<IdentityUser>();
            modelBuilder.Entity<Scaffolding.Internal.IdentityUser>(
                eb =>
                {
                    eb.HasDiscriminator().HasValue("DerivedIdentityUser");
                });
            modelBuilder.Entity<Scaffolding.Internal.Internal>();
        }
    }

    public class SelfReferentialDbContext : ContextBase
    {
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Scaffolding.Internal.SelfReferentialEntity>(
                eb =>
                {
                    eb.Property(e => e.Collection).HasConversion(typeof(SelfReferentialPropertyValueConverter));
                });
        }
    }

    public class SelfReferentialPropertyValueConverter : ValueConverter<Scaffolding.Internal.SelfReferentialProperty, string>
    {
        public SelfReferentialPropertyValueConverter()
          : this(null)
        { }

        public SelfReferentialPropertyValueConverter(ConverterMappingHints hints)
           : base(v => null, v => null, hints)
        { }
    }
}
