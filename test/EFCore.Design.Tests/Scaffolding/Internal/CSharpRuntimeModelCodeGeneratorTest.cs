// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data;
using System.Net;
using System.Net.NetworkInformation;
using System.Text.Json;
using Microsoft.EntityFrameworkCore.Cosmos.ValueGeneration.Internal;
using Microsoft.EntityFrameworkCore.Design.Internal;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Design.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Design.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.ValueGeneration.Internal;
using NetTopologySuite;
using NetTopologySuite.Geometries;
using Newtonsoft.Json.Linq;
using static Microsoft.EntityFrameworkCore.DbLoggerCategory;
using static Microsoft.EntityFrameworkCore.Migrations.Design.CSharpMigrationsGeneratorTest;
using static Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest;
using IdentityUser = Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity.IdentityUser;
using Index = Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index;

public class GlobalNamespaceContext : ContextBase
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity(
            "1", e =>
            {
                e.Property<int>("Id");
                e.HasKey("Id");
            });
    }
}

namespace Microsoft.EntityFrameworkCore.Scaffolding.Internal
{
    public class CSharpRuntimeModelCodeGeneratorTest
    {
        [ConditionalFact]
        public void Self_referential_property()
            => Test(
                new SelfReferentialDbContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    Assert.Single(model.GetEntityTypes());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                }
            );

        [ConditionalFact]
        public void Empty_model()
            => Test(
                new EmptyContext(),
                new CompiledModelCodeGenerationOptions(),
                code =>
                    Assert.Collection(
                        code,
                        c => AssertFileContents(
                            "EmptyContextModel.cs",
                            """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.EmptyContext))]
    public partial class EmptyContextModel : RuntimeModel
    {
        static EmptyContextModel()
        {
            var model = new EmptyContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static EmptyContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""",
                            c),
                        c => AssertFileContents(
                            "EmptyContextModelBuilder.cs",
                            """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class EmptyContextModel
    {
        partial void Initialize()
        {
        }
    }
}
""",
                            c)),
                model =>
                {
                    Assert.Empty(model.GetEntityTypes());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                });

        public class EmptyContext : ContextBase
        {
        }

        [ConditionalFact]
        public void Global_namespace_works()
            => Test(
                new GlobalNamespaceContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = string.Empty },
                code =>
                {
                    Assert.All(code, f => Assert.DoesNotContain("namespace ", f.Code));
                },
                model =>
                {
                    Assert.NotNull(model.FindEntityType("1"));
                });

        [ConditionalFact]
        public void Throws_for_constructor_binding()
            => Test(
                new ConstructorBindingContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelConstructorBinding("Lazy", "Customize()", "LazyEntityType"));

        public class ConstructorBindingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "Lazy", e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        ((EntityType)e.Metadata).ConstructorBinding = new ConstructorBinding(
                            typeof(object).GetConstructor(Type.EmptyTypes)!,
                            Array.Empty<ParameterBinding>());
                    });
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => base.OnConfiguring(options.UseLazyLoadingProxies());
        }

        [ConditionalFact]
        public void Manual_lazy_loading()
            => Test(
                new LazyLoadingContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    var lazyConstructorEntity = model.FindEntityType(typeof(LazyConstructorEntity));
                    var lazyParameterBinding = lazyConstructorEntity!.ConstructorBinding!.ParameterBindings.Single();
                    Assert.Equal(typeof(ILazyLoader), lazyParameterBinding.ParameterType);

                    var lazyPropertyEntity = model.FindEntityType(typeof(LazyPropertyEntity));
                    var lazyServiceProperty = lazyPropertyEntity!.GetServiceProperties().Single();
                    Assert.Equal(typeof(ILazyLoader), lazyServiceProperty.ClrType);

                    var lazyPropertyDelegateEntity = model.FindEntityType(typeof(LazyPropertyDelegateEntity));
                    Assert.Equal(2, lazyPropertyDelegateEntity!.GetServiceProperties().Count());
                    Assert.Contains(lazyPropertyDelegateEntity!.GetServiceProperties(), p => p.ClrType == typeof(ILazyLoader));
                    Assert.Contains(lazyPropertyDelegateEntity!.GetServiceProperties(), p => p.ClrType == typeof(Action<object, string>));
                });

        public class LazyLoadingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<LazyConstructorEntity>();

                modelBuilder.Entity<LazyPropertyDelegateEntity>(
                    b =>
                    {
                        var serviceProperty = (ServiceProperty)b.Metadata.AddServiceProperty(
                            typeof(LazyPropertyDelegateEntity).GetAnyProperty("LoaderState")!,
                            typeof(ILazyLoader));

                        serviceProperty.SetParameterBinding(
                            new DependencyInjectionParameterBinding(typeof(object), typeof(ILazyLoader), serviceProperty),
                            ConfigurationSource.Explicit);
                    });
            }
        }

        public class LazyConstructorEntity
        {
            private readonly ILazyLoader _loader;

            public LazyConstructorEntity(ILazyLoader loader)
            {
                _loader = loader;
            }

            public int Id { get; set; }

            public LazyPropertyEntity LazyPropertyEntity { get; set; }
            public LazyPropertyDelegateEntity LazyPropertyDelegateEntity { get; set; }
        }

        public class LazyPropertyEntity
        {
            public ILazyLoader Loader { get; set; }

            public int Id { get; set; }
            public int LazyConstructorEntityId { get; set; }

            public LazyConstructorEntity LazyConstructorEntity { get; set; }
        }

        public class LazyPropertyDelegateEntity
        {
            public object LoaderState { get; set; }
            private Action<object, string> LazyLoader { get; set; }

            public int Id { get; set; }
            public int LazyConstructorEntityId { get; set; }

            public LazyConstructorEntity LazyConstructorEntity { get; set; }
        }

        [ConditionalFact]
        public void Lazy_loading_proxies()
            => Test(
                new LazyLoadingProxiesContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    Assert.Equal(
                        typeof(ILazyLoader), model.FindEntityType(typeof(LazyProxiesEntity1))!.GetServiceProperties().Single().ClrType);
                    Assert.Equal(
                        typeof(ILazyLoader), model.FindEntityType(typeof(LazyProxiesEntity1))!.GetServiceProperties().Single().ClrType);
                });

        public class LazyLoadingProxiesContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<LazyProxiesEntity1>();
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => base.OnConfiguring(options.UseLazyLoadingProxies());
        }

        public class LazyProxiesEntity1
        {
            public int Id { get; set; }

            public virtual LazyProxiesEntity2 ReferenceNavigation { get; set; }
        }

        public class LazyProxiesEntity2
        {
            public ILazyLoader Loader { get; set; }

            public int Id { get; set; }
            public virtual ICollection<LazyProxiesEntity1> CollectionNavigation { get; set; }
        }

        [ConditionalFact]
        public void Throws_for_query_filter()
            => Test(
                new QueryFilterContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelQueryFilter("QueryFilter"));

        public class QueryFilterContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "QueryFilter", e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        e.HasQueryFilter((Expression<Func<Dictionary<string, object>, bool>>)(e => e != null));
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_defining_query()
            => Test(
                new DefiningQueryContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelDefiningQuery("object"));

        public class DefiningQueryContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<object>(
                    e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        e.Metadata.SetInMemoryQuery(() => (IQueryable<object>)Set<object>());
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_value_generator()
            => Test(
                new ValueGeneratorContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelValueGenerator(
                    "MyEntity", "Id", nameof(PropertyBuilder.HasValueGeneratorFactory)));

        public class ValueGeneratorContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasValueGenerator((p, e) => null);
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_value_converter()
            => Test(
                new ValueConverterContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ValueConverterContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ValueConverterContext))]
    public partial class ValueConverterContextModel : RuntimeModel
    {
        static ValueConverterContextModel()
        {
            var model = new ValueConverterContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static ValueConverterContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ValueConverterContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ValueConverterContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<int, int>(
                    (int i) => i,
                    (int i) => i),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<int, int>(
                        (int i) => i,
                        (int i) => i)));

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    var converter = entityType.FindProperty("Id").GetTypeMapping().Converter;
                    Assert.Equal(1, converter.ConvertToProvider(1));
                });

        public class ValueConverterContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(i => i, i => i);
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_value_comparer()
            => Test(
                new ValueComparerContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ValueComparerContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ValueComparerContext))]
    public partial class ValueComparerContextModel : RuntimeModel
    {
        static ValueComparerContextModel()
        {
            var model = new ValueComparerContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static ValueComparerContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ValueComparerContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ValueComparerContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                providerPropertyType: typeof(int));
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                keyComparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                providerValueComparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    Assert.True(entityType.FindProperty("Id").GetValueComparer().SnapshotExpression
                        is Expression<Func<int, int>> lambda
                        && lambda.Body is ConstantExpression constant
                        && ((int)constant.Value) == 1);
                });

        public class ValueComparerContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(typeof(int), new FakeValueComparer());
                        e.HasKey("Id");
                    });
            }
        }

        private class FakeValueComparer : ValueComparer<int>
        {
            public FakeValueComparer()
                : base((l,r) => false, v => 0, v => 1)
            {
            }

            public override Type Type { get; } = typeof(int);

            public override bool Equals(object left, object right)
                => throw new NotImplementedException();

            public override int GetHashCode(object instance)
                => throw new NotImplementedException();

            public override object Snapshot(object instance)
                => throw new NotImplementedException();
        }

        [ConditionalFact]
        public void Custom_provider_value_comparer()
            => Test(
                new ProviderValueComparerContext(),
                new CompiledModelCodeGenerationOptions(),
                 code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ProviderValueComparerContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ProviderValueComparerContext))]
    public partial class ProviderValueComparerContextModel : RuntimeModel
    {
        static ProviderValueComparerContextModel()
        {
            var model = new ProviderValueComparerContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static ProviderValueComparerContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ProviderValueComparerContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ProviderValueComparerContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                providerPropertyType: typeof(int));
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    Assert.True(entityType.FindProperty("Id").GetProviderValueComparer().SnapshotExpression
                        is Expression<Func<int, int>> lambda
                        && lambda.Body is ConstantExpression constant
                        && ((int)constant.Value) == 1);
                });

        public class ProviderValueComparerContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(typeof(int), null, new FakeValueComparer());
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_type_mapping()
            => Test(
                new TypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "TypeMappingContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TypeMappingContext))]
    public partial class TypeMappingContextModel : RuntimeModel
    {
        static TypeMappingContextModel()
        {
            var model = new TypeMappingContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static TypeMappingContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""",
                        c),
                    c => AssertFileContents(
                        "TypeMappingContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class TypeMappingContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""",
                        c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""",
                        c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    var typeMapping = entityType.FindProperty("Id").FindTypeMapping()!;
                    Assert.IsType<InMemoryTypeMapping>(typeMapping);
                    Assert.IsType<JsonInt32ReaderWriter>(typeMapping.JsonValueReaderWriter);
                });

        public class TypeMappingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").Metadata.SetTypeMapping(
                            new InMemoryTypeMapping(typeof(int), jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_function_type_mapping()
            => Test(
                new FunctionTypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "FunctionTypeMappingContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.FunctionTypeMappingContext))]
    public partial class FunctionTypeMappingContextModel : RuntimeModel
    {
        static FunctionTypeMappingContextModel()
        {
            var model = new FunctionTypeMappingContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static FunctionTypeMappingContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "FunctionTypeMappingContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class FunctionTypeMappingContextModel
    {
        partial void Initialize()
        {
            var functions = new SortedDictionary<string, IDbFunction>();
            var getSqlFragmentStatic = new RuntimeDbFunction(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+FunctionTypeMappingContext.GetSqlFragmentStatic(string)",
                this,
                typeof(string),
                "GetSqlFragmentStatic",
                schema: "dbo",
                storeType: "varchar",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.FunctionTypeMappingContext).GetMethod(
                    "GetSqlFragmentStatic",
                    BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(string) },
                    null),
                scalar: true,
                nullable: true);

            var param = getSqlFragmentStatic.AddParameter(
                "param",
                typeof(string),
                false,
                "nvarchar(max)");
            param.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);

            getSqlFragmentStatic.TypeMapping = StringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar",
                    dbType: System.Data.DbType.AnsiString));
            functions["Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+FunctionTypeMappingContext.GetSqlFragmentStatic(string)"] = getSqlFragmentStatic;

            AddAnnotation("Relational:DbFunctions", functions);
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);
            var getSqlFragmentStatic = (IRuntimeDbFunction)this.FindDbFunction("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+FunctionTypeMappingContext.GetSqlFragmentStatic(string)")!;
            var getSqlFragmentStaticFunction = new StoreFunction(getSqlFragmentStatic, relationalModel);
            var paramFunctionParameter = getSqlFragmentStaticFunction.FindParameter("param")!;
            relationalModel.Functions.Add(
                ("GetSqlFragmentStatic", "dbo", new[] { "nvarchar(max)" }),
                getSqlFragmentStaticFunction);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c)),
                model =>
                {
                    var function = model.GetDbFunctions().Single();

                    var typeMapping = function.TypeMapping;
                    Assert.IsType<StringTypeMapping>(typeMapping);
                    Assert.Equal("varchar", typeMapping.StoreType);
                });

        public class FunctionTypeMappingContext : SqlServerContextBase
        {
            public static string GetSqlFragmentStatic(string param)
                => throw new NotImplementedException();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(typeof(FunctionTypeMappingContext).GetMethod(nameof(GetSqlFragmentStatic)))
                    .Metadata.TypeMapping = new StringTypeMapping("varchar", DbType.AnsiString);
            }
        }

        [ConditionalFact]
        public void Custom_function_parameter_type_mapping()
            => Test(
                new FunctionParameterTypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "FunctionParameterTypeMappingContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.FunctionParameterTypeMappingContext))]
    public partial class FunctionParameterTypeMappingContextModel : RuntimeModel
    {
        static FunctionParameterTypeMappingContextModel()
        {
            var model = new FunctionParameterTypeMappingContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static FunctionParameterTypeMappingContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "FunctionParameterTypeMappingContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class FunctionParameterTypeMappingContextModel
    {
        partial void Initialize()
        {
            var functions = new SortedDictionary<string, IDbFunction>();
            var getSqlFragmentStatic = new RuntimeDbFunction(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+FunctionParameterTypeMappingContext.GetSqlFragmentStatic(string)",
                this,
                typeof(string),
                "GetSqlFragmentStatic",
                schema: "dbo",
                storeType: "nvarchar(max)",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.FunctionParameterTypeMappingContext).GetMethod(
                    "GetSqlFragmentStatic",
                    BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(string) },
                    null),
                scalar: true,
                nullable: true);

            var param = getSqlFragmentStatic.AddParameter(
                "param",
                typeof(string),
                false,
                "varchar");
            param.TypeMapping = StringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar",
                    dbType: System.Data.DbType.AnsiString));

            getSqlFragmentStatic.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            functions["Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+FunctionParameterTypeMappingContext.GetSqlFragmentStatic(string)"] = getSqlFragmentStatic;

            AddAnnotation("Relational:DbFunctions", functions);
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);
            var getSqlFragmentStatic = (IRuntimeDbFunction)this.FindDbFunction("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+FunctionParameterTypeMappingContext.GetSqlFragmentStatic(string)")!;
            var getSqlFragmentStaticFunction = new StoreFunction(getSqlFragmentStatic, relationalModel);
            var paramFunctionParameter = getSqlFragmentStaticFunction.FindParameter("param")!;
            relationalModel.Functions.Add(
                ("GetSqlFragmentStatic", "dbo", new[] { "varchar" }),
                getSqlFragmentStaticFunction);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c)),
                model =>
                {
                    var function = model.GetDbFunctions().Single();
                    var parameter = function.Parameters.Single();

                    var typeMapping = parameter.TypeMapping;
                    Assert.IsType<StringTypeMapping>(typeMapping);
                    Assert.Equal("varchar", typeMapping.StoreType);
                });

        public class FunctionParameterTypeMappingContext : SqlServerContextBase
        {
            public static string GetSqlFragmentStatic(string param)
                => throw new NotImplementedException();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(typeof(FunctionParameterTypeMappingContext).GetMethod(nameof(GetSqlFragmentStatic)))
                    .HasParameter("param").Metadata.TypeMapping = new StringTypeMapping("varchar", DbType.AnsiString);
            }
        }

        [ConditionalFact]
        public void Throws_for_custom_function_translation()
            => Test(
                new FunctionTranslationContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: RelationalStrings.CompiledModelFunctionTranslation("GetSqlFragmentStatic"));

        public class FunctionTranslationContext : SqlServerContextBase
        {
            public static string GetSqlFragmentStatic()
                => throw new NotImplementedException();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(typeof(FunctionTranslationContext).GetMethod(nameof(GetSqlFragmentStatic)))
                    .HasTranslation(args => new SqlFragmentExpression("NULL"));
            }
        }

        [ConditionalFact]
        public void Fully_qualified_model()
            => Test(
                new TestModel.Internal.DbContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = "Internal" },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "DbContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    [DbContext(typeof(DbContext))]
    public partial class DbContextModel : RuntimeModel
    {
        static DbContextModel()
        {
            var model = new DbContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static DbContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "DbContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    public partial class DbContextModel
    {
        partial void Initialize()
        {
            var index = IndexEntityType.Create(this);
            var @internal = InternalEntityType.Create(this);
            var identityUser = IdentityUserEntityType.Create(this);
            var identityUser0 = IdentityUser0EntityType.Create(this, identityUser);

            IndexEntityType.CreateAnnotations(index);
            InternalEntityType.CreateAnnotations(@internal);
            IdentityUserEntityType.CreateAnnotations(identityUser);
            IdentityUser0EntityType.CreateAnnotations(identityUser0);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "IndexEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class IndexEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index",
                typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(Guid),
                propertyInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                clrType: typeof(Guid),
                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "InternalEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class InternalEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal",
                typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long),
                propertyInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Microsoft.EntityFrameworkCore.Scaffolding.Internal.Internal).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                clrType: typeof(long),
                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "IdentityUserEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class IdentityUserEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity.IdentityUser",
                typeof(IdentityUser),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "IdentityUser");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var accessFailedCount = runtimeEntityType.AddProperty(
                "AccessFailedCount",
                typeof(int),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("AccessFailedCount", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<AccessFailedCount>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            accessFailedCount.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var concurrencyStamp = runtimeEntityType.AddProperty(
                "ConcurrencyStamp",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("ConcurrencyStamp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<ConcurrencyStamp>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            concurrencyStamp.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var discriminator = runtimeEntityType.AddProperty(
                "Discriminator",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            discriminator.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var email = runtimeEntityType.AddProperty(
                "Email",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("Email", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<Email>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            email.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var emailConfirmed = runtimeEntityType.AddProperty(
                "EmailConfirmed",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("EmailConfirmed", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<EmailConfirmed>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            emailConfirmed.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                clrType: typeof(bool),
                jsonValueReaderWriter: JsonBoolReaderWriter.Instance);

            var lockoutEnabled = runtimeEntityType.AddProperty(
                "LockoutEnabled",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("LockoutEnabled", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<LockoutEnabled>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            lockoutEnabled.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                clrType: typeof(bool),
                jsonValueReaderWriter: JsonBoolReaderWriter.Instance);

            var lockoutEnd = runtimeEntityType.AddProperty(
                "LockoutEnd",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("LockoutEnd", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<LockoutEnd>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            lockoutEnd.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                keyComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                providerValueComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                clrType: typeof(DateTimeOffset),
                jsonValueReaderWriter: JsonDateTimeOffsetReaderWriter.Instance);

            var normalizedEmail = runtimeEntityType.AddProperty(
                "NormalizedEmail",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("NormalizedEmail", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<NormalizedEmail>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            normalizedEmail.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var normalizedUserName = runtimeEntityType.AddProperty(
                "NormalizedUserName",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("NormalizedUserName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<NormalizedUserName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            normalizedUserName.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var passwordHash = runtimeEntityType.AddProperty(
                "PasswordHash",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("PasswordHash", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<PasswordHash>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            passwordHash.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var phoneNumber = runtimeEntityType.AddProperty(
                "PhoneNumber",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("PhoneNumber", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<PhoneNumber>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            phoneNumber.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var phoneNumberConfirmed = runtimeEntityType.AddProperty(
                "PhoneNumberConfirmed",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("PhoneNumberConfirmed", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<PhoneNumberConfirmed>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            phoneNumberConfirmed.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                clrType: typeof(bool),
                jsonValueReaderWriter: JsonBoolReaderWriter.Instance);

            var securityStamp = runtimeEntityType.AddProperty(
                "SecurityStamp",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("SecurityStamp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<SecurityStamp>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            securityStamp.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var twoFactorEnabled = runtimeEntityType.AddProperty(
                "TwoFactorEnabled",
                typeof(bool),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("TwoFactorEnabled", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<TwoFactorEnabled>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            twoFactorEnabled.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                clrType: typeof(bool),
                jsonValueReaderWriter: JsonBoolReaderWriter.Instance);

            var userName = runtimeEntityType.AddProperty(
                "UserName",
                typeof(string),
                propertyInfo: typeof(IdentityUser<string>).GetProperty("UserName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(IdentityUser<string>).GetField("<UserName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            userName.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "IdentityUser0EntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Internal
{
    internal partial class IdentityUser0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.IdentityUser",
                typeof(IdentityUser),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "DerivedIdentityUser");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Equal(4, model.GetEntityTypes().Count());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                },
                typeof(FullyQualifiedDesignTimeServices));

        private class FullyQualifiedDesignTimeServices : IDesignTimeServices
        {
            public void ConfigureDesignTimeServices(IServiceCollection serviceCollection)
                => serviceCollection.AddSingleton<ICSharpHelper, FullyQualifiedCSharpHelper>();
        }

        private class FullyQualifiedCSharpHelper : CSharpHelper
        {
            public FullyQualifiedCSharpHelper(ITypeMappingSource typeMappingSource)
                : base(typeMappingSource)
            {
            }

            protected override bool ShouldUseFullName(Type type)
                => base.ShouldUseFullName(type);

            protected override bool ShouldUseFullName(string shortTypeName)
                => base.ShouldUseFullName(shortTypeName) || shortTypeName is nameof(Index) or nameof(Internal);
        }

        [ConditionalFact]
        [SqlServerConfiguredCondition]
        public void BigModel()
            => Test(
                new BigContext(),
                new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "BigContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.BigContext))]
    public partial class BigContextModel : RuntimeModel
    {
        static BigContextModel()
        {
            var model = new BigContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static BigContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "BigContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Migrations;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class BigContextModel
    {
        partial void Initialize()
        {
            var dependentBase = DependentBaseEntityType.Create(this);
            var manyTypes = ManyTypesEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var ownedType = OwnedTypeEntityType.Create(this);
            var ownedType0 = OwnedType0EntityType.Create(this);
            var principalBasePrincipalDerivedDependentBasebyte = PrincipalBasePrincipalDerivedDependentBasebyteEntityType.Create(this);
            var dependentDerived = DependentDerivedEntityType.Create(this, dependentBase);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalBase);
            DependentBaseEntityType.CreateForeignKey2(dependentBase, principalDerived);
            OwnedTypeEntityType.CreateForeignKey1(ownedType, principalBase);
            OwnedTypeEntityType.CreateForeignKey2(ownedType, ownedType);
            OwnedType0EntityType.CreateForeignKey1(ownedType0, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey1(principalBasePrincipalDerivedDependentBasebyte, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey2(principalBasePrincipalDerivedDependentBasebyte, principalBase);
            PrincipalDerivedEntityType.CreateForeignKey1(principalDerived, principalBase);

            PrincipalBaseEntityType.CreateSkipNavigation1(principalBase, principalDerived, principalBasePrincipalDerivedDependentBasebyte);
            PrincipalDerivedEntityType.CreateSkipNavigation1(principalDerived, principalBase, principalBasePrincipalDerivedDependentBasebyte);

            DependentBaseEntityType.CreateAnnotations(dependentBase);
            ManyTypesEntityType.CreateAnnotations(manyTypes);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            OwnedTypeEntityType.CreateAnnotations(ownedType);
            OwnedType0EntityType.CreateAnnotations(ownedType0);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateAnnotations(principalBasePrincipalDerivedDependentBasebyte);
            DependentDerivedEntityType.CreateAnnotations(dependentDerived);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            dependentBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", null, relationalModel);
            var dataColumnBase = new ColumnBase<ColumnMappingBase>("Data", "char(20)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Data", dataColumnBase);
            var enumDiscriminatorColumnBase = new ColumnBase<ColumnMappingBase>("EnumDiscriminator", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("EnumDiscriminator", enumDiscriminatorColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase);
            var moneyColumnBase = new ColumnBase<ColumnMappingBase>("Money", "decimal(9,3)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Money", moneyColumnBase);
            var principalAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalAlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalAlternateId", principalAlternateIdColumnBase);
            var principalIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalId", principalIdColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(dependentBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentBase.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentBase.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentBase.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, dependentBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings = new List<TableMapping>();
            dependentBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
            var principalIdColumn = new Column("PrincipalId", "bigint", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
            var principalAlternateIdColumn = new Column("PrincipalAlternateId", "uniqueidentifier", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
            var dataColumn = new Column("Data", "char(20)", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Data", dataColumn);
            var enumDiscriminatorColumn = new Column("EnumDiscriminator", "int", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
            var idColumn = new Column("Id", "tinyint", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Id", idColumn);
            var moneyColumn = new Column("Money", "decimal(9,3)", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Money", moneyColumn);
            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
            var pK_DependentBasebyteUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" });
            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteUc).Add(pK_DependentBasebyte);
            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
            var iX_DependentBasebyte_PrincipalId = new TableIndex(
            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" });
            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
            relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
            tableMappings.Add(dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentBase.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentBase.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);

            var dependentDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            dependentDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0 = new TableMappingBase<ColumnMappingBase>(dependentDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0, false);
            defaultTableMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentDerived.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentDerived.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dataColumnBase, dependentDerived.FindProperty("Data")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentDerived.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, dependentDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)moneyColumnBase, dependentDerived.FindProperty("Money")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);

            var tableMappings0 = new List<TableMapping>();
            dependentDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings0);
            var dependentBasebyteTableMapping0 = new TableMapping(dependentDerived, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping0, false);
            tableMappings0.Add(dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentDerived.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentDerived.FindProperty("PrincipalId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);

            var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes")!;

            var defaultTableMappings1 = new List<TableMappingBase<ColumnMappingBase>>();
            manyTypes.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings1);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", null, relationalModel);
            var boolColumnBase = new ColumnBase<ColumnMappingBase>("Bool", "bit", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bool", boolColumnBase);
            var boolArrayColumnBase = new ColumnBase<ColumnMappingBase>("BoolArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolArray", boolArrayColumnBase);
            var bytesColumnBase = new ColumnBase<ColumnMappingBase>("Bytes", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bytes", bytesColumnBase);
            var bytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("BytesArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BytesArray", bytesArrayColumnBase);
            var charColumnBase = new ColumnBase<ColumnMappingBase>("Char", "nvarchar(1)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Char", charColumnBase);
            var charArrayColumnBase = new ColumnBase<ColumnMappingBase>("CharArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("CharArray", charArrayColumnBase);
            var dateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("DateOnly", "date", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnly", dateOnlyColumnBase);
            var dateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnlyArray", dateOnlyArrayColumnBase);
            var dateTimeColumnBase = new ColumnBase<ColumnMappingBase>("DateTime", "datetime2", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTime", dateTimeColumnBase);
            var dateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeArray", dateTimeArrayColumnBase);
            var decimalColumnBase = new ColumnBase<ColumnMappingBase>("Decimal", "decimal(18,2)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Decimal", decimalColumnBase);
            var decimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("DecimalArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DecimalArray", decimalArrayColumnBase);
            var doubleColumnBase = new ColumnBase<ColumnMappingBase>("Double", "float", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Double", doubleColumnBase);
            var doubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("DoubleArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DoubleArray", doubleArrayColumnBase);
            var floatColumnBase = new ColumnBase<ColumnMappingBase>("Float", "real", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Float", floatColumnBase);
            var floatArrayColumnBase = new ColumnBase<ColumnMappingBase>("FloatArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("FloatArray", floatArrayColumnBase);
            var guidColumnBase = new ColumnBase<ColumnMappingBase>("Guid", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Guid", guidColumnBase);
            var guidArrayColumnBase = new ColumnBase<ColumnMappingBase>("GuidArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("GuidArray", guidArrayColumnBase);
            var iPAddressColumnBase = new ColumnBase<ColumnMappingBase>("IPAddress", "nvarchar(45)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddress", iPAddressColumnBase);
            var iPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("IPAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddressArray", iPAddressArrayColumnBase);
            var idColumnBase0 = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Id", idColumnBase0);
            var int16ColumnBase = new ColumnBase<ColumnMappingBase>("Int16", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16", int16ColumnBase);
            var int16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16Array", int16ArrayColumnBase);
            var int32ColumnBase = new ColumnBase<ColumnMappingBase>("Int32", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32", int32ColumnBase);
            var int32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32Array", int32ArrayColumnBase);
            var int64ColumnBase = new ColumnBase<ColumnMappingBase>("Int64", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64", int64ColumnBase);
            var int64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64Array", int64ArrayColumnBase);
            var int8ColumnBase = new ColumnBase<ColumnMappingBase>("Int8", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8", int8ColumnBase);
            var int8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int8Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8Array", int8ArrayColumnBase);
            var nullableBoolColumnBase = new ColumnBase<ColumnMappingBase>("NullableBool", "bit", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBool", nullableBoolColumnBase);
            var nullableBoolArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBoolArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBoolArray", nullableBoolArrayColumnBase);
            var nullableBytesColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytes", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytes", nullableBytesColumnBase);
            var nullableBytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytesArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytesArray", nullableBytesArrayColumnBase);
            var nullableCharColumnBase = new ColumnBase<ColumnMappingBase>("NullableChar", "nvarchar(1)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableChar", nullableCharColumnBase);
            var nullableCharArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableCharArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableCharArray", nullableCharArrayColumnBase);
            var nullableDateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnly", "date", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnly", nullableDateOnlyColumnBase);
            var nullableDateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumnBase);
            var nullableDateTimeColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTime", "datetime2", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTime", nullableDateTimeColumnBase);
            var nullableDateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTimeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumnBase);
            var nullableDecimalColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimal", "decimal(18,2)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimal", nullableDecimalColumnBase);
            var nullableDecimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimalArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumnBase);
            var nullableDoubleColumnBase = new ColumnBase<ColumnMappingBase>("NullableDouble", "float", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDouble", nullableDoubleColumnBase);
            var nullableDoubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDoubleArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumnBase);
            var nullableFloatColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloat", "real", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloat", nullableFloatColumnBase);
            var nullableFloatArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloatArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloatArray", nullableFloatArrayColumnBase);
            var nullableGuidColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuid", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuid", nullableGuidColumnBase);
            var nullableGuidArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuidArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuidArray", nullableGuidArrayColumnBase);
            var nullableIPAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddress", "nvarchar(45)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddress", nullableIPAddressColumnBase);
            var nullableIPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumnBase);
            var nullableInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16", nullableInt16ColumnBase);
            var nullableInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16Array", nullableInt16ArrayColumnBase);
            var nullableInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32", nullableInt32ColumnBase);
            var nullableInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32Array", nullableInt32ArrayColumnBase);
            var nullableInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64", nullableInt64ColumnBase);
            var nullableInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64Array", nullableInt64ArrayColumnBase);
            var nullableInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8", nullableInt8ColumnBase);
            var nullableInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8Array", nullableInt8ArrayColumnBase);
            var nullablePhysicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddress", "nvarchar(20)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumnBase);
            var nullablePhysicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumnBase);
            var nullableStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableString", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableString", nullableStringColumnBase);
            var nullableStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableStringArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableStringArray", nullableStringArrayColumnBase);
            var nullableTimeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnly", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumnBase);
            var nullableTimeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumnBase);
            var nullableTimeSpanColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpan", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpan", nullableTimeSpanColumnBase);
            var nullableTimeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpanArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumnBase);
            var nullableUInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16", nullableUInt16ColumnBase);
            var nullableUInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumnBase);
            var nullableUInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32", nullableUInt32ColumnBase);
            var nullableUInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumnBase);
            var nullableUInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64", "decimal(20,0)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64", nullableUInt64ColumnBase);
            var nullableUInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumnBase);
            var nullableUInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8", nullableUInt8ColumnBase);
            var nullableUInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumnBase);
            var nullableUriColumnBase = new ColumnBase<ColumnMappingBase>("NullableUri", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUri", nullableUriColumnBase);
            var nullableUriArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUriArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUriArray", nullableUriArrayColumnBase);
            var physicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddress", "nvarchar(20)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddress", physicalAddressColumnBase);
            var physicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumnBase);
            var stringColumnBase = new ColumnBase<ColumnMappingBase>("String", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("String", stringColumnBase);
            var stringArrayColumnBase = new ColumnBase<ColumnMappingBase>("StringArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringArray", stringArrayColumnBase);
            var timeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnly", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnly", timeOnlyColumnBase);
            var timeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnlyArray", timeOnlyArrayColumnBase);
            var timeSpanColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpan", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpan", timeSpanColumnBase);
            var timeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpanArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpanArray", timeSpanArrayColumnBase);
            var uInt16ColumnBase = new ColumnBase<ColumnMappingBase>("UInt16", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16", uInt16ColumnBase);
            var uInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16Array", uInt16ArrayColumnBase);
            var uInt32ColumnBase = new ColumnBase<ColumnMappingBase>("UInt32", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32", uInt32ColumnBase);
            var uInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32Array", uInt32ArrayColumnBase);
            var uInt64ColumnBase = new ColumnBase<ColumnMappingBase>("UInt64", "decimal(20,0)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64", uInt64ColumnBase);
            var uInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64Array", uInt64ArrayColumnBase);
            var uInt8ColumnBase = new ColumnBase<ColumnMappingBase>("UInt8", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8", uInt8ColumnBase);
            var uInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt8Array", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8Array", uInt8ArrayColumnBase);
            var uriColumnBase = new ColumnBase<ColumnMappingBase>("Uri", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Uri", uriColumnBase);
            var uriArrayColumnBase = new ColumnBase<ColumnMappingBase>("UriArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UriArray", uriArrayColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase = new TableMappingBase<ColumnMappingBase>(manyTypes, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase, false);
            defaultTableMappings1.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, manyTypes.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolColumnBase, manyTypes.FindProperty("Bool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolArrayColumnBase, manyTypes.FindProperty("BoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesColumnBase, manyTypes.FindProperty("Bytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesArrayColumnBase, manyTypes.FindProperty("BytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charColumnBase, manyTypes.FindProperty("Char")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charArrayColumnBase, manyTypes.FindProperty("CharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyColumnBase, manyTypes.FindProperty("DateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyArrayColumnBase, manyTypes.FindProperty("DateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeColumnBase, manyTypes.FindProperty("DateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeArrayColumnBase, manyTypes.FindProperty("DateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalColumnBase, manyTypes.FindProperty("Decimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalArrayColumnBase, manyTypes.FindProperty("DecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleColumnBase, manyTypes.FindProperty("Double")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleArrayColumnBase, manyTypes.FindProperty("DoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatColumnBase, manyTypes.FindProperty("Float")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatArrayColumnBase, manyTypes.FindProperty("FloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidColumnBase, manyTypes.FindProperty("Guid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidArrayColumnBase, manyTypes.FindProperty("GuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressColumnBase, manyTypes.FindProperty("IPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressArrayColumnBase, manyTypes.FindProperty("IPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ColumnBase, manyTypes.FindProperty("Int16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ArrayColumnBase, manyTypes.FindProperty("Int16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ColumnBase, manyTypes.FindProperty("Int32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ArrayColumnBase, manyTypes.FindProperty("Int32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ColumnBase, manyTypes.FindProperty("Int64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ArrayColumnBase, manyTypes.FindProperty("Int64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ColumnBase, manyTypes.FindProperty("Int8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ArrayColumnBase, manyTypes.FindProperty("Int8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolColumnBase, manyTypes.FindProperty("NullableBool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolArrayColumnBase, manyTypes.FindProperty("NullableBoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesColumnBase, manyTypes.FindProperty("NullableBytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesArrayColumnBase, manyTypes.FindProperty("NullableBytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharColumnBase, manyTypes.FindProperty("NullableChar")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharArrayColumnBase, manyTypes.FindProperty("NullableCharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyColumnBase, manyTypes.FindProperty("NullableDateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyArrayColumnBase, manyTypes.FindProperty("NullableDateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeColumnBase, manyTypes.FindProperty("NullableDateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeArrayColumnBase, manyTypes.FindProperty("NullableDateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalColumnBase, manyTypes.FindProperty("NullableDecimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalArrayColumnBase, manyTypes.FindProperty("NullableDecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleColumnBase, manyTypes.FindProperty("NullableDouble")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleArrayColumnBase, manyTypes.FindProperty("NullableDoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatColumnBase, manyTypes.FindProperty("NullableFloat")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatArrayColumnBase, manyTypes.FindProperty("NullableFloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidColumnBase, manyTypes.FindProperty("NullableGuid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidArrayColumnBase, manyTypes.FindProperty("NullableGuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressColumnBase, manyTypes.FindProperty("NullableIPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressArrayColumnBase, manyTypes.FindProperty("NullableIPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ColumnBase, manyTypes.FindProperty("NullableInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ArrayColumnBase, manyTypes.FindProperty("NullableInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ColumnBase, manyTypes.FindProperty("NullableInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ArrayColumnBase, manyTypes.FindProperty("NullableInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ColumnBase, manyTypes.FindProperty("NullableInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ArrayColumnBase, manyTypes.FindProperty("NullableInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ColumnBase, manyTypes.FindProperty("NullableInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ArrayColumnBase, manyTypes.FindProperty("NullableInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressColumnBase, manyTypes.FindProperty("NullablePhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressArrayColumnBase, manyTypes.FindProperty("NullablePhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringColumnBase, manyTypes.FindProperty("NullableString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringArrayColumnBase, manyTypes.FindProperty("NullableStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyColumnBase, manyTypes.FindProperty("NullableTimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyArrayColumnBase, manyTypes.FindProperty("NullableTimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanColumnBase, manyTypes.FindProperty("NullableTimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanArrayColumnBase, manyTypes.FindProperty("NullableTimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ColumnBase, manyTypes.FindProperty("NullableUInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ArrayColumnBase, manyTypes.FindProperty("NullableUInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ColumnBase, manyTypes.FindProperty("NullableUInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ArrayColumnBase, manyTypes.FindProperty("NullableUInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ColumnBase, manyTypes.FindProperty("NullableUInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ArrayColumnBase, manyTypes.FindProperty("NullableUInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ColumnBase, manyTypes.FindProperty("NullableUInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ArrayColumnBase, manyTypes.FindProperty("NullableUInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriColumnBase, manyTypes.FindProperty("NullableUri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriArrayColumnBase, manyTypes.FindProperty("NullableUriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressColumnBase, manyTypes.FindProperty("PhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressArrayColumnBase, manyTypes.FindProperty("PhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringColumnBase, manyTypes.FindProperty("String")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringArrayColumnBase, manyTypes.FindProperty("StringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyColumnBase, manyTypes.FindProperty("TimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyArrayColumnBase, manyTypes.FindProperty("TimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanColumnBase, manyTypes.FindProperty("TimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanArrayColumnBase, manyTypes.FindProperty("TimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ColumnBase, manyTypes.FindProperty("UInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ArrayColumnBase, manyTypes.FindProperty("UInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ColumnBase, manyTypes.FindProperty("UInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ArrayColumnBase, manyTypes.FindProperty("UInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ColumnBase, manyTypes.FindProperty("UInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ArrayColumnBase, manyTypes.FindProperty("UInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ColumnBase, manyTypes.FindProperty("UInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ArrayColumnBase, manyTypes.FindProperty("UInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriColumnBase, manyTypes.FindProperty("Uri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriArrayColumnBase, manyTypes.FindProperty("UriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);

            var tableMappings1 = new List<TableMapping>();
            manyTypes.SetRuntimeAnnotation("Relational:TableMappings", tableMappings1);
            var manyTypesTable = new Table("ManyTypes", null, relationalModel);
            var idColumn0 = new Column("Id", "int", manyTypesTable);
            manyTypesTable.Columns.Add("Id", idColumn0);
            var boolColumn = new Column("Bool", "bit", manyTypesTable);
            manyTypesTable.Columns.Add("Bool", boolColumn);
            var boolArrayColumn = new Column("BoolArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
            var bytesColumn = new Column("Bytes", "varbinary(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Bytes", bytesColumn);
            var bytesArrayColumn = new Column("BytesArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
            var charColumn = new Column("Char", "nvarchar(1)", manyTypesTable);
            manyTypesTable.Columns.Add("Char", charColumn);
            var charArrayColumn = new Column("CharArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("CharArray", charArrayColumn);
            var dateOnlyColumn = new Column("DateOnly", "date", manyTypesTable);
            manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
            var dateOnlyArrayColumn = new Column("DateOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
            var dateTimeColumn = new Column("DateTime", "datetime2", manyTypesTable);
            manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
            var dateTimeArrayColumn = new Column("DateTimeArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
            var decimalColumn = new Column("Decimal", "decimal(18,2)", manyTypesTable);
            manyTypesTable.Columns.Add("Decimal", decimalColumn);
            var decimalArrayColumn = new Column("DecimalArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
            var doubleColumn = new Column("Double", "float", manyTypesTable);
            manyTypesTable.Columns.Add("Double", doubleColumn);
            var doubleArrayColumn = new Column("DoubleArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
            var floatColumn = new Column("Float", "real", manyTypesTable);
            manyTypesTable.Columns.Add("Float", floatColumn);
            var floatArrayColumn = new Column("FloatArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
            var guidColumn = new Column("Guid", "uniqueidentifier", manyTypesTable);
            manyTypesTable.Columns.Add("Guid", guidColumn);
            var guidArrayColumn = new Column("GuidArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
            var iPAddressColumn = new Column("IPAddress", "nvarchar(45)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
            var iPAddressArrayColumn = new Column("IPAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
            var int16Column = new Column("Int16", "smallint", manyTypesTable);
            manyTypesTable.Columns.Add("Int16", int16Column);
            var int16ArrayColumn = new Column("Int16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
            var int32Column = new Column("Int32", "int", manyTypesTable);
            manyTypesTable.Columns.Add("Int32", int32Column);
            var int32ArrayColumn = new Column("Int32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
            var int64Column = new Column("Int64", "bigint", manyTypesTable);
            manyTypesTable.Columns.Add("Int64", int64Column);
            var int64ArrayColumn = new Column("Int64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
            var int8Column = new Column("Int8", "smallint", manyTypesTable);
            manyTypesTable.Columns.Add("Int8", int8Column);
            var int8ArrayColumn = new Column("Int8Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
            var nullableBoolColumn = new Column("NullableBool", "bit", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
            var nullableBoolArrayColumn = new Column("NullableBoolArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
            var nullableBytesColumn = new Column("NullableBytes", "varbinary(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
            var nullableBytesArrayColumn = new Column("NullableBytesArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
            var nullableCharColumn = new Column("NullableChar", "nvarchar(1)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
            var nullableCharArrayColumn = new Column("NullableCharArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
            var nullableDateOnlyColumn = new Column("NullableDateOnly", "date", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
            var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
            var nullableDateTimeColumn = new Column("NullableDateTime", "datetime2", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
            var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
            var nullableDecimalColumn = new Column("NullableDecimal", "decimal(18,2)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
            var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
            var nullableDoubleColumn = new Column("NullableDouble", "float", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
            var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
            var nullableFloatColumn = new Column("NullableFloat", "real", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
            var nullableFloatArrayColumn = new Column("NullableFloatArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
            var nullableGuidColumn = new Column("NullableGuid", "uniqueidentifier", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
            var nullableGuidArrayColumn = new Column("NullableGuidArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
            var nullableIPAddressColumn = new Column("NullableIPAddress", "nvarchar(45)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
            var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
            var nullableInt16Column = new Column("NullableInt16", "smallint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
            var nullableInt16ArrayColumn = new Column("NullableInt16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
            var nullableInt32Column = new Column("NullableInt32", "int", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
            var nullableInt32ArrayColumn = new Column("NullableInt32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
            var nullableInt64Column = new Column("NullableInt64", "bigint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
            var nullableInt64ArrayColumn = new Column("NullableInt64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
            var nullableInt8Column = new Column("NullableInt8", "smallint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
            var nullableInt8ArrayColumn = new Column("NullableInt8Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
            var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "nvarchar(20)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
            var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
            var nullableStringColumn = new Column("NullableString", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
            var nullableStringArrayColumn = new Column("NullableStringArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
            var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "time", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
            var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
            var nullableTimeSpanColumn = new Column("NullableTimeSpan", "time", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
            var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
            var nullableUInt16Column = new Column("NullableUInt16", "int", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
            var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
            var nullableUInt32Column = new Column("NullableUInt32", "bigint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
            var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
            var nullableUInt64Column = new Column("NullableUInt64", "decimal(20,0)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
            var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
            var nullableUInt8Column = new Column("NullableUInt8", "tinyint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
            var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
            var nullableUriColumn = new Column("NullableUri", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
            var nullableUriArrayColumn = new Column("NullableUriArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
            var physicalAddressColumn = new Column("PhysicalAddress", "nvarchar(20)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
            var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
            var stringColumn = new Column("String", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("String", stringColumn);
            var stringArrayColumn = new Column("StringArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
            var timeOnlyColumn = new Column("TimeOnly", "time", manyTypesTable);
            manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
            var timeOnlyArrayColumn = new Column("TimeOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
            var timeSpanColumn = new Column("TimeSpan", "time", manyTypesTable);
            manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
            var timeSpanArrayColumn = new Column("TimeSpanArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
            var uInt16Column = new Column("UInt16", "int", manyTypesTable);
            manyTypesTable.Columns.Add("UInt16", uInt16Column);
            var uInt16ArrayColumn = new Column("UInt16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
            var uInt32Column = new Column("UInt32", "bigint", manyTypesTable);
            manyTypesTable.Columns.Add("UInt32", uInt32Column);
            var uInt32ArrayColumn = new Column("UInt32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
            var uInt64Column = new Column("UInt64", "decimal(20,0)", manyTypesTable);
            manyTypesTable.Columns.Add("UInt64", uInt64Column);
            var uInt64ArrayColumn = new Column("UInt64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
            var uInt8Column = new Column("UInt8", "tinyint", manyTypesTable);
            manyTypesTable.Columns.Add("UInt8", uInt8Column);
            var uInt8ArrayColumn = new Column("UInt8Array", "varbinary(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
            var uriColumn = new Column("Uri", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Uri", uriColumn);
            var uriArrayColumn = new Column("UriArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn0 });
            manyTypesTable.PrimaryKey = pK_ManyTypes;
            var pK_ManyTypesUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                new[] { "Id" });
            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesUc).Add(pK_ManyTypes);
            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
            relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
            var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, true);
            manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
            tableMappings1.Add(manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(idColumn0, manyTypes.FindProperty("Id")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolColumn, manyTypes.FindProperty("Bool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolArrayColumn, manyTypes.FindProperty("BoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesColumn, manyTypes.FindProperty("Bytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesArrayColumn, manyTypes.FindProperty("BytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charColumn, manyTypes.FindProperty("Char")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charArrayColumn, manyTypes.FindProperty("CharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyColumn, manyTypes.FindProperty("DateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyArrayColumn, manyTypes.FindProperty("DateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeColumn, manyTypes.FindProperty("DateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeArrayColumn, manyTypes.FindProperty("DateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalColumn, manyTypes.FindProperty("Decimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalArrayColumn, manyTypes.FindProperty("DecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleColumn, manyTypes.FindProperty("Double")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleArrayColumn, manyTypes.FindProperty("DoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatColumn, manyTypes.FindProperty("Float")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatArrayColumn, manyTypes.FindProperty("FloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidColumn, manyTypes.FindProperty("Guid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidArrayColumn, manyTypes.FindProperty("GuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressColumn, manyTypes.FindProperty("IPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressArrayColumn, manyTypes.FindProperty("IPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16Column, manyTypes.FindProperty("Int16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16ArrayColumn, manyTypes.FindProperty("Int16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32Column, manyTypes.FindProperty("Int32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32ArrayColumn, manyTypes.FindProperty("Int32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64Column, manyTypes.FindProperty("Int64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64ArrayColumn, manyTypes.FindProperty("Int64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8Column, manyTypes.FindProperty("Int8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8ArrayColumn, manyTypes.FindProperty("Int8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolColumn, manyTypes.FindProperty("NullableBool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolArrayColumn, manyTypes.FindProperty("NullableBoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesColumn, manyTypes.FindProperty("NullableBytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesArrayColumn, manyTypes.FindProperty("NullableBytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharColumn, manyTypes.FindProperty("NullableChar")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharArrayColumn, manyTypes.FindProperty("NullableCharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyColumn, manyTypes.FindProperty("NullableDateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyArrayColumn, manyTypes.FindProperty("NullableDateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeColumn, manyTypes.FindProperty("NullableDateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeArrayColumn, manyTypes.FindProperty("NullableDateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalColumn, manyTypes.FindProperty("NullableDecimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalArrayColumn, manyTypes.FindProperty("NullableDecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleColumn, manyTypes.FindProperty("NullableDouble")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleArrayColumn, manyTypes.FindProperty("NullableDoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatColumn, manyTypes.FindProperty("NullableFloat")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatArrayColumn, manyTypes.FindProperty("NullableFloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidColumn, manyTypes.FindProperty("NullableGuid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidArrayColumn, manyTypes.FindProperty("NullableGuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressColumn, manyTypes.FindProperty("NullableIPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressArrayColumn, manyTypes.FindProperty("NullableIPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16Column, manyTypes.FindProperty("NullableInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16ArrayColumn, manyTypes.FindProperty("NullableInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32Column, manyTypes.FindProperty("NullableInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32ArrayColumn, manyTypes.FindProperty("NullableInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64Column, manyTypes.FindProperty("NullableInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64ArrayColumn, manyTypes.FindProperty("NullableInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8Column, manyTypes.FindProperty("NullableInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8ArrayColumn, manyTypes.FindProperty("NullableInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressColumn, manyTypes.FindProperty("NullablePhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressArrayColumn, manyTypes.FindProperty("NullablePhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringColumn, manyTypes.FindProperty("NullableString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringArrayColumn, manyTypes.FindProperty("NullableStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyColumn, manyTypes.FindProperty("NullableTimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyArrayColumn, manyTypes.FindProperty("NullableTimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanColumn, manyTypes.FindProperty("NullableTimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanArrayColumn, manyTypes.FindProperty("NullableTimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16Column, manyTypes.FindProperty("NullableUInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16ArrayColumn, manyTypes.FindProperty("NullableUInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32Column, manyTypes.FindProperty("NullableUInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32ArrayColumn, manyTypes.FindProperty("NullableUInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64Column, manyTypes.FindProperty("NullableUInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64ArrayColumn, manyTypes.FindProperty("NullableUInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8Column, manyTypes.FindProperty("NullableUInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8ArrayColumn, manyTypes.FindProperty("NullableUInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriColumn, manyTypes.FindProperty("NullableUri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriArrayColumn, manyTypes.FindProperty("NullableUriArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressColumn, manyTypes.FindProperty("PhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressArrayColumn, manyTypes.FindProperty("PhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringColumn, manyTypes.FindProperty("String")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringArrayColumn, manyTypes.FindProperty("StringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyColumn, manyTypes.FindProperty("TimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyArrayColumn, manyTypes.FindProperty("TimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanColumn, manyTypes.FindProperty("TimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanArrayColumn, manyTypes.FindProperty("TimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16Column, manyTypes.FindProperty("UInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16ArrayColumn, manyTypes.FindProperty("UInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32Column, manyTypes.FindProperty("UInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32ArrayColumn, manyTypes.FindProperty("UInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64Column, manyTypes.FindProperty("UInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64ArrayColumn, manyTypes.FindProperty("UInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8Column, manyTypes.FindProperty("UInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8ArrayColumn, manyTypes.FindProperty("UInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);

            var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase")!;

            var defaultTableMappings2 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings2);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", null, relationalModel);
            var alternateIdColumnBase = new ColumnBase<ColumnMappingBase>("AlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("AlternateId", alternateIdColumnBase);
            var enum1ColumnBase = new ColumnBase<ColumnMappingBase>("Enum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum1", enum1ColumnBase);
            var enum2ColumnBase = new ColumnBase<ColumnMappingBase>("Enum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum2", enum2ColumnBase);
            var flagsEnum1ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase);
            var flagsEnum2ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase);
            var idColumnBase1 = new ColumnBase<ColumnMappingBase>("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Id", idColumnBase1);
            var pointColumnBase = new ColumnBase<ColumnMappingBase>("Point", "geometry", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Point", pointColumnBase);
            var refTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase);
            var refTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase);
            var refTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase);
            var refTypeListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeList", refTypeListColumnBase);
            var valueTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase);
            var valueTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase);
            var valueTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase);
            var valueTypeListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase = new TableMappingBase<ColumnMappingBase>(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase, false);
            defaultTableMappings2.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalBase.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase, principalBase.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);

            var tableMappings2 = new List<TableMapping>();
            principalBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings2);
            var principalBaseTable = new Table("PrincipalBase", "mySchema", relationalModel);
            var idColumn1 = new Column("Id", "bigint", principalBaseTable);
            principalBaseTable.Columns.Add("Id", idColumn1);
            var alternateIdColumn = new Column("AlternateId", "uniqueidentifier", principalBaseTable);
            principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
            var enum1Column = new Column("Enum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Enum1", enum1Column);
            var enum2Column = new Column("Enum2", "int", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Enum2", enum2Column);
            var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
            var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
            var owned_NumberColumn = new Column("Owned_Number", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
            var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
            var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
            var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
            var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
            var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
            var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
            var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
            var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
            var pointColumn = new Column("Point", "geometry", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Point", pointColumn);
            var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
            var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
            var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
            var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
            var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
            var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
            var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
            var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn1 });
            var aK_PrincipalBase_IdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdUc).Add(aK_PrincipalBase_Id);
            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn1, alternateIdColumn });
            principalBaseTable.PrimaryKey = pK;
            var pKUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK.MappedKeys.Add(pKUc);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc).Add(pK);
            var pKUc0 = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            pK.MappedKeys.Add(pKUc0);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc0).Add(pK);
            principalBaseTable.UniqueConstraints.Add("PK", pK);
            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn1 }, false);
            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
            relationalModel.Tables.Add(("PrincipalBase", "mySchema"), principalBaseTable);
            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
            tableMappings2.Add(principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalBase.FindProperty("AlternateId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(idColumn1, principalBase.FindProperty("Id")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(pointColumn, principalBase.FindProperty("Point")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);

            var ownedType = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType")!;

            var defaultTableMappings3 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings3);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", null, relationalModel);
            var detailsColumnBase = new ColumnBase<ColumnMappingBase>("Details", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Details", detailsColumnBase);
            var numberColumnBase = new ColumnBase<ColumnMappingBase>("Number", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Number", numberColumnBase);
            var principalBaseAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseAlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumnBase);
            var principalBaseIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("PrincipalBaseId", principalBaseIdColumnBase);
            var refTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase0);
            var refTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase0);
            var refTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase0);
            var refTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeList", refTypeListColumnBase0);
            var valueTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase0);
            var valueTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase0);
            var valueTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase0);
            var valueTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase0);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase, false);
            defaultTableMappings3.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseAlternateIdColumnBase, ownedType.FindProperty("PrincipalBaseAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase, ownedType.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)detailsColumnBase, ownedType.FindProperty("Details")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)numberColumnBase, ownedType.FindProperty("Number")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase0, ownedType.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase0, ownedType.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase0, ownedType.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase0, ownedType.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase0, ownedType.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase0, ownedType.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase0, ownedType.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase0, ownedType.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);

            var tableMappings3 = new List<TableMapping>();
            ownedType.SetRuntimeAnnotation("Relational:TableMappings", tableMappings3);
            var principalBaseTableMapping0 = new TableMapping(ownedType, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
                IsSplitEntityTypePrincipal = true
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping0, false);
            tableMappings3.Add(principalBaseTableMapping0);
            principalBaseTable.AddRowInternalForeignKey(ownedType, RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" }));
            RelationalModel.CreateColumnMapping(alternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn1, ownedType.FindProperty("PrincipalBaseId")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_NumberColumn, ownedType.FindProperty("Number")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeArrayColumn, ownedType.FindProperty("RefTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeEnumerableColumn, ownedType.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeIListColumn, ownedType.FindProperty("RefTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeListColumn, ownedType.FindProperty("RefTypeList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeArrayColumn, ownedType.FindProperty("ValueTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeEnumerableColumn, ownedType.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeIListColumn, ownedType.FindProperty("ValueTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeListColumn, ownedType.FindProperty("ValueTypeList")!, principalBaseTableMapping0);
            var detailsTable = new Table("Details", null, relationalModel);
            var principalBaseIdColumn = new Column("PrincipalBaseId", "bigint", detailsTable);
            detailsTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
            var principalBaseAlternateIdColumn = new Column("PrincipalBaseAlternateId", "uniqueidentifier", detailsTable);
            detailsTable.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumn);
            var detailsColumn = new Column("Details", "nvarchar(max)", detailsTable)
            {
                IsNullable = true
            };
            detailsTable.Columns.Add("Details", detailsColumn);
            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
            detailsTable.PrimaryKey = pK_Details;
            var pK_DetailsUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            pK_Details.MappedKeys.Add(pK_DetailsUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsUc).Add(pK_Details);
            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
            relationalModel.Tables.Add(("Details", null), detailsTable);
            var detailsTableMapping = new TableMapping(ownedType, detailsTable, true)
            {
                IsSplitEntityTypePrincipal = false
            };
            detailsTable.AddTypeMapping(detailsTableMapping, false);
            tableMappings3.Add(detailsTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseAlternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, detailsTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn, ownedType.FindProperty("PrincipalBaseId")!, detailsTableMapping);
            RelationalModel.CreateColumnMapping(detailsColumn, ownedType.FindProperty("Details")!, detailsTableMapping);

            var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>")!;

            var defaultTableMappings4 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings4);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0 = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, false);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0, false);
            defaultTableMappings4.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase, principalDerived.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);

            var defaultTableMappings5 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings5);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", null, relationalModel);
            var alternateIdColumnBase0 = new ColumnBase<ColumnMappingBase>("AlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("AlternateId", alternateIdColumnBase0);
            var idColumnBase2 = new ColumnBase<ColumnMappingBase>("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase2);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings5.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase0, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase2, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings4 = new List<TableMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings4);
            var principalBaseTableMapping1 = new TableMapping(principalDerived, principalBaseTable, false)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping1, false);
            tableMappings4.Add(principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalDerived.FindProperty("AlternateId")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(idColumn1, principalDerived.FindProperty("Id")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum1Column, principalDerived.FindProperty("Enum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum2Column, principalDerived.FindProperty("Enum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalDerived.FindProperty("FlagsEnum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalDerived.FindProperty("FlagsEnum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(pointColumn, principalDerived.FindProperty("Point")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalDerived.FindProperty("RefTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalDerived.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalDerived.FindProperty("RefTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalDerived.FindProperty("RefTypeList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalDerived.FindProperty("ValueTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping1);
            var principalDerivedTable = new Table("PrincipalDerived", null, relationalModel);
            var derivedIdColumn = new Column("DerivedId", "bigint", principalDerivedTable);
            principalDerivedTable.Columns.Add("DerivedId", derivedIdColumn);
            var alternateIdColumn0 = new Column("AlternateId", "uniqueidentifier", principalDerivedTable);
            principalDerivedTable.Columns.Add("AlternateId", alternateIdColumn0);
            var aK_PrincipalDerived_DerivedId = new UniqueConstraint("AK_PrincipalDerived_DerivedId", principalDerivedTable, new[] { derivedIdColumn });
            var aK_PrincipalDerived_DerivedIdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalDerived_DerivedId.MappedKeys.Add(aK_PrincipalDerived_DerivedIdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalDerived_DerivedIdUc).Add(aK_PrincipalDerived_DerivedId);
            principalDerivedTable.UniqueConstraints.Add("AK_PrincipalDerived_DerivedId", aK_PrincipalDerived_DerivedId);
            var pK0 = new UniqueConstraint("PK", principalDerivedTable, new[] { derivedIdColumn, alternateIdColumn0 });
            principalDerivedTable.PrimaryKey = pK0;
            var pK0Uc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK0.MappedKeys.Add(pK0Uc);
            RelationalModel.GetOrCreateUniqueConstraints(pK0Uc).Add(pK0);
            principalDerivedTable.UniqueConstraints.Add("PK", pK0);
            var iX_PrincipalDerived_AlternateId_DerivedId = new TableIndex(
            "IX_PrincipalDerived_AlternateId_DerivedId", principalDerivedTable, new[] { alternateIdColumn0, derivedIdColumn }, false);
            var iX_PrincipalDerived_AlternateId_DerivedIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalDerived_AlternateId_DerivedId.MappedIndexes.Add(iX_PrincipalDerived_AlternateId_DerivedIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalDerived_AlternateId_DerivedIdIx).Add(iX_PrincipalDerived_AlternateId_DerivedId);
            principalDerivedTable.Indexes.Add("IX_PrincipalDerived_AlternateId_DerivedId", iX_PrincipalDerived_AlternateId_DerivedId);
            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, true);
            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
            tableMappings4.Add(principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);

            var ownedType0 = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType")!;

            var defaultTableMappings6 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType0.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings6);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", null, relationalModel);
            var detailsColumnBase0 = new ColumnBase<ColumnMappingBase>("Details", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Details", detailsColumnBase0);
            var idColumnBase3 = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Id", idColumnBase3);
            var numberColumnBase0 = new ColumnBase<ColumnMappingBase>("Number", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Number", numberColumnBase0);
            var principalDerivedDependentBasebyteAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>AlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumnBase);
            var principalDerivedDependentBasebyteIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumnBase);
            var refTypeArrayColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase1);
            var refTypeEnumerableColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase1);
            var refTypeIListColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase1);
            var refTypeListColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeList", refTypeListColumnBase1);
            var valueTypeArrayColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase1);
            var valueTypeEnumerableColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase1);
            var valueTypeIListColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase1);
            var valueTypeListColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase1);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType0, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase, false);
            defaultTableMappings6.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase3, ownedType0.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteAlternateIdColumnBase, ownedType0.FindProperty("PrincipalDerivedAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteIdColumnBase, ownedType0.FindProperty("PrincipalDerivedId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)detailsColumnBase0, ownedType0.FindProperty("Details")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)numberColumnBase0, ownedType0.FindProperty("Number")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase1, ownedType0.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase1, ownedType0.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase1, ownedType0.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase1, ownedType0.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase1, ownedType0.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase1, ownedType0.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase1, ownedType0.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase1, ownedType0.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);

            var tableMappings5 = new List<TableMapping>();
            ownedType0.SetRuntimeAnnotation("Relational:TableMappings", tableMappings5);
            var manyOwnedTable = new Table("ManyOwned", null, relationalModel);
            var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "bigint", manyOwnedTable);
            manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
            var principalDerivedDependentBasebyteAlternateIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>AlternateId", "uniqueidentifier", manyOwnedTable);
            manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumn);
            var idColumn2 = new Column("Id", "int", manyOwnedTable);
            manyOwnedTable.Columns.Add("Id", idColumn2);
            var detailsColumn0 = new Column("Details", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("Details", detailsColumn0);
            var numberColumn = new Column("Number", "int", manyOwnedTable);
            manyOwnedTable.Columns.Add("Number", numberColumn);
            var refTypeArrayColumn0 = new Column("RefTypeArray", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
            var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
            var refTypeIListColumn0 = new Column("RefTypeIList", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
            var refTypeListColumn0 = new Column("RefTypeList", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeList", refTypeListColumn0);
            var valueTypeArrayColumn0 = new Column("ValueTypeArray", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
            var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
            var valueTypeIListColumn0 = new Column("ValueTypeIList", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
            var valueTypeListColumn0 = new Column("ValueTypeList", "nvarchar(max)", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn2 });
            manyOwnedTable.PrimaryKey = pK_ManyOwned;
            var pK_ManyOwnedUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedUc).Add(pK_ManyOwned);
            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
            relationalModel.Tables.Add(("ManyOwned", null), manyOwnedTable);
            var manyOwnedTableMapping = new TableMapping(ownedType0, manyOwnedTable, true);
            manyOwnedTable.AddTypeMapping(manyOwnedTableMapping, false);
            tableMappings5.Add(manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(idColumn2, ownedType0.FindProperty("Id")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteAlternateIdColumn, ownedType0.FindProperty("PrincipalDerivedAlternateId")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn, ownedType0.FindProperty("PrincipalDerivedId")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(detailsColumn0, ownedType0.FindProperty("Details")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(numberColumn, ownedType0.FindProperty("Number")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn0, ownedType0.FindProperty("RefTypeArray")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn0, ownedType0.FindProperty("RefTypeEnumerable")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn0, ownedType0.FindProperty("RefTypeIList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn0, ownedType0.FindProperty("RefTypeList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn0, ownedType0.FindProperty("ValueTypeArray")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, ownedType0.FindProperty("ValueTypeEnumerable")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn0, ownedType0.FindProperty("ValueTypeIList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn0, ownedType0.FindProperty("ValueTypeList")!, manyOwnedTableMapping);

            var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;

            var defaultTableMappings7 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings7);
            var principalBasePrincipalDerivedDependentBasebyteTableBase = new TableBase("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumnBase);
            var derivedsIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsId", derivedsIdColumnBase);
            var principalsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumnBase);
            var principalsIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsId", principalsIdColumnBase);
            var rowidColumnBase = new ColumnBase<ColumnMappingBase>("rowid", "rowversion", principalBasePrincipalDerivedDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("rowid", rowidColumnBase);
            relationalModel.DefaultTables.Add("PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTableBase);
            var principalBasePrincipalDerivedDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTableBase, true);
            principalBasePrincipalDerivedDependentBasebyteTableBase.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteMappingBase, false);
            defaultTableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)rowidColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);

            var tableMappings6 = new List<TableMapping>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:TableMappings", tableMappings6);
            var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsIdColumn = new Column("DerivedsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
            var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
            var principalsIdColumn = new Column("PrincipalsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
            var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
            var rowidColumn = new Column("rowid", "rowversion", principalBasePrincipalDerivedDependentBasebyteTable)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
            var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
            principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
            var pK_PrincipalBasePrincipalDerivedDependentBasebyteUc = RelationalModel.GetKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
            pK_PrincipalBasePrincipalDerivedDependentBasebyte.MappedKeys.Add(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc).Add(pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
            "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" });
            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, true);
            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
            tableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                new[] { principalIdColumn },
                principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
            var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            fK_DependentBasebyte_PrincipalBase_PrincipalId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk).Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalDerivedTable,
                new[] { principalIdColumn, principalAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk).Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId = new ForeignKeyConstraint(
                "FK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId", detailsTable, principalBaseTable,
                new[] { principalBaseIdColumn, principalBaseAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId.MappedForeignKeys.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk).Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            detailsTable.ForeignKeyConstraints.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId = new ForeignKeyConstraint(
                "FK_ManyOwned_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id_PrincipalDerived<DependentBase<byte?>>AlternateId", manyOwnedTable, principalDerivedTable,
                new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId.MappedForeignKeys.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk).Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            manyOwnedTable.ForeignKeyConstraints.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                new[] { principalsIdColumn, principalsAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalDerived_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalDerivedTable,
                new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId = new ForeignKeyConstraint(
                "FK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId", principalDerivedTable, principalBaseTable,
                new[] { derivedIdColumn, alternateIdColumn0 },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId.MappedForeignKeys.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk).Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            principalDerivedTable.ForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.One);

            var principalId = runtimeEntityType.AddProperty(
                "PrincipalId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalAlternateId = runtimeEntityType.AddProperty(
                "PrincipalAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumDiscriminator = runtimeEntityType.AddProperty(
                "EnumDiscriminator",
                typeof(CSharpMigrationsGeneratorTest.Enum1),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create,
                sentinel: CSharpMigrationsGeneratorTest.Enum1.Default);
            enumDiscriminator.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                keyComparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                    (int value) => (CSharpMigrationsGeneratorTest.Enum1)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                        (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                        (int value) => (CSharpMigrationsGeneratorTest.Enum1)value)));
            enumDiscriminator.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            id.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { principalId, principalAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId"), declaringEntityType.FindProperty("PrincipalAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientNoAction,
                unique: true,
                required: true);

            var principal = declaringEntityType.AddNavigation("Principal",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation("Dependent",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Dependent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Dependent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("DiscriminatorMappingComplete", false);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "ManyTypesEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class ManyTypesEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var @bool = runtimeEntityType.AddProperty(
                "Bool",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            @bool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v));
            @bool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolArray = runtimeEntityType.AddProperty(
                "BoolArray",
                typeof(bool[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            boolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                keyComparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v)));
            boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytes = runtimeEntityType.AddProperty(
                "Bytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            bytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytesArray = runtimeEntityType.AddProperty(
                "BytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @char = runtimeEntityType.AddProperty(
                "Char",
                typeof(char),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: ' ');
            @char.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            @char.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var charArray = runtimeEntityType.AddProperty(
                "CharArray",
                typeof(char[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            charArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                keyComparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionReaderWriter<char[], char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0])))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<char[], char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0]),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))));
            charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnly = runtimeEntityType.AddProperty(
                "DateOnly",
                typeof(DateOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v));
            dateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnlyArray = runtimeEntityType.AddProperty(
                "DateOnlyArray",
                typeof(DateOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                keyComparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v)));
            dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTime = runtimeEntityType.AddProperty(
                "DateTime",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v));
            dateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeArray = runtimeEntityType.AddProperty(
                "DateTimeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @decimal = runtimeEntityType.AddProperty(
                "Decimal",
                typeof(decimal),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0m);
            @decimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v));
            @decimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalArray = runtimeEntityType.AddProperty(
                "DecimalArray",
                typeof(decimal[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            decimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                keyComparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v)));
            decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @double = runtimeEntityType.AddProperty(
                "Double",
                typeof(double),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0.0);
            @double.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v));
            @double.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleArray = runtimeEntityType.AddProperty(
                "DoubleArray",
                typeof(double[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            doubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                keyComparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v)));
            doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @float = runtimeEntityType.AddProperty(
                "Float",
                typeof(float),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0f);
            @float.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v));
            @float.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var floatArray = runtimeEntityType.AddProperty(
                "FloatArray",
                typeof(float[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            floatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                keyComparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v)));
            floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guid = runtimeEntityType.AddProperty(
                "Guid",
                typeof(Guid),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            guid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            guid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidArray = runtimeEntityType.AddProperty(
                "GuidArray",
                typeof(Guid[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            guidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                keyComparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddress = runtimeEntityType.AddProperty(
                "IPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            iPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressArray = runtimeEntityType.AddProperty(
                "IPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16 = runtimeEntityType.AddProperty(
                "Int16",
                typeof(short),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (short)0);
            int16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                keyComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v));
            int16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16Array = runtimeEntityType.AddProperty(
                "Int16Array",
                typeof(short[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32 = runtimeEntityType.AddProperty(
                "Int32",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            int32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            int32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32Array = runtimeEntityType.AddProperty(
                "Int32Array",
                typeof(int[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                keyComparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v)));
            int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64 = runtimeEntityType.AddProperty(
                "Int64",
                typeof(long),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0L);
            int64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            int64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64Array = runtimeEntityType.AddProperty(
                "Int64Array",
                typeof(long[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                keyComparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v)));
            int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8 = runtimeEntityType.AddProperty(
                "Int8",
                typeof(sbyte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (sbyte)0);
            int8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    (sbyte v) => (short)v,
                    (short v) => (sbyte)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v)));
            int8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8Array = runtimeEntityType.AddProperty(
                "Int8Array",
                typeof(sbyte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                keyComparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))));
            int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBool = runtimeEntityType.AddProperty(
                "NullableBool",
                typeof(bool?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)));
            nullableBool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBoolArray = runtimeEntityType.AddProperty(
                "NullableBoolArray",
                typeof(bool?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBoolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                keyComparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool?>(new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v)));
            nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytes = runtimeEntityType.AddProperty(
                "NullableBytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            nullableBytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytesArray = runtimeEntityType.AddProperty(
                "NullableBytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableChar = runtimeEntityType.AddProperty(
                "NullableChar",
                typeof(char?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableChar.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                keyComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            nullableChar.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableCharArray = runtimeEntityType.AddProperty(
                "NullableCharArray",
                typeof(char?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableCharArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                keyComparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char?>(new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0])))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0]),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))));
            nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnly = runtimeEntityType.AddProperty(
                "NullableDateOnly",
                typeof(DateOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)),
                keyComparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)),
                providerValueComparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)));
            nullableDateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                "NullableDateOnlyArray",
                typeof(DateOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                keyComparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v)));
            nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTime = runtimeEntityType.AddProperty(
                "NullableDateTime",
                typeof(DateTime?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)),
                keyComparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)),
                providerValueComparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)));
            nullableDateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTimeArray = runtimeEntityType.AddProperty(
                "NullableDateTimeArray",
                typeof(DateTime?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                keyComparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimal = runtimeEntityType.AddProperty(
                "NullableDecimal",
                typeof(decimal?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)),
                keyComparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)),
                providerValueComparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)));
            nullableDecimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimalArray = runtimeEntityType.AddProperty(
                "NullableDecimalArray",
                typeof(decimal?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                keyComparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal?>(new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v)));
            nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDouble = runtimeEntityType.AddProperty(
                "NullableDouble",
                typeof(double?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDouble.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            nullableDouble.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDoubleArray = runtimeEntityType.AddProperty(
                "NullableDoubleArray",
                typeof(double?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDoubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                keyComparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double?>(new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v)));
            nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloat = runtimeEntityType.AddProperty(
                "NullableFloat",
                typeof(float?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloat.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            nullableFloat.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloatArray = runtimeEntityType.AddProperty(
                "NullableFloatArray",
                typeof(float?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                keyComparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float?>(new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v)));
            nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuid = runtimeEntityType.AddProperty(
                "NullableGuid",
                typeof(Guid?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                keyComparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                providerValueComparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            nullableGuid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuidArray = runtimeEntityType.AddProperty(
                "NullableGuidArray",
                typeof(Guid?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                keyComparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid?>(new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddress = runtimeEntityType.AddProperty(
                "NullableIPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            nullableIPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddressArray = runtimeEntityType.AddProperty(
                "NullableIPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16 = runtimeEntityType.AddProperty(
                "NullableInt16",
                typeof(short?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                keyComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                providerValueComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)));
            nullableInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16Array = runtimeEntityType.AddProperty(
                "NullableInt16Array",
                typeof(short?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                keyComparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short?>(new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32 = runtimeEntityType.AddProperty(
                "NullableInt32",
                typeof(int?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            nullableInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32Array = runtimeEntityType.AddProperty(
                "NullableInt32Array",
                typeof(int?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                keyComparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int?>(new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v)));
            nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64 = runtimeEntityType.AddProperty(
                "NullableInt64",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            nullableInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64Array = runtimeEntityType.AddProperty(
                "NullableInt64Array",
                typeof(long?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                keyComparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long?>(new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v)));
            nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8 = runtimeEntityType.AddProperty(
                "NullableInt8",
                typeof(sbyte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                keyComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    (sbyte v) => (short)v,
                    (short v) => (sbyte)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v)));
            nullableInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8Array = runtimeEntityType.AddProperty(
                "NullableInt8Array",
                typeof(sbyte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                keyComparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))));
            nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                "NullablePhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            nullablePhysicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                "NullablePhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));
            nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableString = runtimeEntityType.AddProperty(
                "NullableString",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            nullableString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableStringArray = runtimeEntityType.AddProperty(
                "NullableStringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnly = runtimeEntityType.AddProperty(
                "NullableTimeOnly",
                typeof(TimeOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)),
                keyComparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)),
                providerValueComparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)));
            nullableTimeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                "NullableTimeOnlyArray",
                typeof(TimeOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                keyComparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v)));
            nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpan = runtimeEntityType.AddProperty(
                "NullableTimeSpan",
                typeof(TimeSpan?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                keyComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                providerValueComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)));
            nullableTimeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                "NullableTimeSpanArray",
                typeof(TimeSpan?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                keyComparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v)));
            nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16 = runtimeEntityType.AddProperty(
                "NullableUInt16",
                typeof(ushort?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                keyComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    (ushort v) => (int)v,
                    (int v) => (ushort)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v)));
            nullableUInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16Array = runtimeEntityType.AddProperty(
                "NullableUInt16Array",
                typeof(ushort?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                keyComparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort?>(new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))));
            nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32 = runtimeEntityType.AddProperty(
                "NullableUInt32",
                typeof(uint?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<uint, long>(
                    (uint v) => (long)v,
                    (long v) => (uint)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v)));
            nullableUInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32Array = runtimeEntityType.AddProperty(
                "NullableUInt32Array",
                typeof(uint?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                keyComparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint?>(new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))));
            nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64 = runtimeEntityType.AddProperty(
                "NullableUInt64",
                typeof(ulong?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>)),
                keyComparer: new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>)),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    (ulong v) => (decimal)v,
                    (decimal v) => (ulong)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v)));
            nullableUInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64Array = runtimeEntityType.AddProperty(
                "NullableUInt64Array",
                typeof(ulong?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                keyComparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong?>(new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))));
            nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8 = runtimeEntityType.AddProperty(
                "NullableUInt8",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)));
            nullableUInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8Array = runtimeEntityType.AddProperty(
                "NullableUInt8Array",
                typeof(byte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                keyComparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte?>(new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUri = runtimeEntityType.AddProperty(
                "NullableUri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            nullableUri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUriArray = runtimeEntityType.AddProperty(
                "NullableUriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddress = runtimeEntityType.AddProperty(
                "PhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            physicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressArray = runtimeEntityType.AddProperty(
                "PhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));
            physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @string = runtimeEntityType.AddProperty(
                "String",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            @string.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            @string.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringArray = runtimeEntityType.AddProperty(
                "StringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnly = runtimeEntityType.AddProperty(
                "TimeOnly",
                typeof(TimeOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeOnly(0, 0, 0));
            timeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v));
            timeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyArray = runtimeEntityType.AddProperty(
                "TimeOnlyArray",
                typeof(TimeOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                keyComparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v)));
            timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpan = runtimeEntityType.AddProperty(
                "TimeSpan",
                typeof(TimeSpan),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeSpan(0, 0, 0, 0, 0));
            timeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v));
            timeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanArray = runtimeEntityType.AddProperty(
                "TimeSpanArray",
                typeof(TimeSpan[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                keyComparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v)));
            timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16 = runtimeEntityType.AddProperty(
                "UInt16",
                typeof(ushort),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            uInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    (ushort v) => (int)v,
                    (int v) => (ushort)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v)));
            uInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16Array = runtimeEntityType.AddProperty(
                "UInt16Array",
                typeof(ushort[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                keyComparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))));
            uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32 = runtimeEntityType.AddProperty(
                "UInt32",
                typeof(uint),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            uInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<uint, long>(
                    (uint v) => (long)v,
                    (long v) => (uint)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v)));
            uInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32Array = runtimeEntityType.AddProperty(
                "UInt32Array",
                typeof(uint[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                keyComparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))));
            uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64 = runtimeEntityType.AddProperty(
                "UInt64",
                typeof(ulong),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0ul);
            uInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    (ulong v) => (decimal)v,
                    (decimal v) => (ulong)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v)));
            uInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64Array = runtimeEntityType.AddProperty(
                "UInt64Array",
                typeof(ulong[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                keyComparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))));
            uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8 = runtimeEntityType.AddProperty(
                "UInt8",
                typeof(byte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (byte)0);
            uInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v));
            uInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8Array = runtimeEntityType.AddProperty(
                "UInt8Array",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt8Array.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            uInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uri = runtimeEntityType.AddProperty(
                "Uri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            uri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uriArray = runtimeEntityType.AddProperty(
                "UriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyTypes");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorValue: "PrincipalBase");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var idPrincipalDerived = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.Table("PrincipalDerived", null),
                true,
                "DerivedId");
            overrides.Add(StoreObjectIdentifier.Table("PrincipalDerived", null), idPrincipalDerived);
            id.AddAnnotation("Relational:RelationalOverrides", overrides);

            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var alternateId = runtimeEntityType.AddProperty(
                "AlternateId",
                typeof(Guid),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"),
                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
            alternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            alternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AnEnum)0);
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)6);
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var point = runtimeEntityType.AddProperty(
                "Point",
                typeof(Point),
                nullable: true,
                valueGenerated: ValueGenerated.OnAdd,
                valueConverter: new CastingConverter<Point, Point>(),
                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>(),
                providerValueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
            point.TypeMapping = null;
            point.AddAnnotation("Relational:ColumnType", "geometry");
            point.AddAnnotation("Relational:DefaultValue", (NetTopologySuite.Geometries.Point)new NetTopologySuite.IO.WKTReader().Read("SRID=0;POINT Z(0 0 0)"));
            point.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });

            var key0 = runtimeEntityType.AddKey(
                new[] { id, alternateId });
            runtimeEntityType.SetPrimaryKey(key0);
            key0.AddAnnotation("Relational:Name", "PK");

            var index = runtimeEntityType.AddIndex(
                new[] { alternateId, id });

            return runtimeEntityType;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Deriveds",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("PrincipalsId"), joinEntityType.FindProperty("PrincipalsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var inverse = targetEntityType.FindSkipNavigation("Principals");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPT");
            runtimeEntityType.AddAnnotation("Relational:Schema", "mySchema");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedTypeEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class OwnedTypeEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true,
                changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long),
                propertyAccessMode: PropertyAccessMode.Field,
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalBaseId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var principalBaseIdPrincipalBase = new RuntimeRelationalPropertyOverrides(
                principalBaseId,
                StoreObjectIdentifier.Table("PrincipalBase", "mySchema"),
                false,
                null);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            overrides.Add(StoreObjectIdentifier.Table("PrincipalBase", "mySchema"), principalBaseIdPrincipalBase);
            principalBaseId.AddAnnotation("Relational:RelationalOverrides", overrides);

            principalBaseId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var principalBaseAlternateId = runtimeEntityType.AddProperty(
                "PrincipalBaseAlternateId",
                typeof(Guid),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalBaseAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalBaseAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            details.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);

            var overrides0 = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var detailsDetails = new RuntimeRelationalPropertyOverrides(
                details,
                StoreObjectIdentifier.Table("Details", null),
                false,
                null);
            overrides0.Add(StoreObjectIdentifier.Table("Details", null), detailsDetails);
            details.AddAnnotation("Relational:RelationalOverrides", overrides0);

            details.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            number.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalBaseId, principalBaseAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true,
                ownership: true);

            var owned = principalEntityType.AddNavigation("Owned",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("PrincipalBaseId"), principalEntityType.FindProperty("PrincipalBaseAlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var fragments = new StoreObjectDictionary<RuntimeEntityTypeMappingFragment>();
            var detailsFragment = new RuntimeEntityTypeMappingFragment(
                runtimeEntityType,
                StoreObjectIdentifier.Table("Details", null),
                null);
            fragments.Add(StoreObjectIdentifier.Table("Details", null), detailsFragment);
            runtimeEntityType.AddAnnotation("Relational:MappingFragments", fragments);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", "mySchema");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedType0EntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class OwnedType0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true);

            var principalDerivedId = runtimeEntityType.AddProperty(
                "PrincipalDerivedId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalDerivedId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalDerivedId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                "PrincipalDerivedAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalDerivedAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalDerivedAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            details.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            details.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            number.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalDerivedId, principalDerivedAlternateId, id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalDerivedId"), declaringEntityType.FindProperty("PrincipalDerivedAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var manyOwned = principalEntityType.AddNavigation("ManyOwned",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.OwnedType>),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("ManyOwned", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyOwned");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);
            runtimeEntityType.AddAnnotation("SqlServer:MemoryOptimized", true);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBasePrincipalDerivedDependentBasebyteEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var derivedsId = runtimeEntityType.AddProperty(
                "DerivedsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            derivedsId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var derivedsAlternateId = runtimeEntityType.AddProperty(
                "DerivedsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            derivedsAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalsId = runtimeEntityType.AddProperty(
                "PrincipalsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalsId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalsAlternateId = runtimeEntityType.AddProperty(
                "PrincipalsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalsAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var rowid = runtimeEntityType.AddProperty(
                "rowid",
                typeof(byte[]),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            rowid.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(v1, v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(v),
                    (Byte[] v) => v.ToArray()),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "rowversion",
                    size: 8),
                storeTypePostfix: StoreTypePostfix.None);
            rowid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalsId, principalsAlternateId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("DerivedsId"), declaringEntityType.FindProperty("DerivedsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalsId"), declaringEntityType.FindProperty("PrincipalsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientCascade,
                required: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBasePrincipalDerived<DependentBase<byte?>>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""",  c),
                    c => AssertFileContents(
                        "DependentDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DependentDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.Two);

            var data = runtimeEntityType.AddProperty(
                "Data",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetProperty("Data", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetField("<Data>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 20,
                unicode: false);
            data.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "char(20)",
                    size: 20,
                    dbType: System.Data.DbType.AnsiStringFixedLength));
            data.AddAnnotation("Relational:IsFixedLength", true);
            data.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var money = runtimeEntityType.AddProperty(
                "Money",
                typeof(decimal),
                precision: 9,
                scale: 3,
                sentinel: 0m);
            money.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(9,3)",
                    precision: 9,
                    scale: 3));
            money.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorValue: "PrincipalDerived<DependentBase<byte?>>");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Principals",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("DerivedsId"), joinEntityType.FindProperty("DerivedsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Principals", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Principals>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            var inverse = targetEntityType.FindSkipNavigation("Deriveds");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalDerived");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetCollation()).Message);
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.MaxIdentifierLength, SqlServerAnnotationNames.ValueGenerationStrategy },
                        model.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, model.GetValueGenerationStrategy());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPropertyAccessMode()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.IdentitySeed]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetIdentitySeed()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.IdentityIncrement]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetIdentityIncrement()).Message);

                    var manyTypesType = model.FindEntityType(typeof(ManyTypes));

                    Assert.Equal(typeof(ManyTypes).FullName, manyTypesType.Name);
                    Assert.False(manyTypesType.HasSharedClrType);
                    Assert.False(manyTypesType.IsPropertyBag);
                    Assert.False(manyTypesType.IsOwned());
                    Assert.IsType<ConstructorBinding>(manyTypesType.ConstructorBinding);
                    Assert.Null(manyTypesType.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, manyTypesType.GetChangeTrackingStrategy());
                    Assert.Equal("ManyTypes", manyTypesType.GetTableName());
                    Assert.Null(manyTypesType.GetSchema());

                    Assert.Null(model.FindEntityType(typeof(AbstractBase)));
                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    Assert.Equal(typeof(PrincipalBase).FullName, principalBase.Name);
                    Assert.False(principalBase.HasSharedClrType);
                    Assert.False(principalBase.IsPropertyBag);
                    Assert.False(principalBase.IsOwned());
                    Assert.Null(principalBase.BaseType);
                    Assert.IsType<ConstructorBinding>(principalBase.ConstructorBinding);
                    Assert.Null(principalBase.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalBase.GetChangeTrackingStrategy());
                    Assert.Null(principalBase.GetQueryFilter());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Equal("mySchema", principalBase.GetSchema());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalBase.GetSeedData()).Message);

                    var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id));
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.RelationalOverrides, SqlServerAnnotationNames.ValueGenerationStrategy },
                        principalId.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(long?), principalId.ClrType);
                    Assert.Equal(typeof(long?), principalId.PropertyInfo.PropertyType);
                    Assert.Equal(typeof(long?), principalId.FieldInfo.FieldType);
                    Assert.False(principalId.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, principalId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, principalId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, principalId.GetBeforeSaveBehavior());
                    Assert.Null(principalId[CoreAnnotationNames.BeforeSaveBehavior]);
                    Assert.Null(principalId[CoreAnnotationNames.AfterSaveBehavior]);
                    Assert.Equal("Id", principalId.GetColumnName());
                    Assert.Equal("Id", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalBase", "mySchema")));
                    Assert.Equal("DerivedId", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalDerived")));
                    Assert.Equal("bigint", principalId.GetColumnType());
                    Assert.Null(principalId.GetValueConverter());
                    Assert.NotNull(principalId.GetValueComparer());
                    Assert.NotNull(principalId.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, principalId.GetValueGenerationStrategy());
                    Assert.Null(principalId[SqlServerAnnotationNames.IdentitySeed]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed()).Message);
                    Assert.Null(principalId[SqlServerAnnotationNames.IdentityIncrement]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement()).Message);

                    var pointProperty = principalBase.FindProperty("Point");
                    Assert.Equal(typeof(Point), pointProperty.ClrType);
                    Assert.True(pointProperty.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, pointProperty.ValueGenerated);
                    Assert.Equal("Point", pointProperty.GetColumnName());
                    Assert.Equal("geometry", pointProperty.GetColumnType());
                    Assert.Equal(0, ((Point)pointProperty.GetDefaultValue()).SRID);
                    Assert.IsType<CastingConverter<Point, Point>>(pointProperty.GetValueConverter());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetKeyValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetProviderValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, pointProperty.GetValueGenerationStrategy());
                    Assert.Null(pointProperty[CoreAnnotationNames.PropertyAccessMode]);

                    Assert.Null(principalBase.FindDiscriminatorProperty());

                    var principalAlternateId = principalBase.FindProperty(nameof(PrincipalBase.AlternateId));
                    var compositeIndex = principalBase.GetIndexes().Single();
                    Assert.Equal(PropertyAccessMode.FieldDuringConstruction, principalAlternateId.GetPropertyAccessMode());
                    Assert.Empty(compositeIndex.GetAnnotations());
                    Assert.Equal(new[] { principalAlternateId, principalId }, compositeIndex.Properties);
                    Assert.False(compositeIndex.IsUnique);
                    Assert.Null(compositeIndex.Name);
                    Assert.Equal("IX_PrincipalBase_AlternateId_Id", compositeIndex.GetDatabaseName());

                    Assert.Equal(new[] { compositeIndex }, principalAlternateId.GetContainingIndexes());

                    Assert.Equal(2, principalBase.GetKeys().Count());

                    var principalAlternateKey = principalBase.GetKeys().First();
                    Assert.Same(principalId, principalAlternateKey.Properties.Single());
                    Assert.False(principalAlternateKey.IsPrimaryKey());
                    Assert.Equal("AK_PrincipalBase_Id", principalAlternateKey.GetName());

                    var principalKey = principalBase.GetKeys().Last();
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.Name },
                        principalKey.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(new[] { principalId, principalAlternateId }, principalKey.Properties);
                    Assert.True(principalKey.IsPrimaryKey());
                    Assert.Equal("PK", principalKey.GetName());
                    Assert.Null(principalKey[SqlServerAnnotationNames.Clustered]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalKey.IsClustered()).Message);

                    Assert.Equal(new[] { principalAlternateKey, principalKey }, principalId.GetContainingKeys());

                    var referenceOwnedNavigation = principalBase.GetNavigations().Single();
                    Assert.Equal(
                        new[] { CoreAnnotationNames.EagerLoaded },
                        referenceOwnedNavigation.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.Name);
                    Assert.False(referenceOwnedNavigation.IsCollection);
                    Assert.True(referenceOwnedNavigation.IsEagerLoaded);
                    Assert.False(referenceOwnedNavigation.IsOnDependent);
                    Assert.Equal(typeof(OwnedType), referenceOwnedNavigation.ClrType);
                    Assert.Equal("_ownedField", referenceOwnedNavigation.FieldInfo.Name);
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.PropertyInfo.Name);
                    Assert.Null(referenceOwnedNavigation.Inverse);
                    Assert.Equal(principalBase, referenceOwnedNavigation.DeclaringEntityType);
                    Assert.Equal(PropertyAccessMode.Field, referenceOwnedNavigation.GetPropertyAccessMode());
                    Assert.Null(referenceOwnedNavigation[CoreAnnotationNames.PropertyAccessMode]);

                    var referenceOwnedType = referenceOwnedNavigation.TargetEntityType;
                    Assert.Equal(typeof(PrincipalBase).FullName + ".Owned#OwnedType", referenceOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), referenceOwnedType.ClrType);
                    Assert.True(referenceOwnedType.HasSharedClrType);
                    Assert.False(referenceOwnedType.IsPropertyBag);
                    Assert.True(referenceOwnedType.IsOwned());
                    Assert.Null(referenceOwnedType.BaseType);
                    Assert.False(referenceOwnedType.IsMemoryOptimized());
                    Assert.IsType<ConstructorBinding>(referenceOwnedType.ConstructorBinding);
                    Assert.Null(referenceOwnedType.FindIndexerPropertyInfo());
                    Assert.Equal(
                        ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                        referenceOwnedType.GetChangeTrackingStrategy());
                    Assert.Null(referenceOwnedType.GetQueryFilter());
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.PropertyAccessMode]);
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.NavigationAccessMode]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetPropertyAccessMode()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetNavigationAccessMode()).Message);

                    var principalTable = StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value;

                    var ownedId = referenceOwnedType.FindProperty("PrincipalBaseId");
                    Assert.True(ownedId.IsPrimaryKey());
                    Assert.Equal(
                        SqlServerValueGenerationStrategy.IdentityColumn,
                        principalId.GetValueGenerationStrategy(principalTable));
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement(principalTable)).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed(principalTable)).Message);

                    var detailsProperty = referenceOwnedType.FindProperty(nameof(OwnedType.Details));
                    Assert.Null(detailsProperty[SqlServerAnnotationNames.Sparse]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.IsSparse()).Message);
                    Assert.Null(detailsProperty[RelationalAnnotationNames.Collation]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetCollation()).Message);

                    var ownedFragment = referenceOwnedType.GetMappingFragments().Single();
                    Assert.Equal(nameof(OwnedType.Details), detailsProperty.GetColumnName(ownedFragment.StoreObject));
                    Assert.Null(detailsProperty.GetColumnName(principalTable));

                    var referenceOwnership = referenceOwnedNavigation.ForeignKey;
                    Assert.Empty(referenceOwnership.GetAnnotations());
                    Assert.Same(referenceOwnership, referenceOwnedType.FindOwnership());
                    Assert.True(referenceOwnership.IsOwnership);
                    Assert.True(referenceOwnership.IsRequired);
                    Assert.True(referenceOwnership.IsRequiredDependent);
                    Assert.True(referenceOwnership.IsUnique);
                    Assert.Null(referenceOwnership.DependentToPrincipal);
                    Assert.Same(referenceOwnedNavigation, referenceOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, referenceOwnership.DeleteBehavior);
                    Assert.Equal(2, referenceOwnership.Properties.Count());
                    Assert.Same(principalKey, referenceOwnership.PrincipalKey);

                    var ownedServiceProperty = referenceOwnedType.GetServiceProperties().Single();
                    Assert.Empty(ownedServiceProperty.GetAnnotations());
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.ClrType);
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.PropertyInfo.PropertyType);
                    Assert.Null(ownedServiceProperty.FieldInfo);
                    Assert.Same(referenceOwnedType, ownedServiceProperty.DeclaringEntityType);
                    var ownedServicePropertyBinding = ownedServiceProperty.ParameterBinding;
                    Assert.IsType<ContextParameterBinding>(ownedServicePropertyBinding);
                    Assert.Equal(typeof(DbContext), ownedServicePropertyBinding.ServiceType);
                    Assert.Equal(ownedServiceProperty, ownedServicePropertyBinding.ConsumedProperties.Single());
                    Assert.Equal(PropertyAccessMode.PreferField, ownedServiceProperty.GetPropertyAccessMode());
                    Assert.Null(ownedServiceProperty[CoreAnnotationNames.PropertyAccessMode]);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);
                    Assert.Equal(
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+"
                        + "PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                        principalDerived.Name);
                    Assert.False(principalDerived.IsOwned());
                    Assert.IsType<ConstructorBinding>(principalDerived.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalDerived.GetChangeTrackingStrategy());
                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());

                    var tptForeignKey = principalDerived.GetForeignKeys().Single();
                    Assert.False(tptForeignKey.IsOwnership);
                    Assert.True(tptForeignKey.IsRequired);
                    Assert.False(tptForeignKey.IsRequiredDependent);
                    Assert.True(tptForeignKey.IsUnique);
                    Assert.Null(tptForeignKey.DependentToPrincipal);
                    Assert.Null(tptForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, tptForeignKey.DeleteBehavior);
                    Assert.Equal(principalKey.Properties, tptForeignKey.Properties);
                    Assert.Same(principalKey, tptForeignKey.PrincipalKey);

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.True(dependentNavigation.IsEagerLoaded);
                    Assert.False(dependentNavigation.LazyLoadingEnabled);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var ownedCollectionNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.Name);
                    Assert.Null(ownedCollectionNavigation.PropertyInfo);
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<OwnedType>), ownedCollectionNavigation.ClrType);
                    Assert.True(ownedCollectionNavigation.IsCollection);
                    Assert.True(ownedCollectionNavigation.IsEagerLoaded);
                    Assert.False(ownedCollectionNavigation.IsOnDependent);
                    Assert.Null(ownedCollectionNavigation.Inverse);
                    Assert.Equal(principalDerived, ownedCollectionNavigation.DeclaringEntityType);

                    var collectionOwnedType = ownedCollectionNavigation.TargetEntityType;
                    Assert.Equal(principalDerived.Name + ".ManyOwned#OwnedType", collectionOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), collectionOwnedType.ClrType);
                    Assert.True(collectionOwnedType.HasSharedClrType);
                    Assert.False(collectionOwnedType.IsPropertyBag);
                    Assert.True(collectionOwnedType.IsOwned());
                    Assert.True(collectionOwnedType.IsMemoryOptimized());
                    Assert.Null(collectionOwnedType[RelationalAnnotationNames.IsTableExcludedFromMigrations]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => collectionOwnedType.IsTableExcludedFromMigrations()).Message);
                    Assert.Null(collectionOwnedType.BaseType);
                    Assert.IsType<ConstructorBinding>(collectionOwnedType.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, collectionOwnedType.GetChangeTrackingStrategy());

                    var collectionOwnership = ownedCollectionNavigation.ForeignKey;
                    Assert.Same(collectionOwnership, collectionOwnedType.FindOwnership());
                    Assert.True(collectionOwnership.IsOwnership);
                    Assert.True(collectionOwnership.IsRequired);
                    Assert.False(collectionOwnership.IsRequiredDependent);
                    Assert.False(collectionOwnership.IsUnique);
                    Assert.Null(collectionOwnership.DependentToPrincipal);
                    Assert.Same(ownedCollectionNavigation, collectionOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, collectionOwnership.DeleteBehavior);
                    Assert.Equal(2, collectionOwnership.Properties.Count());

                    var derivedSkipNavigation = principalDerived.GetDeclaredSkipNavigations().Single();
                    Assert.Equal("Principals", derivedSkipNavigation.Name);
                    Assert.Equal("Principals", derivedSkipNavigation.PropertyInfo.Name);
                    Assert.Equal("<Principals>k__BackingField", derivedSkipNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<PrincipalBase>), derivedSkipNavigation.ClrType);
                    Assert.True(derivedSkipNavigation.IsCollection);
                    Assert.True(derivedSkipNavigation.IsEagerLoaded);
                    Assert.False(derivedSkipNavigation.LazyLoadingEnabled);
                    Assert.False(derivedSkipNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, derivedSkipNavigation.DeclaringEntityType);
                    Assert.Equal("Deriveds", derivedSkipNavigation.Inverse.Name);
                    Assert.Same(principalBase.GetSkipNavigations().Single(), derivedSkipNavigation.Inverse);

                    Assert.Same(derivedSkipNavigation, derivedSkipNavigation.ForeignKey.GetReferencingSkipNavigations().Single());
                    Assert.Same(
                        derivedSkipNavigation.Inverse, derivedSkipNavigation.Inverse.ForeignKey.GetReferencingSkipNavigations().Single());

                    Assert.Equal(new[] { derivedSkipNavigation.Inverse, derivedSkipNavigation }, principalDerived.GetSkipNavigations());

                    var joinType = derivedSkipNavigation.JoinEntityType;

                    Assert.Equal("PrincipalBasePrincipalDerived<DependentBase<byte?>>", joinType.Name);
                    Assert.Equal(typeof(Dictionary<string, object>), joinType.ClrType);
                    Assert.True(joinType.HasSharedClrType);
                    Assert.True(joinType.IsPropertyBag);
                    Assert.False(joinType.IsOwned());
                    Assert.Null(joinType.BaseType);
                    Assert.IsType<ConstructorBinding>(joinType.ConstructorBinding);
                    Assert.Equal("Item", joinType.FindIndexerPropertyInfo().Name);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, joinType.GetChangeTrackingStrategy());
                    Assert.Null(joinType[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => joinType.GetComment()).Message);
                    Assert.Null(joinType.GetQueryFilter());

                    var rowid = joinType.GetProperties().Single(p => !p.IsForeignKey());
                    Assert.Equal(typeof(byte[]), rowid.ClrType);
                    Assert.True(rowid.IsIndexerProperty());
                    Assert.Same(joinType.FindIndexerPropertyInfo(), rowid.PropertyInfo);
                    Assert.Null(rowid.FieldInfo);
                    Assert.True(rowid.IsNullable);
                    Assert.False(rowid.IsShadowProperty());
                    Assert.True(rowid.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, rowid.ValueGenerated);
                    Assert.Equal("rowid", rowid.GetColumnName());
                    Assert.Equal("rowversion", rowid.GetColumnType());
                    Assert.Null(rowid[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetComment()).Message);
                    Assert.Null(rowid[RelationalAnnotationNames.ColumnOrder]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetColumnOrder()).Message);
                    Assert.Null(rowid.GetValueConverter());
                    Assert.NotNull(rowid.GetValueComparer());
                    Assert.NotNull(rowid.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, rowid.GetValueGenerationStrategy());

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.True(dependentForeignKey.IsRequired);
                    Assert.False(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientNoAction, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId", "PrincipalAlternateId" }, dependentForeignKey.Properties.Select(p => p.Name));
                    Assert.Same(principalKey, dependentForeignKey.PrincipalKey);

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.False(dependentBase.GetIsDiscriminatorMappingComplete());
                    var principalDiscriminator = dependentBase.FindDiscriminatorProperty();
                    Assert.IsType<DiscriminatorValueGenerator>(
                        principalDiscriminator.GetValueGeneratorFactory()(principalDiscriminator, dependentBase));
                    Assert.Equal(Enum1.One, dependentBase.GetDiscriminatorValue());

                    var dependentBaseForeignKey = dependentBase.GetForeignKeys().Single(fk => fk != dependentForeignKey);
                    var dependentForeignKeyProperty = dependentBaseForeignKey.Properties.Single();

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, dependentForeignKey }, dependentForeignKeyProperty.GetContainingForeignKeys());

                    var dependentDerived = dependentBase.GetDerivedTypes().Single();
                    Assert.Equal(Enum1.Two, dependentDerived.GetDiscriminatorValue());

                    Assert.Equal(2, dependentDerived.GetDeclaredProperties().Count());

                    var dependentData = dependentDerived.GetDeclaredProperties().First();
                    Assert.Equal(typeof(string), dependentData.ClrType);
                    Assert.Equal("Data", dependentData.Name);
                    Assert.Equal("Data", dependentData.PropertyInfo.Name);
                    Assert.Equal("<Data>k__BackingField", dependentData.FieldInfo.Name);
                    Assert.True(dependentData.IsNullable);
                    Assert.False(dependentData.IsShadowProperty());
                    Assert.False(dependentData.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentData.ValueGenerated);
                    Assert.Equal("Data", dependentData.GetColumnName());
                    Assert.Equal("char(20)", dependentData.GetColumnType());
                    Assert.Equal(20, dependentData.GetMaxLength());
                    Assert.False(dependentData.IsUnicode());
                    Assert.True(dependentData.IsFixedLength());
                    Assert.Null(dependentData.GetPrecision());
                    Assert.Null(dependentData.GetScale());

                    var dependentMoney = dependentDerived.GetDeclaredProperties().Last();
                    Assert.Equal(typeof(decimal), dependentMoney.ClrType);
                    Assert.Equal("Money", dependentMoney.Name);
                    Assert.Null(dependentMoney.PropertyInfo);
                    Assert.Null(dependentMoney.FieldInfo);
                    Assert.False(dependentMoney.IsNullable);
                    Assert.True(dependentMoney.IsShadowProperty());
                    Assert.False(dependentMoney.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentMoney.ValueGenerated);
                    Assert.Equal("Money", dependentMoney.GetColumnName());
                    Assert.Equal("decimal(9,3)", dependentMoney.GetColumnType());
                    Assert.Null(dependentMoney.GetMaxLength());
                    Assert.Null(dependentMoney.IsUnicode());
                    Assert.Null(dependentMoney.IsFixedLength());
                    Assert.Equal(9, dependentMoney.GetPrecision());
                    Assert.Equal(3, dependentMoney.GetScale());

                    Assert.Equal(
                        new[]
                        {
                            derivedSkipNavigation.ForeignKey,
                            tptForeignKey,
                            referenceOwnership,
                            collectionOwnership,
                            dependentForeignKey,
                            derivedSkipNavigation.Inverse.ForeignKey
                        },
                        principalKey.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, tptForeignKey, referenceOwnership, derivedSkipNavigation.Inverse.ForeignKey },
                        principalBase.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { derivedSkipNavigation.ForeignKey, collectionOwnership, dependentForeignKey },
                        principalDerived.GetDeclaredReferencingForeignKeys());

                    Assert.Equal(
                        new[]
                        {
                            dependentBase,
                            dependentDerived,
                            manyTypesType,
                            principalBase,
                            referenceOwnedType,
                            principalDerived,
                            collectionOwnedType,
                            joinType
                        },
                        model.GetEntityTypes());
                },
                typeof(SqlServerNetTopologySuiteDesignTimeServices),
                c =>
                {
                    c.Set<PrincipalDerived<DependentBase<byte?>>>().Add(
                        new PrincipalDerived<DependentBase<byte?>>
                        {
                            AlternateId = new Guid(),
                            Dependent = new DependentBase<byte?>(1),
                            Owned = new OwnedType(c)
                        });

                    c.SaveChanges();
                });

        [ConditionalFact]
        [SqlServerConfiguredCondition]
        public void BigModel_with_JSON_columns()
            => Test(
                new BigContextWithJson(),
                new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "BigContextWithJsonModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.BigContextWithJson))]
    public partial class BigContextWithJsonModel : RuntimeModel
    {
        static BigContextWithJsonModel()
        {
            var model = new BigContextWithJsonModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static BigContextWithJsonModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "BigContextWithJsonModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Migrations;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class BigContextWithJsonModel
    {
        partial void Initialize()
        {
            var dependentBase = DependentBaseEntityType.Create(this);
            var manyTypes = ManyTypesEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var ownedType = OwnedTypeEntityType.Create(this);
            var ownedType0 = OwnedType0EntityType.Create(this);
            var principalBasePrincipalDerivedDependentBasebyte = PrincipalBasePrincipalDerivedDependentBasebyteEntityType.Create(this);
            var dependentDerived = DependentDerivedEntityType.Create(this, dependentBase);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalBase);
            DependentBaseEntityType.CreateForeignKey2(dependentBase, principalDerived);
            OwnedTypeEntityType.CreateForeignKey1(ownedType, principalBase);
            OwnedType0EntityType.CreateForeignKey1(ownedType0, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey1(principalBasePrincipalDerivedDependentBasebyte, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey2(principalBasePrincipalDerivedDependentBasebyte, principalBase);

            PrincipalBaseEntityType.CreateSkipNavigation1(principalBase, principalDerived, principalBasePrincipalDerivedDependentBasebyte);
            PrincipalDerivedEntityType.CreateSkipNavigation1(principalDerived, principalBase, principalBasePrincipalDerivedDependentBasebyte);

            DependentBaseEntityType.CreateAnnotations(dependentBase);
            ManyTypesEntityType.CreateAnnotations(manyTypes);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            OwnedTypeEntityType.CreateAnnotations(ownedType);
            OwnedType0EntityType.CreateAnnotations(ownedType0);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateAnnotations(principalBasePrincipalDerivedDependentBasebyte);
            DependentDerivedEntityType.CreateAnnotations(dependentDerived);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            dependentBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", null, relationalModel);
            var dataColumnBase = new ColumnBase<ColumnMappingBase>("Data", "char(20)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Data", dataColumnBase);
            var enumDiscriminatorColumnBase = new ColumnBase<ColumnMappingBase>("EnumDiscriminator", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("EnumDiscriminator", enumDiscriminatorColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase);
            var moneyColumnBase = new ColumnBase<ColumnMappingBase>("Money", "decimal(9,3)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Money", moneyColumnBase);
            var principalAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalAlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalAlternateId", principalAlternateIdColumnBase);
            var principalIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalId", principalIdColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(dependentBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentBase.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentBase.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentBase.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, dependentBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings = new List<TableMapping>();
            dependentBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
            var principalIdColumn = new Column("PrincipalId", "bigint", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
            var principalAlternateIdColumn = new Column("PrincipalAlternateId", "uniqueidentifier", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
            var dataColumn = new Column("Data", "char(20)", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Data", dataColumn);
            var enumDiscriminatorColumn = new Column("EnumDiscriminator", "int", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
            var idColumn = new Column("Id", "tinyint", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Id", idColumn);
            var moneyColumn = new Column("Money", "decimal(9,3)", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Money", moneyColumn);
            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
            var pK_DependentBasebyteUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" });
            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteUc).Add(pK_DependentBasebyte);
            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
            var iX_DependentBasebyte_PrincipalId = new TableIndex(
            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" });
            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
            relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
            tableMappings.Add(dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentBase.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentBase.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);

            var dependentDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            dependentDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0 = new TableMappingBase<ColumnMappingBase>(dependentDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0, false);
            defaultTableMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentDerived.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentDerived.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dataColumnBase, dependentDerived.FindProperty("Data")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentDerived.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, dependentDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)moneyColumnBase, dependentDerived.FindProperty("Money")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);

            var tableMappings0 = new List<TableMapping>();
            dependentDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings0);
            var dependentBasebyteTableMapping0 = new TableMapping(dependentDerived, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping0, false);
            tableMappings0.Add(dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentDerived.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentDerived.FindProperty("PrincipalId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);

            var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes")!;

            var defaultTableMappings1 = new List<TableMappingBase<ColumnMappingBase>>();
            manyTypes.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings1);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", null, relationalModel);
            var boolColumnBase = new ColumnBase<ColumnMappingBase>("Bool", "bit", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bool", boolColumnBase);
            var boolArrayColumnBase = new ColumnBase<ColumnMappingBase>("BoolArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolArray", boolArrayColumnBase);
            var bytesColumnBase = new ColumnBase<ColumnMappingBase>("Bytes", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bytes", bytesColumnBase);
            var bytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("BytesArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BytesArray", bytesArrayColumnBase);
            var charColumnBase = new ColumnBase<ColumnMappingBase>("Char", "nvarchar(1)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Char", charColumnBase);
            var charArrayColumnBase = new ColumnBase<ColumnMappingBase>("CharArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("CharArray", charArrayColumnBase);
            var dateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("DateOnly", "date", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnly", dateOnlyColumnBase);
            var dateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnlyArray", dateOnlyArrayColumnBase);
            var dateTimeColumnBase = new ColumnBase<ColumnMappingBase>("DateTime", "datetime2", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTime", dateTimeColumnBase);
            var dateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeArray", dateTimeArrayColumnBase);
            var decimalColumnBase = new ColumnBase<ColumnMappingBase>("Decimal", "decimal(18,2)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Decimal", decimalColumnBase);
            var decimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("DecimalArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DecimalArray", decimalArrayColumnBase);
            var doubleColumnBase = new ColumnBase<ColumnMappingBase>("Double", "float", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Double", doubleColumnBase);
            var doubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("DoubleArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DoubleArray", doubleArrayColumnBase);
            var floatColumnBase = new ColumnBase<ColumnMappingBase>("Float", "real", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Float", floatColumnBase);
            var floatArrayColumnBase = new ColumnBase<ColumnMappingBase>("FloatArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("FloatArray", floatArrayColumnBase);
            var guidColumnBase = new ColumnBase<ColumnMappingBase>("Guid", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Guid", guidColumnBase);
            var guidArrayColumnBase = new ColumnBase<ColumnMappingBase>("GuidArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("GuidArray", guidArrayColumnBase);
            var iPAddressColumnBase = new ColumnBase<ColumnMappingBase>("IPAddress", "nvarchar(45)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddress", iPAddressColumnBase);
            var iPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("IPAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddressArray", iPAddressArrayColumnBase);
            var idColumnBase0 = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Id", idColumnBase0);
            var int16ColumnBase = new ColumnBase<ColumnMappingBase>("Int16", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16", int16ColumnBase);
            var int16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16Array", int16ArrayColumnBase);
            var int32ColumnBase = new ColumnBase<ColumnMappingBase>("Int32", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32", int32ColumnBase);
            var int32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32Array", int32ArrayColumnBase);
            var int64ColumnBase = new ColumnBase<ColumnMappingBase>("Int64", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64", int64ColumnBase);
            var int64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64Array", int64ArrayColumnBase);
            var int8ColumnBase = new ColumnBase<ColumnMappingBase>("Int8", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8", int8ColumnBase);
            var int8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int8Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8Array", int8ArrayColumnBase);
            var nullableBoolColumnBase = new ColumnBase<ColumnMappingBase>("NullableBool", "bit", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBool", nullableBoolColumnBase);
            var nullableBoolArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBoolArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBoolArray", nullableBoolArrayColumnBase);
            var nullableBytesColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytes", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytes", nullableBytesColumnBase);
            var nullableBytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytesArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytesArray", nullableBytesArrayColumnBase);
            var nullableCharColumnBase = new ColumnBase<ColumnMappingBase>("NullableChar", "nvarchar(1)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableChar", nullableCharColumnBase);
            var nullableCharArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableCharArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableCharArray", nullableCharArrayColumnBase);
            var nullableDateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnly", "date", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnly", nullableDateOnlyColumnBase);
            var nullableDateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumnBase);
            var nullableDateTimeColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTime", "datetime2", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTime", nullableDateTimeColumnBase);
            var nullableDateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTimeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumnBase);
            var nullableDecimalColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimal", "decimal(18,2)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimal", nullableDecimalColumnBase);
            var nullableDecimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimalArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumnBase);
            var nullableDoubleColumnBase = new ColumnBase<ColumnMappingBase>("NullableDouble", "float", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDouble", nullableDoubleColumnBase);
            var nullableDoubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDoubleArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumnBase);
            var nullableFloatColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloat", "real", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloat", nullableFloatColumnBase);
            var nullableFloatArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloatArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloatArray", nullableFloatArrayColumnBase);
            var nullableGuidColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuid", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuid", nullableGuidColumnBase);
            var nullableGuidArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuidArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuidArray", nullableGuidArrayColumnBase);
            var nullableIPAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddress", "nvarchar(45)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddress", nullableIPAddressColumnBase);
            var nullableIPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumnBase);
            var nullableInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16", nullableInt16ColumnBase);
            var nullableInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16Array", nullableInt16ArrayColumnBase);
            var nullableInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32", nullableInt32ColumnBase);
            var nullableInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32Array", nullableInt32ArrayColumnBase);
            var nullableInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64", nullableInt64ColumnBase);
            var nullableInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64Array", nullableInt64ArrayColumnBase);
            var nullableInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8", "smallint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8", nullableInt8ColumnBase);
            var nullableInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8Array", nullableInt8ArrayColumnBase);
            var nullablePhysicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddress", "nvarchar(20)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumnBase);
            var nullablePhysicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumnBase);
            var nullableStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableString", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableString", nullableStringColumnBase);
            var nullableStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableStringArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableStringArray", nullableStringArrayColumnBase);
            var nullableTimeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnly", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumnBase);
            var nullableTimeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumnBase);
            var nullableTimeSpanColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpan", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpan", nullableTimeSpanColumnBase);
            var nullableTimeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpanArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumnBase);
            var nullableUInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16", nullableUInt16ColumnBase);
            var nullableUInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumnBase);
            var nullableUInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32", nullableUInt32ColumnBase);
            var nullableUInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumnBase);
            var nullableUInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64", "decimal(20,0)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64", nullableUInt64ColumnBase);
            var nullableUInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumnBase);
            var nullableUInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8", nullableUInt8ColumnBase);
            var nullableUInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumnBase);
            var nullableUriColumnBase = new ColumnBase<ColumnMappingBase>("NullableUri", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUri", nullableUriColumnBase);
            var nullableUriArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUriArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUriArray", nullableUriArrayColumnBase);
            var physicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddress", "nvarchar(20)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddress", physicalAddressColumnBase);
            var physicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddressArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumnBase);
            var stringColumnBase = new ColumnBase<ColumnMappingBase>("String", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("String", stringColumnBase);
            var stringArrayColumnBase = new ColumnBase<ColumnMappingBase>("StringArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringArray", stringArrayColumnBase);
            var timeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnly", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnly", timeOnlyColumnBase);
            var timeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnlyArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnlyArray", timeOnlyArrayColumnBase);
            var timeSpanColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpan", "time", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpan", timeSpanColumnBase);
            var timeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpanArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpanArray", timeSpanArrayColumnBase);
            var uInt16ColumnBase = new ColumnBase<ColumnMappingBase>("UInt16", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16", uInt16ColumnBase);
            var uInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt16Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16Array", uInt16ArrayColumnBase);
            var uInt32ColumnBase = new ColumnBase<ColumnMappingBase>("UInt32", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32", uInt32ColumnBase);
            var uInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt32Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32Array", uInt32ArrayColumnBase);
            var uInt64ColumnBase = new ColumnBase<ColumnMappingBase>("UInt64", "decimal(20,0)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64", uInt64ColumnBase);
            var uInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt64Array", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64Array", uInt64ArrayColumnBase);
            var uInt8ColumnBase = new ColumnBase<ColumnMappingBase>("UInt8", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8", uInt8ColumnBase);
            var uInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt8Array", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8Array", uInt8ArrayColumnBase);
            var uriColumnBase = new ColumnBase<ColumnMappingBase>("Uri", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Uri", uriColumnBase);
            var uriArrayColumnBase = new ColumnBase<ColumnMappingBase>("UriArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UriArray", uriArrayColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase = new TableMappingBase<ColumnMappingBase>(manyTypes, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase, false);
            defaultTableMappings1.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, manyTypes.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolColumnBase, manyTypes.FindProperty("Bool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolArrayColumnBase, manyTypes.FindProperty("BoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesColumnBase, manyTypes.FindProperty("Bytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesArrayColumnBase, manyTypes.FindProperty("BytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charColumnBase, manyTypes.FindProperty("Char")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charArrayColumnBase, manyTypes.FindProperty("CharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyColumnBase, manyTypes.FindProperty("DateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyArrayColumnBase, manyTypes.FindProperty("DateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeColumnBase, manyTypes.FindProperty("DateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeArrayColumnBase, manyTypes.FindProperty("DateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalColumnBase, manyTypes.FindProperty("Decimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalArrayColumnBase, manyTypes.FindProperty("DecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleColumnBase, manyTypes.FindProperty("Double")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleArrayColumnBase, manyTypes.FindProperty("DoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatColumnBase, manyTypes.FindProperty("Float")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatArrayColumnBase, manyTypes.FindProperty("FloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidColumnBase, manyTypes.FindProperty("Guid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidArrayColumnBase, manyTypes.FindProperty("GuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressColumnBase, manyTypes.FindProperty("IPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressArrayColumnBase, manyTypes.FindProperty("IPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ColumnBase, manyTypes.FindProperty("Int16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ArrayColumnBase, manyTypes.FindProperty("Int16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ColumnBase, manyTypes.FindProperty("Int32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ArrayColumnBase, manyTypes.FindProperty("Int32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ColumnBase, manyTypes.FindProperty("Int64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ArrayColumnBase, manyTypes.FindProperty("Int64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ColumnBase, manyTypes.FindProperty("Int8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ArrayColumnBase, manyTypes.FindProperty("Int8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolColumnBase, manyTypes.FindProperty("NullableBool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolArrayColumnBase, manyTypes.FindProperty("NullableBoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesColumnBase, manyTypes.FindProperty("NullableBytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesArrayColumnBase, manyTypes.FindProperty("NullableBytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharColumnBase, manyTypes.FindProperty("NullableChar")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharArrayColumnBase, manyTypes.FindProperty("NullableCharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyColumnBase, manyTypes.FindProperty("NullableDateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyArrayColumnBase, manyTypes.FindProperty("NullableDateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeColumnBase, manyTypes.FindProperty("NullableDateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeArrayColumnBase, manyTypes.FindProperty("NullableDateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalColumnBase, manyTypes.FindProperty("NullableDecimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalArrayColumnBase, manyTypes.FindProperty("NullableDecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleColumnBase, manyTypes.FindProperty("NullableDouble")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleArrayColumnBase, manyTypes.FindProperty("NullableDoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatColumnBase, manyTypes.FindProperty("NullableFloat")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatArrayColumnBase, manyTypes.FindProperty("NullableFloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidColumnBase, manyTypes.FindProperty("NullableGuid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidArrayColumnBase, manyTypes.FindProperty("NullableGuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressColumnBase, manyTypes.FindProperty("NullableIPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressArrayColumnBase, manyTypes.FindProperty("NullableIPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ColumnBase, manyTypes.FindProperty("NullableInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ArrayColumnBase, manyTypes.FindProperty("NullableInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ColumnBase, manyTypes.FindProperty("NullableInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ArrayColumnBase, manyTypes.FindProperty("NullableInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ColumnBase, manyTypes.FindProperty("NullableInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ArrayColumnBase, manyTypes.FindProperty("NullableInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ColumnBase, manyTypes.FindProperty("NullableInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ArrayColumnBase, manyTypes.FindProperty("NullableInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressColumnBase, manyTypes.FindProperty("NullablePhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressArrayColumnBase, manyTypes.FindProperty("NullablePhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringColumnBase, manyTypes.FindProperty("NullableString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringArrayColumnBase, manyTypes.FindProperty("NullableStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyColumnBase, manyTypes.FindProperty("NullableTimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyArrayColumnBase, manyTypes.FindProperty("NullableTimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanColumnBase, manyTypes.FindProperty("NullableTimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanArrayColumnBase, manyTypes.FindProperty("NullableTimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ColumnBase, manyTypes.FindProperty("NullableUInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ArrayColumnBase, manyTypes.FindProperty("NullableUInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ColumnBase, manyTypes.FindProperty("NullableUInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ArrayColumnBase, manyTypes.FindProperty("NullableUInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ColumnBase, manyTypes.FindProperty("NullableUInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ArrayColumnBase, manyTypes.FindProperty("NullableUInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ColumnBase, manyTypes.FindProperty("NullableUInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ArrayColumnBase, manyTypes.FindProperty("NullableUInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriColumnBase, manyTypes.FindProperty("NullableUri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriArrayColumnBase, manyTypes.FindProperty("NullableUriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressColumnBase, manyTypes.FindProperty("PhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressArrayColumnBase, manyTypes.FindProperty("PhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringColumnBase, manyTypes.FindProperty("String")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringArrayColumnBase, manyTypes.FindProperty("StringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyColumnBase, manyTypes.FindProperty("TimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyArrayColumnBase, manyTypes.FindProperty("TimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanColumnBase, manyTypes.FindProperty("TimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanArrayColumnBase, manyTypes.FindProperty("TimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ColumnBase, manyTypes.FindProperty("UInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ArrayColumnBase, manyTypes.FindProperty("UInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ColumnBase, manyTypes.FindProperty("UInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ArrayColumnBase, manyTypes.FindProperty("UInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ColumnBase, manyTypes.FindProperty("UInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ArrayColumnBase, manyTypes.FindProperty("UInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ColumnBase, manyTypes.FindProperty("UInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ArrayColumnBase, manyTypes.FindProperty("UInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriColumnBase, manyTypes.FindProperty("Uri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriArrayColumnBase, manyTypes.FindProperty("UriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);

            var tableMappings1 = new List<TableMapping>();
            manyTypes.SetRuntimeAnnotation("Relational:TableMappings", tableMappings1);
            var manyTypesTable = new Table("ManyTypes", null, relationalModel);
            var idColumn0 = new Column("Id", "int", manyTypesTable);
            manyTypesTable.Columns.Add("Id", idColumn0);
            var boolColumn = new Column("Bool", "bit", manyTypesTable);
            manyTypesTable.Columns.Add("Bool", boolColumn);
            var boolArrayColumn = new Column("BoolArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
            var bytesColumn = new Column("Bytes", "varbinary(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Bytes", bytesColumn);
            var bytesArrayColumn = new Column("BytesArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
            var charColumn = new Column("Char", "nvarchar(1)", manyTypesTable);
            manyTypesTable.Columns.Add("Char", charColumn);
            var charArrayColumn = new Column("CharArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("CharArray", charArrayColumn);
            var dateOnlyColumn = new Column("DateOnly", "date", manyTypesTable);
            manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
            var dateOnlyArrayColumn = new Column("DateOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
            var dateTimeColumn = new Column("DateTime", "datetime2", manyTypesTable);
            manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
            var dateTimeArrayColumn = new Column("DateTimeArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
            var decimalColumn = new Column("Decimal", "decimal(18,2)", manyTypesTable);
            manyTypesTable.Columns.Add("Decimal", decimalColumn);
            var decimalArrayColumn = new Column("DecimalArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
            var doubleColumn = new Column("Double", "float", manyTypesTable);
            manyTypesTable.Columns.Add("Double", doubleColumn);
            var doubleArrayColumn = new Column("DoubleArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
            var floatColumn = new Column("Float", "real", manyTypesTable);
            manyTypesTable.Columns.Add("Float", floatColumn);
            var floatArrayColumn = new Column("FloatArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
            var guidColumn = new Column("Guid", "uniqueidentifier", manyTypesTable);
            manyTypesTable.Columns.Add("Guid", guidColumn);
            var guidArrayColumn = new Column("GuidArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
            var iPAddressColumn = new Column("IPAddress", "nvarchar(45)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
            var iPAddressArrayColumn = new Column("IPAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
            var int16Column = new Column("Int16", "smallint", manyTypesTable);
            manyTypesTable.Columns.Add("Int16", int16Column);
            var int16ArrayColumn = new Column("Int16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
            var int32Column = new Column("Int32", "int", manyTypesTable);
            manyTypesTable.Columns.Add("Int32", int32Column);
            var int32ArrayColumn = new Column("Int32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
            var int64Column = new Column("Int64", "bigint", manyTypesTable);
            manyTypesTable.Columns.Add("Int64", int64Column);
            var int64ArrayColumn = new Column("Int64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
            var int8Column = new Column("Int8", "smallint", manyTypesTable);
            manyTypesTable.Columns.Add("Int8", int8Column);
            var int8ArrayColumn = new Column("Int8Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
            var nullableBoolColumn = new Column("NullableBool", "bit", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
            var nullableBoolArrayColumn = new Column("NullableBoolArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
            var nullableBytesColumn = new Column("NullableBytes", "varbinary(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
            var nullableBytesArrayColumn = new Column("NullableBytesArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
            var nullableCharColumn = new Column("NullableChar", "nvarchar(1)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
            var nullableCharArrayColumn = new Column("NullableCharArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
            var nullableDateOnlyColumn = new Column("NullableDateOnly", "date", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
            var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
            var nullableDateTimeColumn = new Column("NullableDateTime", "datetime2", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
            var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
            var nullableDecimalColumn = new Column("NullableDecimal", "decimal(18,2)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
            var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
            var nullableDoubleColumn = new Column("NullableDouble", "float", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
            var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
            var nullableFloatColumn = new Column("NullableFloat", "real", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
            var nullableFloatArrayColumn = new Column("NullableFloatArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
            var nullableGuidColumn = new Column("NullableGuid", "uniqueidentifier", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
            var nullableGuidArrayColumn = new Column("NullableGuidArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
            var nullableIPAddressColumn = new Column("NullableIPAddress", "nvarchar(45)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
            var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
            var nullableInt16Column = new Column("NullableInt16", "smallint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
            var nullableInt16ArrayColumn = new Column("NullableInt16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
            var nullableInt32Column = new Column("NullableInt32", "int", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
            var nullableInt32ArrayColumn = new Column("NullableInt32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
            var nullableInt64Column = new Column("NullableInt64", "bigint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
            var nullableInt64ArrayColumn = new Column("NullableInt64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
            var nullableInt8Column = new Column("NullableInt8", "smallint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
            var nullableInt8ArrayColumn = new Column("NullableInt8Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
            var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "nvarchar(20)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
            var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
            var nullableStringColumn = new Column("NullableString", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
            var nullableStringArrayColumn = new Column("NullableStringArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
            var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "time", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
            var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
            var nullableTimeSpanColumn = new Column("NullableTimeSpan", "time", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
            var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
            var nullableUInt16Column = new Column("NullableUInt16", "int", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
            var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
            var nullableUInt32Column = new Column("NullableUInt32", "bigint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
            var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
            var nullableUInt64Column = new Column("NullableUInt64", "decimal(20,0)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
            var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
            var nullableUInt8Column = new Column("NullableUInt8", "tinyint", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
            var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
            var nullableUriColumn = new Column("NullableUri", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
            var nullableUriArrayColumn = new Column("NullableUriArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
            var physicalAddressColumn = new Column("PhysicalAddress", "nvarchar(20)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
            var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
            var stringColumn = new Column("String", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("String", stringColumn);
            var stringArrayColumn = new Column("StringArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
            var timeOnlyColumn = new Column("TimeOnly", "time", manyTypesTable);
            manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
            var timeOnlyArrayColumn = new Column("TimeOnlyArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
            var timeSpanColumn = new Column("TimeSpan", "time", manyTypesTable);
            manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
            var timeSpanArrayColumn = new Column("TimeSpanArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
            var uInt16Column = new Column("UInt16", "int", manyTypesTable);
            manyTypesTable.Columns.Add("UInt16", uInt16Column);
            var uInt16ArrayColumn = new Column("UInt16Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
            var uInt32Column = new Column("UInt32", "bigint", manyTypesTable);
            manyTypesTable.Columns.Add("UInt32", uInt32Column);
            var uInt32ArrayColumn = new Column("UInt32Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
            var uInt64Column = new Column("UInt64", "decimal(20,0)", manyTypesTable);
            manyTypesTable.Columns.Add("UInt64", uInt64Column);
            var uInt64ArrayColumn = new Column("UInt64Array", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
            var uInt8Column = new Column("UInt8", "tinyint", manyTypesTable);
            manyTypesTable.Columns.Add("UInt8", uInt8Column);
            var uInt8ArrayColumn = new Column("UInt8Array", "varbinary(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
            var uriColumn = new Column("Uri", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Uri", uriColumn);
            var uriArrayColumn = new Column("UriArray", "nvarchar(max)", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn0 });
            manyTypesTable.PrimaryKey = pK_ManyTypes;
            var pK_ManyTypesUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                new[] { "Id" });
            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesUc).Add(pK_ManyTypes);
            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
            relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
            var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, true);
            manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
            tableMappings1.Add(manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(idColumn0, manyTypes.FindProperty("Id")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolColumn, manyTypes.FindProperty("Bool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolArrayColumn, manyTypes.FindProperty("BoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesColumn, manyTypes.FindProperty("Bytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesArrayColumn, manyTypes.FindProperty("BytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charColumn, manyTypes.FindProperty("Char")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charArrayColumn, manyTypes.FindProperty("CharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyColumn, manyTypes.FindProperty("DateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyArrayColumn, manyTypes.FindProperty("DateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeColumn, manyTypes.FindProperty("DateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeArrayColumn, manyTypes.FindProperty("DateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalColumn, manyTypes.FindProperty("Decimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalArrayColumn, manyTypes.FindProperty("DecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleColumn, manyTypes.FindProperty("Double")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleArrayColumn, manyTypes.FindProperty("DoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatColumn, manyTypes.FindProperty("Float")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatArrayColumn, manyTypes.FindProperty("FloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidColumn, manyTypes.FindProperty("Guid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidArrayColumn, manyTypes.FindProperty("GuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressColumn, manyTypes.FindProperty("IPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressArrayColumn, manyTypes.FindProperty("IPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16Column, manyTypes.FindProperty("Int16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16ArrayColumn, manyTypes.FindProperty("Int16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32Column, manyTypes.FindProperty("Int32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32ArrayColumn, manyTypes.FindProperty("Int32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64Column, manyTypes.FindProperty("Int64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64ArrayColumn, manyTypes.FindProperty("Int64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8Column, manyTypes.FindProperty("Int8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8ArrayColumn, manyTypes.FindProperty("Int8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolColumn, manyTypes.FindProperty("NullableBool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolArrayColumn, manyTypes.FindProperty("NullableBoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesColumn, manyTypes.FindProperty("NullableBytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesArrayColumn, manyTypes.FindProperty("NullableBytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharColumn, manyTypes.FindProperty("NullableChar")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharArrayColumn, manyTypes.FindProperty("NullableCharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyColumn, manyTypes.FindProperty("NullableDateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyArrayColumn, manyTypes.FindProperty("NullableDateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeColumn, manyTypes.FindProperty("NullableDateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeArrayColumn, manyTypes.FindProperty("NullableDateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalColumn, manyTypes.FindProperty("NullableDecimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalArrayColumn, manyTypes.FindProperty("NullableDecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleColumn, manyTypes.FindProperty("NullableDouble")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleArrayColumn, manyTypes.FindProperty("NullableDoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatColumn, manyTypes.FindProperty("NullableFloat")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatArrayColumn, manyTypes.FindProperty("NullableFloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidColumn, manyTypes.FindProperty("NullableGuid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidArrayColumn, manyTypes.FindProperty("NullableGuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressColumn, manyTypes.FindProperty("NullableIPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressArrayColumn, manyTypes.FindProperty("NullableIPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16Column, manyTypes.FindProperty("NullableInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16ArrayColumn, manyTypes.FindProperty("NullableInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32Column, manyTypes.FindProperty("NullableInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32ArrayColumn, manyTypes.FindProperty("NullableInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64Column, manyTypes.FindProperty("NullableInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64ArrayColumn, manyTypes.FindProperty("NullableInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8Column, manyTypes.FindProperty("NullableInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8ArrayColumn, manyTypes.FindProperty("NullableInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressColumn, manyTypes.FindProperty("NullablePhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressArrayColumn, manyTypes.FindProperty("NullablePhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringColumn, manyTypes.FindProperty("NullableString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringArrayColumn, manyTypes.FindProperty("NullableStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyColumn, manyTypes.FindProperty("NullableTimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyArrayColumn, manyTypes.FindProperty("NullableTimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanColumn, manyTypes.FindProperty("NullableTimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanArrayColumn, manyTypes.FindProperty("NullableTimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16Column, manyTypes.FindProperty("NullableUInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16ArrayColumn, manyTypes.FindProperty("NullableUInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32Column, manyTypes.FindProperty("NullableUInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32ArrayColumn, manyTypes.FindProperty("NullableUInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64Column, manyTypes.FindProperty("NullableUInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64ArrayColumn, manyTypes.FindProperty("NullableUInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8Column, manyTypes.FindProperty("NullableUInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8ArrayColumn, manyTypes.FindProperty("NullableUInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriColumn, manyTypes.FindProperty("NullableUri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriArrayColumn, manyTypes.FindProperty("NullableUriArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressColumn, manyTypes.FindProperty("PhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressArrayColumn, manyTypes.FindProperty("PhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringColumn, manyTypes.FindProperty("String")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringArrayColumn, manyTypes.FindProperty("StringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyColumn, manyTypes.FindProperty("TimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyArrayColumn, manyTypes.FindProperty("TimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanColumn, manyTypes.FindProperty("TimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanArrayColumn, manyTypes.FindProperty("TimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16Column, manyTypes.FindProperty("UInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16ArrayColumn, manyTypes.FindProperty("UInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32Column, manyTypes.FindProperty("UInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32ArrayColumn, manyTypes.FindProperty("UInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64Column, manyTypes.FindProperty("UInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64ArrayColumn, manyTypes.FindProperty("UInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8Column, manyTypes.FindProperty("UInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8ArrayColumn, manyTypes.FindProperty("UInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);

            var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase")!;

            var defaultTableMappings2 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings2);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", null, relationalModel);
            var alternateIdColumnBase = new ColumnBase<ColumnMappingBase>("AlternateId", "uniqueidentifier", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("AlternateId", alternateIdColumnBase);
            var discriminatorColumnBase = new ColumnBase<ColumnMappingBase>("Discriminator", "nvarchar(55)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Discriminator", discriminatorColumnBase);
            var enum1ColumnBase = new ColumnBase<ColumnMappingBase>("Enum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum1", enum1ColumnBase);
            var enum2ColumnBase = new ColumnBase<ColumnMappingBase>("Enum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum2", enum2ColumnBase);
            var flagsEnum1ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase);
            var flagsEnum2ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase);
            var idColumnBase1 = new ColumnBase<ColumnMappingBase>("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Id", idColumnBase1);
            var pointColumnBase = new ColumnBase<ColumnMappingBase>("Point", "geometry", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Point", pointColumnBase);
            var refTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase);
            var refTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase);
            var refTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase);
            var refTypeListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeList", refTypeListColumnBase);
            var valueTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase);
            var valueTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase);
            var valueTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase);
            var valueTypeListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase = new TableMappingBase<ColumnMappingBase>(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase, false);
            defaultTableMappings2.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalBase.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)discriminatorColumnBase, principalBase.FindProperty("Discriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase, principalBase.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);

            var tableMappings2 = new List<TableMapping>();
            principalBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings2);
            var principalBaseTable = new Table("PrincipalBase", null, relationalModel);
            var idColumn1 = new Column("Id", "bigint", principalBaseTable);
            principalBaseTable.Columns.Add("Id", idColumn1);
            var alternateIdColumn = new Column("AlternateId", "uniqueidentifier", principalBaseTable);
            principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
            var discriminatorColumn = new Column("Discriminator", "nvarchar(55)", principalBaseTable);
            principalBaseTable.Columns.Add("Discriminator", discriminatorColumn);
            var enum1Column = new Column("Enum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Enum1", enum1Column);
            var enum2Column = new Column("Enum2", "int", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Enum2", enum2Column);
            var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
            var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
            var manyOwnedColumn = new JsonColumn("ManyOwned", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ManyOwned", manyOwnedColumn);
            var ownedColumn = new JsonColumn("Owned", "nvarchar(max)", principalBaseTable);
            principalBaseTable.Columns.Add("Owned", ownedColumn);
            var pointColumn = new Column("Point", "geometry", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Point", pointColumn);
            var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
            var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
            var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
            var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
            var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
            var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
            var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
            var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn1 });
            var aK_PrincipalBase_IdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdUc).Add(aK_PrincipalBase_Id);
            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn1, alternateIdColumn });
            principalBaseTable.PrimaryKey = pK;
            var pKUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK.MappedKeys.Add(pKUc);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc).Add(pK);
            principalBaseTable.UniqueConstraints.Add("PK", pK);
            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn1 }, false);
            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
            relationalModel.Tables.Add(("PrincipalBase", null), principalBaseTable);
            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
            tableMappings2.Add(principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalBase.FindProperty("AlternateId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(idColumn1, principalBase.FindProperty("Id")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(discriminatorColumn, principalBase.FindProperty("Discriminator")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(pointColumn, principalBase.FindProperty("Point")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);

            var ownedType = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType")!;

            var defaultTableMappings3 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings3);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", null, relationalModel);
            var ownedColumnBase = new JsonColumnBase("Owned", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Owned", ownedColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase, false);
            defaultTableMappings3.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);

            var tableMappings3 = new List<TableMapping>();
            ownedType.SetRuntimeAnnotation("Relational:TableMappings", tableMappings3);
            var principalBaseTableMapping0 = new TableMapping(ownedType, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping0, false);
            tableMappings3.Add(principalBaseTableMapping0);
            principalBaseTable.AddRowInternalForeignKey(ownedType, RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" }));

            var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>")!;

            var defaultTableMappings4 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings4);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0 = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0, false);
            defaultTableMappings4.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)discriminatorColumnBase, principalDerived.FindProperty("Discriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase, principalDerived.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);

            var tableMappings4 = new List<TableMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings4);
            var principalBaseTableMapping1 = new TableMapping(principalDerived, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping1, false);
            tableMappings4.Add(principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalDerived.FindProperty("AlternateId")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(idColumn1, principalDerived.FindProperty("Id")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(discriminatorColumn, principalDerived.FindProperty("Discriminator")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum1Column, principalDerived.FindProperty("Enum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum2Column, principalDerived.FindProperty("Enum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalDerived.FindProperty("FlagsEnum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalDerived.FindProperty("FlagsEnum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(pointColumn, principalDerived.FindProperty("Point")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalDerived.FindProperty("RefTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalDerived.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalDerived.FindProperty("RefTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalDerived.FindProperty("RefTypeList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalDerived.FindProperty("ValueTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping1);

            var ownedType0 = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType")!;

            var defaultTableMappings5 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType0.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings5);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", null, relationalModel);
            var manyOwnedColumnBase = new JsonColumnBase("ManyOwned", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ManyOwned", manyOwnedColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType0, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase, false);
            defaultTableMappings5.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);

            var tableMappings5 = new List<TableMapping>();
            ownedType0.SetRuntimeAnnotation("Relational:TableMappings", tableMappings5);
            var principalBaseTableMapping2 = new TableMapping(ownedType0, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping2, true);
            tableMappings5.Add(principalBaseTableMapping2);
            principalBaseTable.AddRowInternalForeignKey(ownedType0, RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" }));

            var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;

            var defaultTableMappings6 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings6);
            var principalBasePrincipalDerivedDependentBasebyteTableBase = new TableBase("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumnBase);
            var derivedsIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsId", derivedsIdColumnBase);
            var principalsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumnBase);
            var principalsIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsId", principalsIdColumnBase);
            var rowidColumnBase = new ColumnBase<ColumnMappingBase>("rowid", "rowversion", principalBasePrincipalDerivedDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("rowid", rowidColumnBase);
            relationalModel.DefaultTables.Add("PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTableBase);
            var principalBasePrincipalDerivedDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTableBase, true);
            principalBasePrincipalDerivedDependentBasebyteTableBase.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteMappingBase, false);
            defaultTableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)rowidColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);

            var tableMappings6 = new List<TableMapping>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:TableMappings", tableMappings6);
            var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsIdColumn = new Column("DerivedsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
            var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
            var principalsIdColumn = new Column("PrincipalsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
            var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
            var rowidColumn = new Column("rowid", "rowversion", principalBasePrincipalDerivedDependentBasebyteTable)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
            var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
            principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
            var pK_PrincipalBasePrincipalDerivedDependentBasebyteUc = RelationalModel.GetKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
            pK_PrincipalBasePrincipalDerivedDependentBasebyte.MappedKeys.Add(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc).Add(pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
            "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" });
            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, true);
            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
            tableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                new[] { principalIdColumn },
                principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
            var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            fK_DependentBasebyte_PrincipalBase_PrincipalId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk).Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            var fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalBase_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalBaseTable,
                new[] { principalIdColumn, principalAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
            var fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateIdFk).Add(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                new[] { principalsIdColumn, principalsAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.One);

            var principalId = runtimeEntityType.AddProperty(
                "PrincipalId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalAlternateId = runtimeEntityType.AddProperty(
                "PrincipalAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enumDiscriminator = runtimeEntityType.AddProperty(
                "EnumDiscriminator",
                typeof(CSharpMigrationsGeneratorTest.Enum1),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create,
                sentinel: CSharpMigrationsGeneratorTest.Enum1.Default);
            enumDiscriminator.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                keyComparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                    (int value) => (CSharpMigrationsGeneratorTest.Enum1)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                        (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                        (int value) => (CSharpMigrationsGeneratorTest.Enum1)value)));
            enumDiscriminator.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            id.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { principalId, principalAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId"), declaringEntityType.FindProperty("PrincipalAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientNoAction,
                unique: true,
                required: true);

            var principal = declaringEntityType.AddNavigation("Principal",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation("Dependent",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Dependent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Dependent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("DiscriminatorMappingComplete", false);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "ManyTypesEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class ManyTypesEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var @bool = runtimeEntityType.AddProperty(
                "Bool",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            @bool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v));
            @bool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var boolArray = runtimeEntityType.AddProperty(
                "BoolArray",
                typeof(bool[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            boolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                keyComparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v)));
            boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytes = runtimeEntityType.AddProperty(
                "Bytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            bytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var bytesArray = runtimeEntityType.AddProperty(
                "BytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @char = runtimeEntityType.AddProperty(
                "Char",
                typeof(char),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: ' ');
            @char.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            @char.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var charArray = runtimeEntityType.AddProperty(
                "CharArray",
                typeof(char[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            charArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                keyComparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionReaderWriter<char[], char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0])))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<char[], char[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0]),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))));
            charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnly = runtimeEntityType.AddProperty(
                "DateOnly",
                typeof(DateOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v));
            dateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateOnlyArray = runtimeEntityType.AddProperty(
                "DateOnlyArray",
                typeof(DateOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                keyComparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v)));
            dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTime = runtimeEntityType.AddProperty(
                "DateTime",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v));
            dateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var dateTimeArray = runtimeEntityType.AddProperty(
                "DateTimeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @decimal = runtimeEntityType.AddProperty(
                "Decimal",
                typeof(decimal),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0m);
            @decimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v));
            @decimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var decimalArray = runtimeEntityType.AddProperty(
                "DecimalArray",
                typeof(decimal[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            decimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                keyComparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v)));
            decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @double = runtimeEntityType.AddProperty(
                "Double",
                typeof(double),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0.0);
            @double.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v));
            @double.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var doubleArray = runtimeEntityType.AddProperty(
                "DoubleArray",
                typeof(double[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            doubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                keyComparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v)));
            doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @float = runtimeEntityType.AddProperty(
                "Float",
                typeof(float),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0f);
            @float.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v));
            @float.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var floatArray = runtimeEntityType.AddProperty(
                "FloatArray",
                typeof(float[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            floatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                keyComparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v)));
            floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guid = runtimeEntityType.AddProperty(
                "Guid",
                typeof(Guid),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            guid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            guid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var guidArray = runtimeEntityType.AddProperty(
                "GuidArray",
                typeof(Guid[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            guidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                keyComparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddress = runtimeEntityType.AddProperty(
                "IPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            iPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var iPAddressArray = runtimeEntityType.AddProperty(
                "IPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16 = runtimeEntityType.AddProperty(
                "Int16",
                typeof(short),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (short)0);
            int16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                keyComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v));
            int16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int16Array = runtimeEntityType.AddProperty(
                "Int16Array",
                typeof(short[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32 = runtimeEntityType.AddProperty(
                "Int32",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            int32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            int32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int32Array = runtimeEntityType.AddProperty(
                "Int32Array",
                typeof(int[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                keyComparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v)));
            int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64 = runtimeEntityType.AddProperty(
                "Int64",
                typeof(long),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0L);
            int64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            int64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int64Array = runtimeEntityType.AddProperty(
                "Int64Array",
                typeof(long[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                keyComparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v)));
            int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8 = runtimeEntityType.AddProperty(
                "Int8",
                typeof(sbyte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (sbyte)0);
            int8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    (sbyte v) => (short)v,
                    (short v) => (sbyte)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v)));
            int8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var int8Array = runtimeEntityType.AddProperty(
                "Int8Array",
                typeof(sbyte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                keyComparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))));
            int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBool = runtimeEntityType.AddProperty(
                "NullableBool",
                typeof(bool?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBool.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)));
            nullableBool.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBoolArray = runtimeEntityType.AddProperty(
                "NullableBoolArray",
                typeof(bool?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBoolArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                keyComparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<bool?>(new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: SqlServerBoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v)));
            nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytes = runtimeEntityType.AddProperty(
                "NullableBytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytes.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            nullableBytes.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableBytesArray = runtimeEntityType.AddProperty(
                "NullableBytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytesArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    JsonByteArrayReaderWriter.Instance),
                elementMapping: SqlServerByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varbinary(max)"),
                    storeTypePostfix: StoreTypePostfix.None));
            nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableChar = runtimeEntityType.AddProperty(
                "NullableChar",
                typeof(char?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableChar.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                keyComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(1)",
                    size: 1,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            nullableChar.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableCharArray = runtimeEntityType.AddProperty(
                "NullableCharArray",
                typeof(char?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableCharArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                keyComparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<char?>(new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0])))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(1)",
                        size: 1,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0]),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<char, string>(
                            (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                            (string v) => v.Length < 1 ? '\0' : v[0]))));
            nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnly = runtimeEntityType.AddProperty(
                "NullableDateOnly",
                typeof(DateOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnly.TypeMapping = SqlServerDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)),
                keyComparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)),
                providerValueComparer: new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>)));
            nullableDateOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                "NullableDateOnlyArray",
                typeof(DateOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                keyComparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqlServerDateOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    keyComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v),
                    providerValueComparer: new ValueComparer<DateOnly>(
                        (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                        (DateOnly v) => v.GetHashCode(),
                        (DateOnly v) => v)));
            nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTime = runtimeEntityType.AddProperty(
                "NullableDateTime",
                typeof(DateTime?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTime.TypeMapping = SqlServerDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)),
                keyComparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)),
                providerValueComparer: new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>)));
            nullableDateTime.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDateTimeArray = runtimeEntityType.AddProperty(
                "NullableDateTimeArray",
                typeof(DateTime?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTimeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                keyComparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimal = runtimeEntityType.AddProperty(
                "NullableDecimal",
                typeof(decimal?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimal.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)),
                keyComparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)),
                providerValueComparer: new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>)));
            nullableDecimal.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDecimalArray = runtimeEntityType.AddProperty(
                "NullableDecimalArray",
                typeof(decimal?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimalArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                keyComparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<decimal?>(new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    JsonDecimalReaderWriter.Instance),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    keyComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v)));
            nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDouble = runtimeEntityType.AddProperty(
                "NullableDouble",
                typeof(double?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDouble.TypeMapping = SqlServerDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            nullableDouble.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableDoubleArray = runtimeEntityType.AddProperty(
                "NullableDoubleArray",
                typeof(double?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDoubleArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                keyComparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<double?>(new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: SqlServerDoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v)));
            nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloat = runtimeEntityType.AddProperty(
                "NullableFloat",
                typeof(float?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloat.TypeMapping = SqlServerFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            nullableFloat.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableFloatArray = runtimeEntityType.AddProperty(
                "NullableFloatArray",
                typeof(float?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloatArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                keyComparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<float?>(new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: SqlServerFloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v)));
            nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuid = runtimeEntityType.AddProperty(
                "NullableGuid",
                typeof(Guid?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuid.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                keyComparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                providerValueComparer: new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            nullableGuid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableGuidArray = runtimeEntityType.AddProperty(
                "NullableGuidArray",
                typeof(Guid?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuidArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                keyComparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Guid?>(new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    JsonGuidReaderWriter.Instance),
                elementMapping: GuidTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    keyComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    providerValueComparer: new ValueComparer<Guid>(
                        (Guid v1, Guid v2) => v1 == v2,
                        (Guid v) => v.GetHashCode(),
                        (Guid v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "uniqueidentifier")));
            nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddress = runtimeEntityType.AddProperty(
                "NullableIPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(45)",
                    size: 45,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));
            nullableIPAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableIPAddressArray = runtimeEntityType.AddProperty(
                "NullableIPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16 = runtimeEntityType.AddProperty(
                "NullableInt16",
                typeof(short?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                keyComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                providerValueComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)));
            nullableInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt16Array = runtimeEntityType.AddProperty(
                "NullableInt16Array",
                typeof(short?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                keyComparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short?>(new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32 = runtimeEntityType.AddProperty(
                "NullableInt32",
                typeof(int?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            nullableInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt32Array = runtimeEntityType.AddProperty(
                "NullableInt32Array",
                typeof(int?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                keyComparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<int?>(new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v)));
            nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64 = runtimeEntityType.AddProperty(
                "NullableInt64",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            nullableInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt64Array = runtimeEntityType.AddProperty(
                "NullableInt64Array",
                typeof(long?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                keyComparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<long?>(new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v)));
            nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8 = runtimeEntityType.AddProperty(
                "NullableInt8",
                typeof(sbyte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8.TypeMapping = SqlServerShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                keyComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                converter: new ValueConverter<sbyte, short>(
                    (sbyte v) => (short)v,
                    (short v) => (sbyte)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v)));
            nullableInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableInt8Array = runtimeEntityType.AddProperty(
                "NullableInt8Array",
                typeof(sbyte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                keyComparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    converter: new ValueConverter<sbyte, short>(
                        (sbyte v) => (short)v,
                        (short v) => (sbyte)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<sbyte, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<sbyte, short>(
                            (sbyte v) => (short)v,
                            (short v) => (sbyte)v))));
            nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                "NullablePhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            nullablePhysicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                "NullablePhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));
            nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableString = runtimeEntityType.AddProperty(
                "NullableString",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableString.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            nullableString.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableStringArray = runtimeEntityType.AddProperty(
                "NullableStringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableStringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnly = runtimeEntityType.AddProperty(
                "NullableTimeOnly",
                typeof(TimeOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)),
                keyComparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)),
                providerValueComparer: new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>)));
            nullableTimeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                "NullableTimeOnlyArray",
                typeof(TimeOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                keyComparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v)));
            nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpan = runtimeEntityType.AddProperty(
                "NullableTimeSpan",
                typeof(TimeSpan?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                keyComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                providerValueComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)));
            nullableTimeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                "NullableTimeSpanArray",
                typeof(TimeSpan?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                keyComparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v)));
            nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16 = runtimeEntityType.AddProperty(
                "NullableUInt16",
                typeof(ushort?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                keyComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    (ushort v) => (int)v,
                    (int v) => (ushort)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v)));
            nullableUInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt16Array = runtimeEntityType.AddProperty(
                "NullableUInt16Array",
                typeof(ushort?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                keyComparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort?>(new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))));
            nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32 = runtimeEntityType.AddProperty(
                "NullableUInt32",
                typeof(uint?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<uint, long>(
                    (uint v) => (long)v,
                    (long v) => (uint)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v)));
            nullableUInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt32Array = runtimeEntityType.AddProperty(
                "NullableUInt32Array",
                typeof(uint?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                keyComparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint?>(new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))));
            nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64 = runtimeEntityType.AddProperty(
                "NullableUInt64",
                typeof(ulong?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>)),
                keyComparer: new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>)),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    (ulong v) => (decimal)v,
                    (decimal v) => (ulong)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v)));
            nullableUInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt64Array = runtimeEntityType.AddProperty(
                "NullableUInt64Array",
                typeof(ulong?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                keyComparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong?>(new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))));
            nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8 = runtimeEntityType.AddProperty(
                "NullableUInt8",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)));
            nullableUInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUInt8Array = runtimeEntityType.AddProperty(
                "NullableUInt8Array",
                typeof(byte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                keyComparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte?>(new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUri = runtimeEntityType.AddProperty(
                "NullableUri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            nullableUri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var nullableUriArray = runtimeEntityType.AddProperty(
                "NullableUriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddress = runtimeEntityType.AddProperty(
                "PhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddress.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(20)",
                    size: 20,
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));
            physicalAddress.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var physicalAddressArray = runtimeEntityType.AddProperty(
                "PhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddressArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(20)",
                        size: 20,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));
            physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var @string = runtimeEntityType.AddProperty(
                "String",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            @string.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            @string.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var stringArray = runtimeEntityType.AddProperty(
                "StringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnly = runtimeEntityType.AddProperty(
                "TimeOnly",
                typeof(TimeOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeOnly(0, 0, 0));
            timeOnly.TypeMapping = SqlServerTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v));
            timeOnly.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeOnlyArray = runtimeEntityType.AddProperty(
                "TimeOnlyArray",
                typeof(TimeOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeOnlyArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                keyComparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqlServerTimeOnlyTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    keyComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v),
                    providerValueComparer: new ValueComparer<TimeOnly>(
                        (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                        (TimeOnly v) => v.GetHashCode(),
                        (TimeOnly v) => v)));
            timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpan = runtimeEntityType.AddProperty(
                "TimeSpan",
                typeof(TimeSpan),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeSpan(0, 0, 0, 0, 0));
            timeSpan.TypeMapping = SqlServerTimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v));
            timeSpan.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var timeSpanArray = runtimeEntityType.AddProperty(
                "TimeSpanArray",
                typeof(TimeSpan[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeSpanArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                keyComparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: SqlServerTimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v)));
            timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16 = runtimeEntityType.AddProperty(
                "UInt16",
                typeof(ushort),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            uInt16.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<ushort, int>(
                    (ushort v) => (int)v,
                    (int v) => (ushort)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v)));
            uInt16.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt16Array = runtimeEntityType.AddProperty(
                "UInt16Array",
                typeof(ushort[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt16Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                keyComparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    converter: new ValueConverter<ushort, int>(
                        (ushort v) => (int)v,
                        (int v) => (ushort)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ushort, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<ushort, int>(
                            (ushort v) => (int)v,
                            (int v) => (ushort)v))));
            uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32 = runtimeEntityType.AddProperty(
                "UInt32",
                typeof(uint),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            uInt32.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                converter: new ValueConverter<uint, long>(
                    (uint v) => (long)v,
                    (long v) => (uint)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v)));
            uInt32.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt32Array = runtimeEntityType.AddProperty(
                "UInt32Array",
                typeof(uint[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt32Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                keyComparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))),
                elementMapping: SqlServerLongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    converter: new ValueConverter<uint, long>(
                        (uint v) => (long)v,
                        (long v) => (uint)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<uint, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<uint, long>(
                            (uint v) => (long)v,
                            (long v) => (uint)v))));
            uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64 = runtimeEntityType.AddProperty(
                "UInt64",
                typeof(ulong),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0ul);
            uInt64.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    (ulong v) => (decimal)v,
                    (decimal v) => (ulong)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v)));
            uInt64.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt64Array = runtimeEntityType.AddProperty(
                "UInt64Array",
                typeof(ulong[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt64Array.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                keyComparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v)))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))),
                elementMapping: SqlServerDecimalTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    keyComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    providerValueComparer: new ValueComparer<decimal>(
                        (decimal v1, decimal v2) => v1 == v2,
                        (decimal v) => v.GetHashCode(),
                        (decimal v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "decimal(20,0)",
                        precision: 20,
                        scale: 0),
                    converter: new ValueConverter<ulong, decimal>(
                        (ulong v) => (decimal)v,
                        (decimal v) => (ulong)v),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                        JsonDecimalReaderWriter.Instance,
                        new ValueConverter<ulong, decimal>(
                            (ulong v) => (decimal)v,
                            (decimal v) => (ulong)v))));
            uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8 = runtimeEntityType.AddProperty(
                "UInt8",
                typeof(byte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (byte)0);
            uInt8.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v));
            uInt8.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uInt8Array = runtimeEntityType.AddProperty(
                "UInt8Array",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt8Array.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            uInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uri = runtimeEntityType.AddProperty(
                "Uri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uri.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
            uri.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var uriArray = runtimeEntityType.AddProperty(
                "UriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uriArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
            uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyTypes");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalBase");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var alternateId = runtimeEntityType.AddProperty(
                "AlternateId",
                typeof(Guid),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"),
                jsonValueReaderWriter: new CSharpRuntimeModelCodeGeneratorTest.MyJsonGuidReaderWriter());
            alternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            alternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var discriminator = runtimeEntityType.AddProperty(
                "Discriminator",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                maxLength: 55,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            discriminator.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(55)",
                    size: 55,
                    dbType: System.Data.DbType.String));
            discriminator.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AnEnum)0);
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)6);
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var point = runtimeEntityType.AddProperty(
                "Point",
                typeof(Point),
                nullable: true,
                valueGenerated: ValueGenerated.OnAdd,
                valueConverter: new CastingConverter<Point, Point>(),
                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>(),
                providerValueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
            point.TypeMapping = null;
            point.AddAnnotation("Relational:ColumnType", "geometry");
            point.AddAnnotation("Relational:DefaultValue", (NetTopologySuite.Geometries.Point)new NetTopologySuite.IO.WKTReader().Read("SRID=0;POINT Z(0 0 0)"));
            point.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });

            var key0 = runtimeEntityType.AddKey(
                new[] { id, alternateId });
            runtimeEntityType.SetPrimaryKey(key0);
            key0.AddAnnotation("Relational:Name", "PK");

            var index = runtimeEntityType.AddIndex(
                new[] { alternateId, id });

            return runtimeEntityType;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Deriveds",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("PrincipalsId"), joinEntityType.FindProperty("PrincipalsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var inverse = targetEntityType.FindSkipNavigation("Principals");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedTypeEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class OwnedTypeEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true,
                changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalBaseId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalBaseId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalBaseAlternateId = runtimeEntityType.AddProperty(
                "PrincipalBaseAlternateId",
                typeof(Guid),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalBaseAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalBaseAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            details.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            details.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            number.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalBaseId, principalBaseAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true,
                ownership: true);

            var owned = principalEntityType.AddNavigation("Owned",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:ContainerColumnName", "Owned");
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedType0EntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class OwnedType0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true);

            var principalDerivedId = runtimeEntityType.AddProperty(
                "PrincipalDerivedId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalDerivedId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalDerivedId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                "PrincipalDerivedAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalDerivedAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalDerivedAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            details.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                storeTypePostfix: StoreTypePostfix.None);
            details.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            number.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalDerivedId, principalDerivedAlternateId, id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalDerivedId"), declaringEntityType.FindProperty("PrincipalDerivedAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var manyOwned = principalEntityType.AddNavigation("ManyOwned",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.OwnedType>),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("ManyOwned", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:ContainerColumnName", "ManyOwned");
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBasePrincipalDerivedDependentBasebyteEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var derivedsId = runtimeEntityType.AddProperty(
                "DerivedsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            derivedsId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var derivedsAlternateId = runtimeEntityType.AddProperty(
                "DerivedsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            derivedsAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalsId = runtimeEntityType.AddProperty(
                "PrincipalsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v));
            principalsId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalsAlternateId = runtimeEntityType.AddProperty(
                "PrincipalsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsAlternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            principalsAlternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var rowid = runtimeEntityType.AddProperty(
                "rowid",
                typeof(byte[]),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            rowid.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(v1, v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(v),
                    (Byte[] v) => v.ToArray()),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "rowversion",
                    size: 8),
                storeTypePostfix: StoreTypePostfix.None);
            rowid.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalsId, principalsAlternateId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("DerivedsId"), declaringEntityType.FindProperty("DerivedsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalsId"), declaringEntityType.FindProperty("PrincipalsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientCascade,
                required: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBasePrincipalDerived<DependentBase<byte?>>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DependentDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.Two);

            var data = runtimeEntityType.AddProperty(
                "Data",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetProperty("Data", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetField("<Data>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 20,
                unicode: false);
            data.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "char(20)",
                    size: 20,
                    dbType: System.Data.DbType.AnsiStringFixedLength));
            data.AddAnnotation("Relational:IsFixedLength", true);
            data.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var money = runtimeEntityType.AddProperty(
                "Money",
                typeof(decimal),
                precision: 9,
                scale: 3,
                sentinel: 0m);
            money.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(9,3)",
                    precision: 9,
                    scale: 3));
            money.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalDerived<DependentBase<byte?>>");

            return runtimeEntityType;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Principals",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("DerivedsId"), joinEntityType.FindProperty("DerivedsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Principals", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Principals>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            var inverse = targetEntityType.FindSkipNavigation("Deriveds");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetCollation()).Message);
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.MaxIdentifierLength, SqlServerAnnotationNames.ValueGenerationStrategy },
                        model.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(SqlServerValueGenerationStrategy.IdentityColumn, model.GetValueGenerationStrategy());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPropertyAccessMode()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.IdentitySeed]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetIdentitySeed()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.IdentityIncrement]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetIdentityIncrement()).Message);

                    var manyTypesType = model.FindEntityType(typeof(ManyTypes));

                    Assert.Equal(typeof(ManyTypes).FullName, manyTypesType.Name);
                    Assert.False(manyTypesType.HasSharedClrType);
                    Assert.False(manyTypesType.IsPropertyBag);
                    Assert.False(manyTypesType.IsOwned());
                    Assert.IsType<ConstructorBinding>(manyTypesType.ConstructorBinding);
                    Assert.Null(manyTypesType.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, manyTypesType.GetChangeTrackingStrategy());
                    Assert.Equal("ManyTypes", manyTypesType.GetTableName());
                    Assert.Null(manyTypesType.GetSchema());

                    Assert.Null(model.FindEntityType(typeof(AbstractBase)));
                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    Assert.Equal(typeof(PrincipalBase).FullName, principalBase.Name);
                    Assert.False(principalBase.HasSharedClrType);
                    Assert.False(principalBase.IsPropertyBag);
                    Assert.False(principalBase.IsOwned());
                    Assert.Null(principalBase.BaseType);
                    Assert.IsType<ConstructorBinding>(principalBase.ConstructorBinding);
                    Assert.Null(principalBase.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalBase.GetChangeTrackingStrategy());
                    Assert.Null(principalBase.GetQueryFilter());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Null(principalBase.GetSchema());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalBase.GetSeedData()).Message);

                    var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id));
                    Assert.Equal(
                        new[] { SqlServerAnnotationNames.ValueGenerationStrategy },
                        principalId.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(long?), principalId.ClrType);
                    Assert.Equal(typeof(long?), principalId.PropertyInfo.PropertyType);
                    Assert.Equal(typeof(long?), principalId.FieldInfo.FieldType);
                    Assert.False(principalId.IsNullable);
                    Assert.Equal(ValueGenerated.Never, principalId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, principalId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, principalId.GetBeforeSaveBehavior());
                    Assert.Null(principalId[CoreAnnotationNames.BeforeSaveBehavior]);
                    Assert.Null(principalId[CoreAnnotationNames.AfterSaveBehavior]);
                    Assert.Equal("Id", principalId.GetColumnName());
                    Assert.Equal("bigint", principalId.GetColumnType());
                    Assert.Null(principalId.GetValueConverter());
                    Assert.NotNull(principalId.GetValueComparer());
                    Assert.NotNull(principalId.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, principalId.GetValueGenerationStrategy());
                    Assert.Null(principalId[SqlServerAnnotationNames.IdentitySeed]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed()).Message);
                    Assert.Null(principalId[SqlServerAnnotationNames.IdentityIncrement]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement()).Message);

                    var pointProperty = principalBase.FindProperty("Point");
                    Assert.Equal(typeof(Point), pointProperty.ClrType);
                    Assert.True(pointProperty.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, pointProperty.ValueGenerated);
                    Assert.Equal("Point", pointProperty.GetColumnName());
                    Assert.Equal("geometry", pointProperty.GetColumnType());
                    Assert.Equal(0, ((Point)pointProperty.GetDefaultValue()).SRID);
                    Assert.IsType<CastingConverter<Point, Point>>(pointProperty.GetValueConverter());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetKeyValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetProviderValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, pointProperty.GetValueGenerationStrategy());
                    Assert.Null(pointProperty[CoreAnnotationNames.PropertyAccessMode]);

                    var discriminatorProperty = principalBase.FindDiscriminatorProperty();
                    Assert.Equal("Discriminator", discriminatorProperty.Name);
                    Assert.Equal(typeof(string), discriminatorProperty.ClrType);

                    var principalAlternateId = principalBase.FindProperty(nameof(PrincipalBase.AlternateId));
                    var compositeIndex = principalBase.GetIndexes().Single();
                    Assert.Equal(PropertyAccessMode.FieldDuringConstruction, principalAlternateId.GetPropertyAccessMode());
                    Assert.Empty(compositeIndex.GetAnnotations());
                    Assert.Equal(new[] { principalAlternateId, principalId }, compositeIndex.Properties);
                    Assert.False(compositeIndex.IsUnique);
                    Assert.Null(compositeIndex.Name);
                    Assert.Equal("IX_PrincipalBase_AlternateId_Id", compositeIndex.GetDatabaseName());

                    Assert.Equal(new[] { compositeIndex }, principalAlternateId.GetContainingIndexes());

                    Assert.Equal(2, principalBase.GetKeys().Count());

                    var principalAlternateKey = principalBase.GetKeys().First();
                    Assert.Same(principalId, principalAlternateKey.Properties.Single());
                    Assert.False(principalAlternateKey.IsPrimaryKey());
                    Assert.Equal("AK_PrincipalBase_Id", principalAlternateKey.GetName());

                    var principalKey = principalBase.GetKeys().Last();
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.Name },
                        principalKey.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(new[] { principalId, principalAlternateId }, principalKey.Properties);
                    Assert.True(principalKey.IsPrimaryKey());
                    Assert.Equal("PK", principalKey.GetName());
                    Assert.Null(principalKey[SqlServerAnnotationNames.Clustered]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalKey.IsClustered()).Message);

                    Assert.Equal(new[] { principalAlternateKey, principalKey }, principalId.GetContainingKeys());

                    var referenceOwnedNavigation = principalBase.GetNavigations().Single();
                    Assert.Equal(
                        new[] { CoreAnnotationNames.EagerLoaded },
                        referenceOwnedNavigation.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.Name);
                    Assert.False(referenceOwnedNavigation.IsCollection);
                    Assert.True(referenceOwnedNavigation.IsEagerLoaded);
                    Assert.False(referenceOwnedNavigation.IsOnDependent);
                    Assert.Equal(typeof(OwnedType), referenceOwnedNavigation.ClrType);
                    Assert.Equal("_ownedField", referenceOwnedNavigation.FieldInfo.Name);
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.PropertyInfo.Name);
                    Assert.Null(referenceOwnedNavigation.Inverse);
                    Assert.Equal(principalBase, referenceOwnedNavigation.DeclaringEntityType);
                    Assert.Equal(PropertyAccessMode.Field, referenceOwnedNavigation.GetPropertyAccessMode());
                    Assert.Null(referenceOwnedNavigation[CoreAnnotationNames.PropertyAccessMode]);

                    var referenceOwnedType = referenceOwnedNavigation.TargetEntityType;
                    Assert.Equal(typeof(PrincipalBase).FullName + ".Owned#OwnedType", referenceOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), referenceOwnedType.ClrType);
                    Assert.True(referenceOwnedType.HasSharedClrType);
                    Assert.False(referenceOwnedType.IsPropertyBag);
                    Assert.True(referenceOwnedType.IsOwned());
                    Assert.Null(referenceOwnedType.BaseType);
                    Assert.False(referenceOwnedType.IsMemoryOptimized());
                    Assert.IsType<ConstructorBinding>(referenceOwnedType.ConstructorBinding);
                    Assert.Null(referenceOwnedType.FindIndexerPropertyInfo());
                    Assert.Equal(
                        ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                        referenceOwnedType.GetChangeTrackingStrategy());
                    Assert.Null(referenceOwnedType.GetQueryFilter());
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.PropertyAccessMode]);
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.NavigationAccessMode]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetPropertyAccessMode()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetNavigationAccessMode()).Message);

                    var principalTable = StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value;

                    var ownedId = referenceOwnedType.FindProperty("PrincipalBaseId");
                    Assert.True(ownedId.IsPrimaryKey());
                    Assert.Equal(
                        SqlServerValueGenerationStrategy.None,
                        principalId.GetValueGenerationStrategy(principalTable));
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentityIncrement(principalTable)).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalId.GetIdentitySeed(principalTable)).Message);

                    var detailsProperty = referenceOwnedType.FindProperty(nameof(OwnedType.Details));
                    Assert.Null(detailsProperty[SqlServerAnnotationNames.Sparse]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.IsSparse()).Message);
                    Assert.Null(detailsProperty[RelationalAnnotationNames.Collation]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetCollation()).Message);

                    Assert.Null(detailsProperty.GetColumnName(principalTable));

                    var referenceOwnership = referenceOwnedNavigation.ForeignKey;
                    Assert.Empty(referenceOwnership.GetAnnotations());
                    Assert.Same(referenceOwnership, referenceOwnedType.FindOwnership());
                    Assert.True(referenceOwnership.IsOwnership);
                    Assert.True(referenceOwnership.IsRequired);
                    Assert.True(referenceOwnership.IsRequiredDependent);
                    Assert.True(referenceOwnership.IsUnique);
                    Assert.Null(referenceOwnership.DependentToPrincipal);
                    Assert.Same(referenceOwnedNavigation, referenceOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, referenceOwnership.DeleteBehavior);
                    Assert.Equal(2, referenceOwnership.Properties.Count());
                    Assert.Same(principalKey, referenceOwnership.PrincipalKey);

                    var ownedServiceProperty = referenceOwnedType.GetServiceProperties().Single();
                    Assert.Empty(ownedServiceProperty.GetAnnotations());
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.ClrType);
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.PropertyInfo.PropertyType);
                    Assert.Null(ownedServiceProperty.FieldInfo);
                    Assert.Same(referenceOwnedType, ownedServiceProperty.DeclaringEntityType);
                    var ownedServicePropertyBinding = ownedServiceProperty.ParameterBinding;
                    Assert.IsType<ContextParameterBinding>(ownedServicePropertyBinding);
                    Assert.Equal(typeof(DbContext), ownedServicePropertyBinding.ServiceType);
                    Assert.Equal(ownedServiceProperty, ownedServicePropertyBinding.ConsumedProperties.Single());
                    Assert.Equal(PropertyAccessMode.PreferField, ownedServiceProperty.GetPropertyAccessMode());
                    Assert.Null(ownedServiceProperty[CoreAnnotationNames.PropertyAccessMode]);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);
                    Assert.Equal(
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+"
                        + "PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                        principalDerived.Name);
                    Assert.False(principalDerived.IsOwned());
                    Assert.IsType<ConstructorBinding>(principalDerived.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalDerived.GetChangeTrackingStrategy());
                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.True(dependentNavigation.IsEagerLoaded);
                    Assert.False(dependentNavigation.LazyLoadingEnabled);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var ownedCollectionNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.Name);
                    Assert.Null(ownedCollectionNavigation.PropertyInfo);
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<OwnedType>), ownedCollectionNavigation.ClrType);
                    Assert.True(ownedCollectionNavigation.IsCollection);
                    Assert.True(ownedCollectionNavigation.IsEagerLoaded);
                    Assert.False(ownedCollectionNavigation.IsOnDependent);
                    Assert.Null(ownedCollectionNavigation.Inverse);
                    Assert.Equal(principalDerived, ownedCollectionNavigation.DeclaringEntityType);

                    var collectionOwnedType = ownedCollectionNavigation.TargetEntityType;
                    Assert.Equal(principalDerived.Name + ".ManyOwned#OwnedType", collectionOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), collectionOwnedType.ClrType);
                    Assert.True(collectionOwnedType.HasSharedClrType);
                    Assert.False(collectionOwnedType.IsPropertyBag);
                    Assert.True(collectionOwnedType.IsOwned());
                    Assert.False(collectionOwnedType.IsMemoryOptimized());
                    Assert.Null(collectionOwnedType[RelationalAnnotationNames.IsTableExcludedFromMigrations]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => collectionOwnedType.IsTableExcludedFromMigrations()).Message);
                    Assert.Null(collectionOwnedType.BaseType);
                    Assert.IsType<ConstructorBinding>(collectionOwnedType.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, collectionOwnedType.GetChangeTrackingStrategy());

                    var collectionOwnership = ownedCollectionNavigation.ForeignKey;
                    Assert.Same(collectionOwnership, collectionOwnedType.FindOwnership());
                    Assert.True(collectionOwnership.IsOwnership);
                    Assert.True(collectionOwnership.IsRequired);
                    Assert.False(collectionOwnership.IsRequiredDependent);
                    Assert.False(collectionOwnership.IsUnique);
                    Assert.Null(collectionOwnership.DependentToPrincipal);
                    Assert.Same(ownedCollectionNavigation, collectionOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, collectionOwnership.DeleteBehavior);
                    Assert.Equal(2, collectionOwnership.Properties.Count());

                    var derivedSkipNavigation = principalDerived.GetDeclaredSkipNavigations().Single();
                    Assert.Equal("Principals", derivedSkipNavigation.Name);
                    Assert.Equal("Principals", derivedSkipNavigation.PropertyInfo.Name);
                    Assert.Equal("<Principals>k__BackingField", derivedSkipNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<PrincipalBase>), derivedSkipNavigation.ClrType);
                    Assert.True(derivedSkipNavigation.IsCollection);
                    Assert.True(derivedSkipNavigation.IsEagerLoaded);
                    Assert.False(derivedSkipNavigation.LazyLoadingEnabled);
                    Assert.False(derivedSkipNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, derivedSkipNavigation.DeclaringEntityType);
                    Assert.Equal("Deriveds", derivedSkipNavigation.Inverse.Name);
                    Assert.Same(principalBase.GetSkipNavigations().Single(), derivedSkipNavigation.Inverse);

                    Assert.Same(derivedSkipNavigation, derivedSkipNavigation.ForeignKey.GetReferencingSkipNavigations().Single());
                    Assert.Same(
                        derivedSkipNavigation.Inverse, derivedSkipNavigation.Inverse.ForeignKey.GetReferencingSkipNavigations().Single());

                    Assert.Equal(new[] { derivedSkipNavigation.Inverse, derivedSkipNavigation }, principalDerived.GetSkipNavigations());

                    var joinType = derivedSkipNavigation.JoinEntityType;

                    Assert.Equal("PrincipalBasePrincipalDerived<DependentBase<byte?>>", joinType.Name);
                    Assert.Equal(typeof(Dictionary<string, object>), joinType.ClrType);
                    Assert.True(joinType.HasSharedClrType);
                    Assert.True(joinType.IsPropertyBag);
                    Assert.False(joinType.IsOwned());
                    Assert.Null(joinType.BaseType);
                    Assert.IsType<ConstructorBinding>(joinType.ConstructorBinding);
                    Assert.Equal("Item", joinType.FindIndexerPropertyInfo().Name);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, joinType.GetChangeTrackingStrategy());
                    Assert.Null(joinType[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => joinType.GetComment()).Message);
                    Assert.Null(joinType.GetQueryFilter());

                    var rowid = joinType.GetProperties().Single(p => !p.IsForeignKey());
                    Assert.Equal(typeof(byte[]), rowid.ClrType);
                    Assert.True(rowid.IsIndexerProperty());
                    Assert.Same(joinType.FindIndexerPropertyInfo(), rowid.PropertyInfo);
                    Assert.Null(rowid.FieldInfo);
                    Assert.True(rowid.IsNullable);
                    Assert.False(rowid.IsShadowProperty());
                    Assert.True(rowid.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, rowid.ValueGenerated);
                    Assert.Equal("rowid", rowid.GetColumnName());
                    Assert.Equal("rowversion", rowid.GetColumnType());
                    Assert.Null(rowid[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetComment()).Message);
                    Assert.Null(rowid[RelationalAnnotationNames.ColumnOrder]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetColumnOrder()).Message);
                    Assert.Null(rowid.GetValueConverter());
                    Assert.NotNull(rowid.GetValueComparer());
                    Assert.NotNull(rowid.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, rowid.GetValueGenerationStrategy());

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.True(dependentForeignKey.IsRequired);
                    Assert.False(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientNoAction, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId", "PrincipalAlternateId" }, dependentForeignKey.Properties.Select(p => p.Name));
                    Assert.Same(principalKey, dependentForeignKey.PrincipalKey);

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.False(dependentBase.GetIsDiscriminatorMappingComplete());
                    var principalDiscriminator = dependentBase.FindDiscriminatorProperty();
                    Assert.IsType<DiscriminatorValueGenerator>(
                        principalDiscriminator.GetValueGeneratorFactory()(principalDiscriminator, dependentBase));
                    Assert.Equal(Enum1.One, dependentBase.GetDiscriminatorValue());

                    var dependentBaseForeignKey = dependentBase.GetForeignKeys().Single(fk => fk != dependentForeignKey);
                    var dependentForeignKeyProperty = dependentBaseForeignKey.Properties.Single();

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, dependentForeignKey }, dependentForeignKeyProperty.GetContainingForeignKeys());

                    var dependentDerived = dependentBase.GetDerivedTypes().Single();
                    Assert.Equal(Enum1.Two, dependentDerived.GetDiscriminatorValue());

                    Assert.Equal(2, dependentDerived.GetDeclaredProperties().Count());

                    var dependentData = dependentDerived.GetDeclaredProperties().First();
                    Assert.Equal(typeof(string), dependentData.ClrType);
                    Assert.Equal("Data", dependentData.Name);
                    Assert.Equal("Data", dependentData.PropertyInfo.Name);
                    Assert.Equal("<Data>k__BackingField", dependentData.FieldInfo.Name);
                    Assert.True(dependentData.IsNullable);
                    Assert.False(dependentData.IsShadowProperty());
                    Assert.False(dependentData.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentData.ValueGenerated);
                    Assert.Equal("Data", dependentData.GetColumnName());
                    Assert.Equal("char(20)", dependentData.GetColumnType());
                    Assert.Equal(20, dependentData.GetMaxLength());
                    Assert.False(dependentData.IsUnicode());
                    Assert.True(dependentData.IsFixedLength());
                    Assert.Null(dependentData.GetPrecision());
                    Assert.Null(dependentData.GetScale());

                    var dependentMoney = dependentDerived.GetDeclaredProperties().Last();
                    Assert.Equal(typeof(decimal), dependentMoney.ClrType);
                    Assert.Equal("Money", dependentMoney.Name);
                    Assert.Null(dependentMoney.PropertyInfo);
                    Assert.Null(dependentMoney.FieldInfo);
                    Assert.False(dependentMoney.IsNullable);
                    Assert.True(dependentMoney.IsShadowProperty());
                    Assert.False(dependentMoney.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentMoney.ValueGenerated);
                    Assert.Equal("Money", dependentMoney.GetColumnName());
                    Assert.Equal("decimal(9,3)", dependentMoney.GetColumnType());
                    Assert.Null(dependentMoney.GetMaxLength());
                    Assert.Null(dependentMoney.IsUnicode());
                    Assert.Null(dependentMoney.IsFixedLength());
                    Assert.Equal(9, dependentMoney.GetPrecision());
                    Assert.Equal(3, dependentMoney.GetScale());

                    Assert.Equal(
                        new[]
                        {
                            derivedSkipNavigation.ForeignKey,
                            referenceOwnership,
                            collectionOwnership,
                            dependentForeignKey,
                            derivedSkipNavigation.Inverse.ForeignKey
                        },
                        principalKey.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, referenceOwnership, derivedSkipNavigation.Inverse.ForeignKey },
                        principalBase.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { derivedSkipNavigation.ForeignKey, collectionOwnership, dependentForeignKey },
                        principalDerived.GetDeclaredReferencingForeignKeys());

                    Assert.Equal(
                        new[]
                        {
                            dependentBase,
                            dependentDerived,
                            manyTypesType,
                            principalBase,
                            referenceOwnedType,
                            principalDerived,
                            collectionOwnedType,
                            joinType
                        },
                        model.GetEntityTypes());
                },
                typeof(SqlServerNetTopologySuiteDesignTimeServices),
                c =>
                {
                    c.Set<PrincipalDerived<DependentBase<byte?>>>().Add(
                        new PrincipalDerived<DependentBase<byte?>>
                        {
                            Id = 1,
                            AlternateId = new Guid(),
                            Dependent = new DependentBase<byte?>(1),
                            Owned = new OwnedType(c)
                        });

                    c.SaveChanges();
                });

        [ConditionalFact]
        [SqlServerConfiguredCondition]
        public void ComplexTypes()
            => Test(
                new ComplexTypesContext(),
                new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ComplexTypesContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ComplexTypesContext))]
    public partial class ComplexTypesContextModel : RuntimeModel
    {
        static ComplexTypesContextModel()
        {
            var model = new ComplexTypesContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static ComplexTypesContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ComplexTypesContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ComplexTypesContextModel
    {
        partial void Initialize()
        {
            var principalBase = PrincipalBaseEntityType.Create(this);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            PrincipalBaseEntityType.CreateForeignKey1(principalBase, principalBase);

            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            var functions = new SortedDictionary<string, IDbFunction>();
            var principalBaseTvf = new RuntimeDbFunction(
                "PrincipalBaseTvf",
                this,
                typeof(IQueryable<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                "PrincipalBaseTvf",
                schema: "dbo");

            functions["PrincipalBaseTvf"] = principalBaseTvf;

            AddAnnotation("Relational:DbFunctions", functions);
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            principalBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", null, relationalModel);
            var discriminatorColumnBase = new ColumnBase<ColumnMappingBase>("Discriminator", "nvarchar(55)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Discriminator", discriminatorColumnBase);
            var enum1ColumnBase = new ColumnBase<ColumnMappingBase>("Enum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum1", enum1ColumnBase);
            var enum2ColumnBase = new ColumnBase<ColumnMappingBase>("Enum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum2", enum2ColumnBase);
            var flagsEnum1ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase);
            var flagsEnum2ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Id", idColumnBase);
            var principalBaseIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("PrincipalBaseId", principalBaseIdColumnBase);
            var refTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase);
            var refTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase);
            var refTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase);
            var refTypeListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeList", refTypeListColumnBase);
            var valueTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase);
            var valueTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase);
            var valueTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase);
            var valueTypeListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase = new TableMappingBase<ColumnMappingBase>(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)discriminatorColumnBase, principalBase.FindProperty("Discriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase, principalBase.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);

            var tableMappings = new List<TableMapping>();
            principalBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var principalBaseTable = new Table("PrincipalBase", null, relationalModel);
            var idColumn = new Column("Id", "bigint", principalBaseTable);
            principalBaseTable.Columns.Add("Id", idColumn);
            var deetsColumn = new Column("Deets", "varchar(64)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Deets", deetsColumn);
            var discriminatorColumn = new Column("Discriminator", "nvarchar(55)", principalBaseTable);
            principalBaseTable.Columns.Add("Discriminator", discriminatorColumn);
            var enum1Column = new Column("Enum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Enum1", enum1Column);
            var enum2Column = new Column("Enum2", "int", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Enum2", enum2Column);
            var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
            var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
            var owned_NumberColumn = new Column("Owned_Number", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
            var owned_Principal_AlternateIdColumn = new Column("Owned_Principal_AlternateId", "uniqueidentifier", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Principal_AlternateId", owned_Principal_AlternateIdColumn);
            var owned_Principal_Enum1Column = new Column("Owned_Principal_Enum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Principal_Enum1", owned_Principal_Enum1Column);
            var owned_Principal_Enum2Column = new Column("Owned_Principal_Enum2", "int", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_Enum2", owned_Principal_Enum2Column);
            var owned_Principal_FlagsEnum1Column = new Column("Owned_Principal_FlagsEnum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Principal_FlagsEnum1", owned_Principal_FlagsEnum1Column);
            var owned_Principal_FlagsEnum2Column = new Column("Owned_Principal_FlagsEnum2", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Principal_FlagsEnum2", owned_Principal_FlagsEnum2Column);
            var owned_Principal_IdColumn = new Column("Owned_Principal_Id", "bigint", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_Id", owned_Principal_IdColumn);
            var owned_Principal_RefTypeArrayColumn = new Column("Owned_Principal_RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_RefTypeArray", owned_Principal_RefTypeArrayColumn);
            var owned_Principal_RefTypeEnumerableColumn = new Column("Owned_Principal_RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_RefTypeEnumerable", owned_Principal_RefTypeEnumerableColumn);
            var owned_Principal_RefTypeIListColumn = new Column("Owned_Principal_RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_RefTypeIList", owned_Principal_RefTypeIListColumn);
            var owned_Principal_RefTypeListColumn = new Column("Owned_Principal_RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_RefTypeList", owned_Principal_RefTypeListColumn);
            var owned_Principal_ValueTypeArrayColumn = new Column("Owned_Principal_ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_ValueTypeArray", owned_Principal_ValueTypeArrayColumn);
            var owned_Principal_ValueTypeEnumerableColumn = new Column("Owned_Principal_ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_ValueTypeEnumerable", owned_Principal_ValueTypeEnumerableColumn);
            var owned_Principal_ValueTypeIListColumn = new Column("Owned_Principal_ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_ValueTypeIList", owned_Principal_ValueTypeIListColumn);
            var owned_Principal_ValueTypeListColumn = new Column("Owned_Principal_ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_Principal_ValueTypeList", owned_Principal_ValueTypeListColumn);
            var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
            var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
            var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
            var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
            var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
            var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
            var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
            var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
            var principalBaseIdColumn = new Column("PrincipalBaseId", "bigint", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
            var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
            var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
            var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
            var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
            var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
            var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
            var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
            var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
            var pK_PrincipalBase = new UniqueConstraint("PK_PrincipalBase", principalBaseTable, new[] { idColumn });
            principalBaseTable.PrimaryKey = pK_PrincipalBase;
            var pK_PrincipalBaseUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            pK_PrincipalBase.MappedKeys.Add(pK_PrincipalBaseUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBaseUc).Add(pK_PrincipalBase);
            principalBaseTable.UniqueConstraints.Add("PK_PrincipalBase", pK_PrincipalBase);
            var iX_PrincipalBase_PrincipalBaseId = new TableIndex(
            "IX_PrincipalBase_PrincipalBaseId", principalBaseTable, new[] { principalBaseIdColumn }, false);
            var iX_PrincipalBase_PrincipalBaseIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "PrincipalBaseId" });
            iX_PrincipalBase_PrincipalBaseId.MappedIndexes.Add(iX_PrincipalBase_PrincipalBaseIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_PrincipalBaseIdIx).Add(iX_PrincipalBase_PrincipalBaseId);
            principalBaseTable.Indexes.Add("IX_PrincipalBase_PrincipalBaseId", iX_PrincipalBase_PrincipalBaseId);
            relationalModel.Tables.Add(("PrincipalBase", null), principalBaseTable);
            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
            tableMappings.Add(principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, principalBase.FindProperty("Id")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(discriminatorColumn, principalBase.FindProperty("Discriminator")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);

            var viewMappings = new List<ViewMapping>();
            principalBase.SetRuntimeAnnotation("Relational:ViewMappings", viewMappings);
            var principalBaseViewView = new View("PrincipalBaseView", null, relationalModel);
            var discriminatorViewColumn = new ViewColumn("Discriminator", "nvarchar(55)", principalBaseViewView);
            principalBaseViewView.Columns.Add("Discriminator", discriminatorViewColumn);
            var enum1ViewColumn = new ViewColumn("Enum1", "int", principalBaseViewView);
            principalBaseViewView.Columns.Add("Enum1", enum1ViewColumn);
            var enum2ViewColumn = new ViewColumn("Enum2", "int", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("Enum2", enum2ViewColumn);
            var flagsEnum1ViewColumn = new ViewColumn("FlagsEnum1", "int", principalBaseViewView);
            principalBaseViewView.Columns.Add("FlagsEnum1", flagsEnum1ViewColumn);
            var flagsEnum2ViewColumn = new ViewColumn("FlagsEnum2", "int", principalBaseViewView);
            principalBaseViewView.Columns.Add("FlagsEnum2", flagsEnum2ViewColumn);
            var idViewColumn = new ViewColumn("Id", "bigint", principalBaseViewView);
            principalBaseViewView.Columns.Add("Id", idViewColumn);
            var principalBaseIdViewColumn = new ViewColumn("PrincipalBaseId", "bigint", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("PrincipalBaseId", principalBaseIdViewColumn);
            var refTypeArrayViewColumn = new ViewColumn("RefTypeArray", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeArray", refTypeArrayViewColumn);
            var refTypeEnumerableViewColumn = new ViewColumn("RefTypeEnumerable", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeEnumerable", refTypeEnumerableViewColumn);
            var refTypeIListViewColumn = new ViewColumn("RefTypeIList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeIList", refTypeIListViewColumn);
            var refTypeListViewColumn = new ViewColumn("RefTypeList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeList", refTypeListViewColumn);
            var valueTypeArrayViewColumn = new ViewColumn("ValueTypeArray", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeArray", valueTypeArrayViewColumn);
            var valueTypeEnumerableViewColumn = new ViewColumn("ValueTypeEnumerable", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableViewColumn);
            var valueTypeIListViewColumn = new ViewColumn("ValueTypeIList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeIList", valueTypeIListViewColumn);
            var valueTypeListViewColumn = new ViewColumn("ValueTypeList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeList", valueTypeListViewColumn);
            relationalModel.Views.Add(("PrincipalBaseView", null), principalBaseViewView);
            var principalBaseViewViewMapping = new ViewMapping(principalBase, principalBaseViewView, true);
            principalBaseViewView.AddTypeMapping(principalBaseViewViewMapping, false);
            viewMappings.Add(principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(idViewColumn, principalBase.FindProperty("Id")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(discriminatorViewColumn, principalBase.FindProperty("Discriminator")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(enum1ViewColumn, principalBase.FindProperty("Enum1")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(enum2ViewColumn, principalBase.FindProperty("Enum2")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(flagsEnum1ViewColumn, principalBase.FindProperty("FlagsEnum1")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(flagsEnum2ViewColumn, principalBase.FindProperty("FlagsEnum2")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(principalBaseIdViewColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeArrayViewColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeEnumerableViewColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeIListViewColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeListViewColumn, principalBase.FindProperty("RefTypeList")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeArrayViewColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeEnumerableViewColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeIListViewColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeListViewColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseViewViewMapping);

            var sqlQueryMappings = new List<SqlQueryMapping>();
            principalBase.SetRuntimeAnnotation("Relational:SqlQueryMappings", sqlQueryMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery = new SqlQuery("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.MappedSqlQuery", relationalModel, "select * from PrincipalBase");
            var discriminatorSqlQueryColumn = new SqlQueryColumn("Discriminator", "nvarchar(55)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("Discriminator", discriminatorSqlQueryColumn);
            var enum1SqlQueryColumn = new SqlQueryColumn("Enum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("Enum1", enum1SqlQueryColumn);
            var enum2SqlQueryColumn = new SqlQueryColumn("Enum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("Enum2", enum2SqlQueryColumn);
            var flagsEnum1SqlQueryColumn = new SqlQueryColumn("FlagsEnum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("FlagsEnum1", flagsEnum1SqlQueryColumn);
            var flagsEnum2SqlQueryColumn = new SqlQueryColumn("FlagsEnum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("FlagsEnum2", flagsEnum2SqlQueryColumn);
            var idSqlQueryColumn = new SqlQueryColumn("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("Id", idSqlQueryColumn);
            var principalBaseIdSqlQueryColumn = new SqlQueryColumn("PrincipalBaseId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("PrincipalBaseId", principalBaseIdSqlQueryColumn);
            var refTypeArraySqlQueryColumn = new SqlQueryColumn("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("RefTypeArray", refTypeArraySqlQueryColumn);
            var refTypeEnumerableSqlQueryColumn = new SqlQueryColumn("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("RefTypeEnumerable", refTypeEnumerableSqlQueryColumn);
            var refTypeIListSqlQueryColumn = new SqlQueryColumn("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("RefTypeIList", refTypeIListSqlQueryColumn);
            var refTypeListSqlQueryColumn = new SqlQueryColumn("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("RefTypeList", refTypeListSqlQueryColumn);
            var valueTypeArraySqlQueryColumn = new SqlQueryColumn("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("ValueTypeArray", valueTypeArraySqlQueryColumn);
            var valueTypeEnumerableSqlQueryColumn = new SqlQueryColumn("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableSqlQueryColumn);
            var valueTypeIListSqlQueryColumn = new SqlQueryColumn("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("ValueTypeIList", valueTypeIListSqlQueryColumn);
            var valueTypeListSqlQueryColumn = new SqlQueryColumn("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.Columns.Add("ValueTypeList", valueTypeListSqlQueryColumn);
            relationalModel.Queries.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.MappedSqlQuery", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping = new SqlQueryMapping(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping, false);
            sqlQueryMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping.IsDefaultSqlQueryMapping = true;
            RelationalModel.CreateSqlQueryColumnMapping(idSqlQueryColumn, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(discriminatorSqlQueryColumn, principalBase.FindProperty("Discriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(enum1SqlQueryColumn, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(enum2SqlQueryColumn, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(flagsEnum1SqlQueryColumn, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(flagsEnum2SqlQueryColumn, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(principalBaseIdSqlQueryColumn, principalBase.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeArraySqlQueryColumn, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeEnumerableSqlQueryColumn, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeIListSqlQueryColumn, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeListSqlQueryColumn, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeArraySqlQueryColumn, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeEnumerableSqlQueryColumn, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeIListSqlQueryColumn, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeListSqlQueryColumn, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping);

            var functionMappings = new List<FunctionMapping>();
            principalBase.SetRuntimeAnnotation("Relational:FunctionMappings", functionMappings);
            var principalBaseTvf = (IRuntimeDbFunction)this.FindDbFunction("PrincipalBaseTvf")!;
            var principalBaseTvfFunction = new StoreFunction(principalBaseTvf, relationalModel);
            var discriminatorFunctionColumn = new FunctionColumn("Discriminator", "nvarchar(55)", principalBaseTvfFunction);
            principalBaseTvfFunction.Columns.Add("Discriminator", discriminatorFunctionColumn);
            var enum1FunctionColumn = new FunctionColumn("Enum1", "int", principalBaseTvfFunction);
            principalBaseTvfFunction.Columns.Add("Enum1", enum1FunctionColumn);
            var enum2FunctionColumn = new FunctionColumn("Enum2", "int", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("Enum2", enum2FunctionColumn);
            var flagsEnum1FunctionColumn = new FunctionColumn("FlagsEnum1", "int", principalBaseTvfFunction);
            principalBaseTvfFunction.Columns.Add("FlagsEnum1", flagsEnum1FunctionColumn);
            var flagsEnum2FunctionColumn = new FunctionColumn("FlagsEnum2", "int", principalBaseTvfFunction);
            principalBaseTvfFunction.Columns.Add("FlagsEnum2", flagsEnum2FunctionColumn);
            var idFunctionColumn = new FunctionColumn("Id", "bigint", principalBaseTvfFunction);
            principalBaseTvfFunction.Columns.Add("Id", idFunctionColumn);
            var principalBaseIdFunctionColumn = new FunctionColumn("PrincipalBaseId", "bigint", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("PrincipalBaseId", principalBaseIdFunctionColumn);
            var refTypeArrayFunctionColumn = new FunctionColumn("RefTypeArray", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("RefTypeArray", refTypeArrayFunctionColumn);
            var refTypeEnumerableFunctionColumn = new FunctionColumn("RefTypeEnumerable", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("RefTypeEnumerable", refTypeEnumerableFunctionColumn);
            var refTypeIListFunctionColumn = new FunctionColumn("RefTypeIList", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("RefTypeIList", refTypeIListFunctionColumn);
            var refTypeListFunctionColumn = new FunctionColumn("RefTypeList", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("RefTypeList", refTypeListFunctionColumn);
            var valueTypeArrayFunctionColumn = new FunctionColumn("ValueTypeArray", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("ValueTypeArray", valueTypeArrayFunctionColumn);
            var valueTypeEnumerableFunctionColumn = new FunctionColumn("ValueTypeEnumerable", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableFunctionColumn);
            var valueTypeIListFunctionColumn = new FunctionColumn("ValueTypeIList", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("ValueTypeIList", valueTypeIListFunctionColumn);
            var valueTypeListFunctionColumn = new FunctionColumn("ValueTypeList", "nvarchar(max)", principalBaseTvfFunction)
            {
                IsNullable = true
            };
            principalBaseTvfFunction.Columns.Add("ValueTypeList", valueTypeListFunctionColumn);
            relationalModel.Functions.Add(
                ("PrincipalBaseTvf", "dbo", new string[0]),
                principalBaseTvfFunction);
            var principalBaseTvfFunctionMapping = new FunctionMapping(principalBase, principalBaseTvfFunction, principalBaseTvf, true);
            principalBaseTvfFunction.AddTypeMapping(principalBaseTvfFunctionMapping, false);
            functionMappings.Add(principalBaseTvfFunctionMapping);
            principalBaseTvfFunctionMapping.IsDefaultFunctionMapping = true;
            RelationalModel.CreateFunctionColumnMapping(idFunctionColumn, principalBase.FindProperty("Id")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(discriminatorFunctionColumn, principalBase.FindProperty("Discriminator")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(enum1FunctionColumn, principalBase.FindProperty("Enum1")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(enum2FunctionColumn, principalBase.FindProperty("Enum2")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(flagsEnum1FunctionColumn, principalBase.FindProperty("FlagsEnum1")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(flagsEnum2FunctionColumn, principalBase.FindProperty("FlagsEnum2")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(principalBaseIdFunctionColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(refTypeArrayFunctionColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(refTypeEnumerableFunctionColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(refTypeIListFunctionColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(refTypeListFunctionColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(valueTypeArrayFunctionColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(valueTypeEnumerableFunctionColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(valueTypeIListFunctionColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTvfFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(valueTypeListFunctionColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTvfFunctionMapping);

            var deleteSprocMappings = new List<StoredProcedureMapping>();
            principalBase.SetRuntimeAnnotation("Relational:DeleteStoredProcedureMappings", deleteSprocMappings);
            var principalBase_DeleteStoreSproc = new StoreStoredProcedure("PrincipalBase_Delete", null, relationalModel);
            principalBase_DeleteStoreSproc.ReturnValue = new StoreStoredProcedureReturnValue("", "int", principalBase_DeleteStoreSproc);
            var id_OriginalParameter = new StoreStoredProcedureParameter("Id_Original", "bigint", 0, principalBase_DeleteStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_DeleteStoreSproc.AddParameter(id_OriginalParameter);
            principalBase_DeleteStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("PrincipalBase_Delete", null), principalBase_DeleteStoreSproc);
            var principalBase_DeleteDSproc = (IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!;
            var principalBase_DeleteSprocMapping = new StoredProcedureMapping(principalBase, principalBase_DeleteStoreSproc, (IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!, principalBaseTableMapping, true);
            principalBase_DeleteStoreSproc.AddTypeMapping(principalBase_DeleteSprocMapping, false);
            deleteSprocMappings.Add(principalBase_DeleteSprocMapping);
            principalBaseTableMapping.DeleteStoredProcedureMapping = principalBase_DeleteSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter, principalBase_DeleteDSproc.FindParameter("Id_Original")!, principalBase.FindProperty("Id")!, principalBase_DeleteSprocMapping);

            var insertSprocMappings = new List<StoredProcedureMapping>();
            principalBase.SetRuntimeAnnotation("Relational:InsertStoredProcedureMappings", insertSprocMappings);
            var principalBase_InsertStoreSproc = new StoreStoredProcedure("PrincipalBase_Insert", null, relationalModel);
            var principalBaseIdParameter = new StoreStoredProcedureParameter("PrincipalBaseId", "bigint", 0, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(principalBaseIdParameter);
            var enum1Parameter = new StoreStoredProcedureParameter("Enum1", "int", 1, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(enum1Parameter);
            var enum2Parameter = new StoreStoredProcedureParameter("Enum2", "int", 2, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(enum2Parameter);
            var flagsEnum1Parameter = new StoreStoredProcedureParameter("FlagsEnum1", "int", 3, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(flagsEnum1Parameter);
            var flagsEnum2Parameter = new StoreStoredProcedureParameter("FlagsEnum2", "int", 4, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(flagsEnum2Parameter);
            var valueTypeListParameter = new StoreStoredProcedureParameter("ValueTypeList", "nvarchar(max)", 5, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeListParameter);
            var valueTypeIListParameter = new StoreStoredProcedureParameter("ValueTypeIList", "nvarchar(max)", 6, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeIListParameter);
            var valueTypeArrayParameter = new StoreStoredProcedureParameter("ValueTypeArray", "nvarchar(max)", 7, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeArrayParameter);
            var valueTypeEnumerableParameter = new StoreStoredProcedureParameter("ValueTypeEnumerable", "nvarchar(max)", 8, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeEnumerableParameter);
            var refTypeListParameter = new StoreStoredProcedureParameter("RefTypeList", "nvarchar(max)", 9, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeListParameter);
            var refTypeIListParameter = new StoreStoredProcedureParameter("RefTypeIList", "nvarchar(max)", 10, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeIListParameter);
            var refTypeArrayParameter = new StoreStoredProcedureParameter("RefTypeArray", "nvarchar(max)", 11, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeArrayParameter);
            var refTypeEnumerableParameter = new StoreStoredProcedureParameter("RefTypeEnumerable", "nvarchar(max)", 12, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeEnumerableParameter);
            var discriminatorParameter = new StoreStoredProcedureParameter("Discriminator", "nvarchar(55)", 13, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(discriminatorParameter);
            var idParameter = new StoreStoredProcedureParameter("Id", "bigint", 14, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Output);
            principalBase_InsertStoreSproc.AddParameter(idParameter);
            principalBase_InsertStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("PrincipalBase_Insert", null), principalBase_InsertStoreSproc);
            var principalBase_InsertISproc = (IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!;
            var principalBase_InsertSprocMapping = new StoredProcedureMapping(principalBase, principalBase_InsertStoreSproc, (IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!, principalBaseTableMapping, true);
            principalBase_InsertStoreSproc.AddTypeMapping(principalBase_InsertSprocMapping, false);
            insertSprocMappings.Add(principalBase_InsertSprocMapping);
            principalBaseTableMapping.InsertStoredProcedureMapping = principalBase_InsertSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(idParameter, principalBase_InsertISproc.FindParameter("Id")!, principalBase.FindProperty("Id")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(discriminatorParameter, principalBase_InsertISproc.FindParameter("Discriminator")!, principalBase.FindProperty("Discriminator")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter, principalBase_InsertISproc.FindParameter("Enum1")!, principalBase.FindProperty("Enum1")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter, principalBase_InsertISproc.FindParameter("Enum2")!, principalBase.FindProperty("Enum2")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter, principalBase_InsertISproc.FindParameter("FlagsEnum1")!, principalBase.FindProperty("FlagsEnum1")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter, principalBase_InsertISproc.FindParameter("FlagsEnum2")!, principalBase.FindProperty("FlagsEnum2")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter, principalBase_InsertISproc.FindParameter("PrincipalBaseId")!, principalBase.FindProperty("PrincipalBaseId")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter, principalBase_InsertISproc.FindParameter("RefTypeArray")!, principalBase.FindProperty("RefTypeArray")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter, principalBase_InsertISproc.FindParameter("RefTypeEnumerable")!, principalBase.FindProperty("RefTypeEnumerable")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter, principalBase_InsertISproc.FindParameter("RefTypeIList")!, principalBase.FindProperty("RefTypeIList")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter, principalBase_InsertISproc.FindParameter("RefTypeList")!, principalBase.FindProperty("RefTypeList")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter, principalBase_InsertISproc.FindParameter("ValueTypeArray")!, principalBase.FindProperty("ValueTypeArray")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter, principalBase_InsertISproc.FindParameter("ValueTypeEnumerable")!, principalBase.FindProperty("ValueTypeEnumerable")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter, principalBase_InsertISproc.FindParameter("ValueTypeIList")!, principalBase.FindProperty("ValueTypeIList")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter, principalBase_InsertISproc.FindParameter("ValueTypeList")!, principalBase.FindProperty("ValueTypeList")!, principalBase_InsertSprocMapping);

            var updateSprocMappings = new List<StoredProcedureMapping>();
            principalBase.SetRuntimeAnnotation("Relational:UpdateStoredProcedureMappings", updateSprocMappings);
            var principalBase_UpdateStoreSproc = new StoreStoredProcedure("PrincipalBase_Update", null, relationalModel);
            var principalBaseIdParameter0 = new StoreStoredProcedureParameter("PrincipalBaseId", "bigint", 0, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(principalBaseIdParameter0);
            var enum1Parameter0 = new StoreStoredProcedureParameter("Enum1", "int", 1, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(enum1Parameter0);
            var enum2Parameter0 = new StoreStoredProcedureParameter("Enum2", "int", 2, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(enum2Parameter0);
            var flagsEnum1Parameter0 = new StoreStoredProcedureParameter("FlagsEnum1", "int", 3, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(flagsEnum1Parameter0);
            var flagsEnum2Parameter0 = new StoreStoredProcedureParameter("FlagsEnum2", "int", 4, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(flagsEnum2Parameter0);
            var valueTypeListParameter0 = new StoreStoredProcedureParameter("ValueTypeList", "nvarchar(max)", 5, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeListParameter0);
            var valueTypeIListParameter0 = new StoreStoredProcedureParameter("ValueTypeIList", "nvarchar(max)", 6, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeIListParameter0);
            var valueTypeArrayParameter0 = new StoreStoredProcedureParameter("ValueTypeArray", "nvarchar(max)", 7, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeArrayParameter0);
            var valueTypeEnumerableParameter0 = new StoreStoredProcedureParameter("ValueTypeEnumerable", "nvarchar(max)", 8, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeEnumerableParameter0);
            var refTypeListParameter0 = new StoreStoredProcedureParameter("RefTypeList", "nvarchar(max)", 9, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeListParameter0);
            var refTypeIListParameter0 = new StoreStoredProcedureParameter("RefTypeIList", "nvarchar(max)", 10, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeIListParameter0);
            var refTypeArrayParameter0 = new StoreStoredProcedureParameter("RefTypeArray", "nvarchar(max)", 11, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeArrayParameter0);
            var refTypeEnumerableParameter0 = new StoreStoredProcedureParameter("RefTypeEnumerable", "nvarchar(max)", 12, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeEnumerableParameter0);
            var id_OriginalParameter0 = new StoreStoredProcedureParameter("Id_Original", "bigint", 13, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(id_OriginalParameter0);
            principalBase_UpdateStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("PrincipalBase_Update", null), principalBase_UpdateStoreSproc);
            var principalBase_UpdateUSproc = (IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!;
            var principalBase_UpdateSprocMapping = new StoredProcedureMapping(principalBase, principalBase_UpdateStoreSproc, (IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!, principalBaseTableMapping, true);
            principalBase_UpdateStoreSproc.AddTypeMapping(principalBase_UpdateSprocMapping, false);
            updateSprocMappings.Add(principalBase_UpdateSprocMapping);
            principalBaseTableMapping.UpdateStoredProcedureMapping = principalBase_UpdateSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter0, principalBase_UpdateUSproc.FindParameter("Id_Original")!, principalBase.FindProperty("Id")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter0, principalBase_UpdateUSproc.FindParameter("Enum1")!, principalBase.FindProperty("Enum1")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter0, principalBase_UpdateUSproc.FindParameter("Enum2")!, principalBase.FindProperty("Enum2")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter0, principalBase_UpdateUSproc.FindParameter("FlagsEnum1")!, principalBase.FindProperty("FlagsEnum1")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter0, principalBase_UpdateUSproc.FindParameter("FlagsEnum2")!, principalBase.FindProperty("FlagsEnum2")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter0, principalBase_UpdateUSproc.FindParameter("PrincipalBaseId")!, principalBase.FindProperty("PrincipalBaseId")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeArray")!, principalBase.FindProperty("RefTypeArray")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeEnumerable")!, principalBase.FindProperty("RefTypeEnumerable")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeIList")!, principalBase.FindProperty("RefTypeIList")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeList")!, principalBase.FindProperty("RefTypeList")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeArray")!, principalBase.FindProperty("ValueTypeArray")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeEnumerable")!, principalBase.FindProperty("ValueTypeEnumerable")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeIList")!, principalBase.FindProperty("ValueTypeIList")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeList")!, principalBase.FindProperty("ValueTypeList")!, principalBase_UpdateSprocMapping);

            var ownedType = principalBase.FindComplexProperty("Owned")!.ComplexType;

            var tableMappings0 = new List<TableMapping>();
            ownedType.SetRuntimeAnnotation("Relational:TableMappings", tableMappings0);
            var principalBaseTableMapping0 = new TableMapping(ownedType, principalBaseTable, true);
            principalBaseTable.AddTypeMapping(principalBaseTableMapping0, false);
            tableMappings0.Add(principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(deetsColumn, ownedType.FindProperty("Details")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_NumberColumn, ownedType.FindProperty("Number")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeArrayColumn, ownedType.FindProperty("RefTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeEnumerableColumn, ownedType.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeIListColumn, ownedType.FindProperty("RefTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeListColumn, ownedType.FindProperty("RefTypeList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeArrayColumn, ownedType.FindProperty("ValueTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeEnumerableColumn, ownedType.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeIListColumn, ownedType.FindProperty("ValueTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeListColumn, ownedType.FindProperty("ValueTypeList")!, principalBaseTableMapping0);

            var principalBase0 = ownedType.FindComplexProperty("Principal")!.ComplexType;

            var tableMappings1 = new List<TableMapping>();
            principalBase0.SetRuntimeAnnotation("Relational:TableMappings", tableMappings1);
            var principalBaseTableMapping1 = new TableMapping(principalBase0, principalBaseTable, true);
            principalBaseTable.AddTypeMapping(principalBaseTableMapping1, false);
            tableMappings1.Add(principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_AlternateIdColumn, principalBase0.FindProperty("AlternateId")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_Enum1Column, principalBase0.FindProperty("Enum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_Enum2Column, principalBase0.FindProperty("Enum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_FlagsEnum1Column, principalBase0.FindProperty("FlagsEnum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_FlagsEnum2Column, principalBase0.FindProperty("FlagsEnum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_IdColumn, principalBase0.FindProperty("Id")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_RefTypeArrayColumn, principalBase0.FindProperty("RefTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_RefTypeEnumerableColumn, principalBase0.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_RefTypeIListColumn, principalBase0.FindProperty("RefTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_RefTypeListColumn, principalBase0.FindProperty("RefTypeList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_ValueTypeArrayColumn, principalBase0.FindProperty("ValueTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_ValueTypeEnumerableColumn, principalBase0.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_ValueTypeIListColumn, principalBase0.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(owned_Principal_ValueTypeListColumn, principalBase0.FindProperty("ValueTypeList")!, principalBaseTableMapping1);

            var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0 = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0, false);
            defaultTableMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)discriminatorColumnBase, principalDerived.FindProperty("Discriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase, principalDerived.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);

            var tableMappings2 = new List<TableMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings2);
            var principalBaseTableMapping2 = new TableMapping(principalDerived, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping2, false);
            tableMappings2.Add(principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(idColumn, principalDerived.FindProperty("Id")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(discriminatorColumn, principalDerived.FindProperty("Discriminator")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(enum1Column, principalDerived.FindProperty("Enum1")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(enum2Column, principalDerived.FindProperty("Enum2")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalDerived.FindProperty("FlagsEnum1")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalDerived.FindProperty("FlagsEnum2")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn, principalDerived.FindProperty("PrincipalBaseId")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalDerived.FindProperty("RefTypeArray")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalDerived.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalDerived.FindProperty("RefTypeIList")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalDerived.FindProperty("RefTypeList")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalDerived.FindProperty("ValueTypeArray")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping2);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping2);

            var sqlQueryMappings0 = new List<SqlQueryMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:SqlQueryMappings", sqlQueryMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0 = new SqlQueryMapping(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQuery.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0, false);
            sqlQueryMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0.IsDefaultSqlQueryMapping = true;
            RelationalModel.CreateSqlQueryColumnMapping(idSqlQueryColumn, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(discriminatorSqlQueryColumn, principalDerived.FindProperty("Discriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(enum1SqlQueryColumn, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(enum2SqlQueryColumn, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(flagsEnum1SqlQueryColumn, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(flagsEnum2SqlQueryColumn, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(principalBaseIdSqlQueryColumn, principalDerived.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeArraySqlQueryColumn, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeEnumerableSqlQueryColumn, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeIListSqlQueryColumn, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(refTypeListSqlQueryColumn, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeArraySqlQueryColumn, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeEnumerableSqlQueryColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeIListSqlQueryColumn, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);
            RelationalModel.CreateSqlQueryColumnMapping(valueTypeListSqlQueryColumn, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappedSqlQuerySqlQueryMapping0);

            var deleteSprocMappings0 = new List<StoredProcedureMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:DeleteStoredProcedureMappings", deleteSprocMappings0);
            var principalBase_DeleteDSproc0 = (IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!;
            var principalBase_DeleteSprocMapping0 = new StoredProcedureMapping(principalDerived, principalBase_DeleteStoreSproc, (IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!, principalBaseTableMapping2, true);
            principalBase_DeleteStoreSproc.AddTypeMapping(principalBase_DeleteSprocMapping0, false);
            deleteSprocMappings0.Add(principalBase_DeleteSprocMapping0);
            principalBaseTableMapping2.DeleteStoredProcedureMapping = principalBase_DeleteSprocMapping0;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter, principalBase_DeleteDSproc0.FindParameter("Id_Original")!, principalDerived.FindProperty("Id")!, principalBase_DeleteSprocMapping0);

            var insertSprocMappings0 = new List<StoredProcedureMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:InsertStoredProcedureMappings", insertSprocMappings0);
            var principalBase_InsertISproc0 = (IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!;
            var principalBase_InsertSprocMapping0 = new StoredProcedureMapping(principalDerived, principalBase_InsertStoreSproc, (IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!, principalBaseTableMapping2, true);
            principalBase_InsertStoreSproc.AddTypeMapping(principalBase_InsertSprocMapping0, false);
            insertSprocMappings0.Add(principalBase_InsertSprocMapping0);
            principalBaseTableMapping2.InsertStoredProcedureMapping = principalBase_InsertSprocMapping0;
            RelationalModel.CreateStoredProcedureParameterMapping(idParameter, principalBase_InsertISproc0.FindParameter("Id")!, principalDerived.FindProperty("Id")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(discriminatorParameter, principalBase_InsertISproc0.FindParameter("Discriminator")!, principalDerived.FindProperty("Discriminator")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter, principalBase_InsertISproc0.FindParameter("Enum1")!, principalDerived.FindProperty("Enum1")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter, principalBase_InsertISproc0.FindParameter("Enum2")!, principalDerived.FindProperty("Enum2")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter, principalBase_InsertISproc0.FindParameter("FlagsEnum1")!, principalDerived.FindProperty("FlagsEnum1")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter, principalBase_InsertISproc0.FindParameter("FlagsEnum2")!, principalDerived.FindProperty("FlagsEnum2")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter, principalBase_InsertISproc0.FindParameter("PrincipalBaseId")!, principalDerived.FindProperty("PrincipalBaseId")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter, principalBase_InsertISproc0.FindParameter("RefTypeArray")!, principalDerived.FindProperty("RefTypeArray")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter, principalBase_InsertISproc0.FindParameter("RefTypeEnumerable")!, principalDerived.FindProperty("RefTypeEnumerable")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter, principalBase_InsertISproc0.FindParameter("RefTypeIList")!, principalDerived.FindProperty("RefTypeIList")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter, principalBase_InsertISproc0.FindParameter("RefTypeList")!, principalDerived.FindProperty("RefTypeList")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter, principalBase_InsertISproc0.FindParameter("ValueTypeArray")!, principalDerived.FindProperty("ValueTypeArray")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter, principalBase_InsertISproc0.FindParameter("ValueTypeEnumerable")!, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter, principalBase_InsertISproc0.FindParameter("ValueTypeIList")!, principalDerived.FindProperty("ValueTypeIList")!, principalBase_InsertSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter, principalBase_InsertISproc0.FindParameter("ValueTypeList")!, principalDerived.FindProperty("ValueTypeList")!, principalBase_InsertSprocMapping0);

            var updateSprocMappings0 = new List<StoredProcedureMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:UpdateStoredProcedureMappings", updateSprocMappings0);
            var principalBase_UpdateUSproc0 = (IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!;
            var principalBase_UpdateSprocMapping0 = new StoredProcedureMapping(principalDerived, principalBase_UpdateStoreSproc, (IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!, principalBaseTableMapping2, true);
            principalBase_UpdateStoreSproc.AddTypeMapping(principalBase_UpdateSprocMapping0, false);
            updateSprocMappings0.Add(principalBase_UpdateSprocMapping0);
            principalBaseTableMapping2.UpdateStoredProcedureMapping = principalBase_UpdateSprocMapping0;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter0, principalBase_UpdateUSproc0.FindParameter("Id_Original")!, principalDerived.FindProperty("Id")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter0, principalBase_UpdateUSproc0.FindParameter("Enum1")!, principalDerived.FindProperty("Enum1")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter0, principalBase_UpdateUSproc0.FindParameter("Enum2")!, principalDerived.FindProperty("Enum2")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter0, principalBase_UpdateUSproc0.FindParameter("FlagsEnum1")!, principalDerived.FindProperty("FlagsEnum1")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter0, principalBase_UpdateUSproc0.FindParameter("FlagsEnum2")!, principalDerived.FindProperty("FlagsEnum2")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter0, principalBase_UpdateUSproc0.FindParameter("PrincipalBaseId")!, principalDerived.FindProperty("PrincipalBaseId")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter0, principalBase_UpdateUSproc0.FindParameter("RefTypeArray")!, principalDerived.FindProperty("RefTypeArray")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter0, principalBase_UpdateUSproc0.FindParameter("RefTypeEnumerable")!, principalDerived.FindProperty("RefTypeEnumerable")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter0, principalBase_UpdateUSproc0.FindParameter("RefTypeIList")!, principalDerived.FindProperty("RefTypeIList")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter0, principalBase_UpdateUSproc0.FindParameter("RefTypeList")!, principalDerived.FindProperty("RefTypeList")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter0, principalBase_UpdateUSproc0.FindParameter("ValueTypeArray")!, principalDerived.FindProperty("ValueTypeArray")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter0, principalBase_UpdateUSproc0.FindParameter("ValueTypeEnumerable")!, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter0, principalBase_UpdateUSproc0.FindParameter("ValueTypeIList")!, principalDerived.FindProperty("ValueTypeIList")!, principalBase_UpdateSprocMapping0);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter0, principalBase_UpdateUSproc0.FindParameter("ValueTypeList")!, principalDerived.FindProperty("ValueTypeList")!, principalBase_UpdateSprocMapping0);
            var fK_PrincipalBase_PrincipalBase_PrincipalBaseId = new ForeignKeyConstraint(
                "FK_PrincipalBase_PrincipalBase_PrincipalBaseId", principalBaseTable, principalBaseTable,
                new[] { principalBaseIdColumn },
                principalBaseTable.FindUniqueConstraint("PK_PrincipalBase")!, ReferentialAction.NoAction);
            var fK_PrincipalBase_PrincipalBase_PrincipalBaseIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "PrincipalBaseId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            fK_PrincipalBase_PrincipalBase_PrincipalBaseId.MappedForeignKeys.Add(fK_PrincipalBase_PrincipalBase_PrincipalBaseIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBase_PrincipalBase_PrincipalBaseIdFk).Add(fK_PrincipalBase_PrincipalBase_PrincipalBaseId);
            principalBaseTable.ForeignKeyConstraints.Add(fK_PrincipalBase_PrincipalBase_PrincipalBaseId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBase_PrincipalBase_PrincipalBaseId);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalBase");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var discriminator = runtimeEntityType.AddProperty(
                "Discriminator",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                maxLength: 55,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            discriminator.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(55)",
                    size: 55,
                    dbType: System.Data.DbType.String));
            discriminator.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AnEnum)0);
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long?),
                nullable: true);
            principalBaseId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            principalBaseId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            OwnedComplexProperty.Create(runtimeEntityType);
            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalBaseId });

            return runtimeEntityType;
        }

        private static class OwnedComplexProperty
        {
            public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
            {
                var complexProperty = declaringType.AddComplexProperty("Owned",
                    typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                    "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                    typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    propertyAccessMode: PropertyAccessMode.Field,
                    changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);

                var complexType = complexProperty.ComplexType;
                var details = complexType.AddProperty(
                    "Details",
                    typeof(string),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                    nullable: true,
                    concurrencyToken: true,
                    valueGenerated: ValueGenerated.OnAddOrUpdate,
                    beforeSaveBehavior: PropertySaveBehavior.Ignore,
                    afterSaveBehavior: PropertySaveBehavior.Ignore,
                    maxLength: 64,
                    unicode: false,
                    precision: 3,
                    scale: 2,
                    sentinel: "");
                details.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "varchar(64)",
                        size: 64,
                        precision: 3,
                        scale: 2));
                details.AddAnnotation("foo", "bar");
                details.AddAnnotation("Relational:ColumnName", "Deets");
                details.AddAnnotation("Relational:ColumnType", "varchar");
                details.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var number = complexType.AddProperty(
                    "Number",
                    typeof(int),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    sentinel: 0);
                number.TypeMapping = IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v));
                number.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeArray = complexType.AddProperty(
                    "RefTypeArray",
                    typeof(IPAddress[]),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v))))),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        keyComparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(45)",
                            size: 45,
                            dbType: System.Data.DbType.String),
                        converter: new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))));
                refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeEnumerable = complexType.AddProperty(
                    "RefTypeEnumerable",
                    typeof(IEnumerable<string>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    keyComparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        keyComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        storeTypePostfix: StoreTypePostfix.None));
                refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeIList = complexType.AddProperty(
                    "RefTypeIList",
                    typeof(IList<string>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    keyComparer: new ListComparer<string>(new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                        JsonStringReaderWriter.Instance),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        keyComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        storeTypePostfix: StoreTypePostfix.None));
                refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var refTypeList = complexType.AddProperty(
                    "RefTypeList",
                    typeof(List<IPAddress>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v))))),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                        new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))),
                    elementMapping: SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        keyComparer: new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(45)",
                            size: 45,
                            dbType: System.Data.DbType.String),
                        converter: new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                            JsonStringReaderWriter.Instance,
                            new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)))));
                refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeArray = complexType.AddProperty(
                    "ValueTypeArray",
                    typeof(DateTime[]),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)),
                    keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                        JsonDateTimeReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                        JsonDateTimeReaderWriter.Instance),
                    elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                        comparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        keyComparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v),
                        providerValueComparer: new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)));
                valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeEnumerable = complexType.AddProperty(
                    "ValueTypeEnumerable",
                    typeof(IEnumerable<byte>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance),
                    elementMapping: SqlServerByteTypeMapping.Default.Clone(
                        comparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        keyComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        providerValueComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)));
                valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeIList = complexType.AddProperty(
                    "ValueTypeIList",
                    typeof(IList<byte>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                        JsonByteReaderWriter.Instance),
                    elementMapping: SqlServerByteTypeMapping.Default.Clone(
                        comparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        keyComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v),
                        providerValueComparer: new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)));
                valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                var valueTypeList = complexType.AddProperty(
                    "ValueTypeList",
                    typeof(List<short>),
                    propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                    nullable: true);
                valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ListComparer<short>(new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)),
                    keyComparer: new ListComparer<short>(new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                        JsonInt16ReaderWriter.Instance)),
                    storeTypePostfix: StoreTypePostfix.None,
                    jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                        JsonInt16ReaderWriter.Instance),
                    elementMapping: SqlServerShortTypeMapping.Default.Clone(
                        comparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        keyComparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v),
                        providerValueComparer: new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)));
                valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                PrincipalComplexProperty.Create(complexType);
                complexType.AddAnnotation("go", "brr");
                complexType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
                complexType.AddAnnotation("Relational:Schema", null);
                complexType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
                complexType.AddAnnotation("Relational:TableName", "PrincipalBase");
                complexType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
                complexType.AddAnnotation("Relational:ViewSchema", null);
                complexProperty.AddAnnotation("goo", "ber");
                return complexProperty;
            }

            private static class PrincipalComplexProperty
            {
                public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                {
                    var complexProperty = declaringType.AddComplexProperty("Principal",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType.Principal#PrincipalBase",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

                    var complexType = complexProperty.ComplexType;
                    var alternateId = complexType.AddProperty(
                        "AlternateId",
                        typeof(Guid),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
                    alternateId.TypeMapping = GuidTypeMapping.Default.Clone(
                        comparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        keyComparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        providerValueComparer: new ValueComparer<Guid>(
                            (Guid v1, Guid v2) => v1 == v2,
                            (Guid v) => v.GetHashCode(),
                            (Guid v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "uniqueidentifier"));
                    alternateId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var enum1 = complexType.AddProperty(
                        "Enum1",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: (CSharpRuntimeModelCodeGeneratorTest.AnEnum)0);
                    enum1.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
                    enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var enum2 = complexType.AddProperty(
                        "Enum2",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    enum2.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                            (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
                    enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var flagsEnum1 = complexType.AddProperty(
                        "FlagsEnum1",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
                    flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
                    flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var flagsEnum2 = complexType.AddProperty(
                        "FlagsEnum2",
                        typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
                    flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                        comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                        providerValueComparer: new ValueComparer<int>(
                            (int v1, int v2) => v1 == v2,
                            (int v) => v,
                            (int v) => v),
                        converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                        jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                            JsonInt32ReaderWriter.Instance,
                            new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                                (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                                (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
                    flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var id = complexType.AddProperty(
                        "Id",
                        typeof(long?),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                        comparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        keyComparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                        providerValueComparer: new ValueComparer<long?>(
                            (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                            (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                            (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
                    id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeArray = complexType.AddProperty(
                        "RefTypeArray",
                        typeof(IPAddress[]),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v))))),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            keyComparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(45)",
                                size: 45,
                                dbType: System.Data.DbType.String),
                            converter: new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)),
                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))));
                    refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeEnumerable = complexType.AddProperty(
                        "RefTypeEnumerable",
                        typeof(IEnumerable<string>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        keyComparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            keyComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(max)",
                                dbType: System.Data.DbType.String),
                            storeTypePostfix: StoreTypePostfix.None));
                    refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeIList = complexType.AddProperty(
                        "RefTypeIList",
                        typeof(IList<string>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        keyComparer: new ListComparer<string>(new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                            JsonStringReaderWriter.Instance),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            keyComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(max)",
                                dbType: System.Data.DbType.String),
                            storeTypePostfix: StoreTypePostfix.None));
                    refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var refTypeList = complexType.AddProperty(
                        "RefTypeList",
                        typeof(List<IPAddress>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                            (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                            (IPAddress v) => v.GetHashCode(),
                            (IPAddress v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v))))),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                            new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))),
                        elementMapping: SqlServerStringTypeMapping.Default.Clone(
                            comparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            keyComparer: new ValueComparer<IPAddress>(
                                (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                                (IPAddress v) => v.GetHashCode(),
                                (IPAddress v) => v),
                            providerValueComparer: new ValueComparer<string>(
                                (string v1, string v2) => v1 == v2,
                                (string v) => v.GetHashCode(),
                                (string v) => v),
                            mappingInfo: new RelationalTypeMappingInfo(
                                storeTypeName: "nvarchar(45)",
                                size: 45,
                                dbType: System.Data.DbType.String),
                            converter: new ValueConverter<IPAddress, string>(
                                (IPAddress v) => v.ToString(),
                                (string v) => IPAddress.Parse(v)),
                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                                JsonStringReaderWriter.Instance,
                                new ValueConverter<IPAddress, string>(
                                    (IPAddress v) => v.ToString(),
                                    (string v) => IPAddress.Parse(v)))));
                    refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeArray = complexType.AddProperty(
                        "ValueTypeArray",
                        typeof(DateTime[]),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)),
                        keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                            (DateTime v1, DateTime v2) => v1.Equals(v2),
                            (DateTime v) => v.GetHashCode(),
                            (DateTime v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                            JsonDateTimeReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                            JsonDateTimeReaderWriter.Instance),
                        elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                            comparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            keyComparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v),
                            providerValueComparer: new ValueComparer<DateTime>(
                                (DateTime v1, DateTime v2) => v1.Equals(v2),
                                (DateTime v) => v.GetHashCode(),
                                (DateTime v) => v)));
                    valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeEnumerable = complexType.AddProperty(
                        "ValueTypeEnumerable",
                        typeof(IEnumerable<byte>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance),
                        elementMapping: SqlServerByteTypeMapping.Default.Clone(
                            comparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            keyComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            providerValueComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v)));
                    valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeIList = complexType.AddProperty(
                        "ValueTypeIList",
                        typeof(IList<byte>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                            (byte v1, byte v2) => v1 == v2,
                            (byte v) => (int)v,
                            (byte v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                            JsonByteReaderWriter.Instance),
                        elementMapping: SqlServerByteTypeMapping.Default.Clone(
                            comparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            keyComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v),
                            providerValueComparer: new ValueComparer<byte>(
                                (byte v1, byte v2) => v1 == v2,
                                (byte v) => (int)v,
                                (byte v) => v)));
                    valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    var valueTypeList = complexType.AddProperty(
                        "ValueTypeList",
                        typeof(List<short>),
                        propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                        nullable: true);
                    valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                        comparer: new ListComparer<short>(new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)),
                        keyComparer: new ListComparer<short>(new ValueComparer<short>(
                            (short v1, short v2) => v1 == v2,
                            (short v) => (int)v,
                            (short v) => v)),
                        providerValueComparer: new ValueComparer<string>(
                            (string v1, string v2) => v1 == v2,
                            (string v) => v.GetHashCode(),
                            (string v) => v),
                        mappingInfo: new RelationalTypeMappingInfo(
                            storeTypeName: "nvarchar(max)",
                            dbType: System.Data.DbType.String),
                        converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                            JsonInt16ReaderWriter.Instance)),
                        storeTypePostfix: StoreTypePostfix.None,
                        jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                            JsonInt16ReaderWriter.Instance),
                        elementMapping: SqlServerShortTypeMapping.Default.Clone(
                            comparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            keyComparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v),
                            providerValueComparer: new ValueComparer<short>(
                                (short v1, short v2) => v1 == v2,
                                (short v) => (int)v,
                                (short v) => v)));
                    valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

                    complexType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
                    complexType.AddAnnotation("Relational:Schema", null);
                    complexType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
                    complexType.AddAnnotation("Relational:TableName", "PrincipalBase");
                    complexType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
                    complexType.AddAnnotation("Relational:ViewSchema", null);
                    return complexProperty;
                }
            }
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType);

            var deriveds = principalEntityType.AddNavigation("Deriveds",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var insertSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Insert",
                null,
                false);

            var principalBaseId = insertSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var enum1 = insertSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum2 = insertSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum1 = insertSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum2 = insertSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList = insertSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList = insertSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray = insertSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable = insertSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList = insertSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList = insertSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray = insertSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable = insertSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var discriminator = insertSproc.AddParameter(
                "Discriminator", System.Data.ParameterDirection.Input, false, "Discriminator", false);
            var id = insertSproc.AddParameter(
                "Id", System.Data.ParameterDirection.Output, false, "Id", false);
            runtimeEntityType.AddAnnotation("Relational:InsertStoredProcedure", insertSproc);

            var deleteSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Delete",
                null,
                true);

            var id0 = deleteSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:DeleteStoredProcedure", deleteSproc);

            var updateSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Update",
                null,
                false);

            var principalBaseId0 = updateSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var enum10 = updateSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum20 = updateSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum10 = updateSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum20 = updateSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList0 = updateSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList0 = updateSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray0 = updateSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable0 = updateSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList0 = updateSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList0 = updateSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray0 = updateSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable0 = updateSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var id1 = updateSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:UpdateStoredProcedure", updateSproc);

            runtimeEntityType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewDefinitionSql", null);
            runtimeEntityType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorProperty: "Discriminator",
                discriminatorValue: "PrincipalDerived<DependentBase<byte?>>");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", "select * from PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var principalBase = model.FindEntityType(typeof(PrincipalBase));

                    var complexProperty = principalBase.GetComplexProperties().Single();
                    Assert.Equal(
                        new[] { "goo" },
                        complexProperty.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(nameof(PrincipalBase.Owned), complexProperty.Name);
                    Assert.False(complexProperty.IsCollection);
                    Assert.False(complexProperty.IsNullable);
                    Assert.Equal(typeof(OwnedType), complexProperty.ClrType);
                    Assert.Equal("_ownedField", complexProperty.FieldInfo.Name);
                    Assert.Equal(nameof(PrincipalBase.Owned), complexProperty.PropertyInfo.Name);
                    Assert.Equal(principalBase, complexProperty.DeclaringType);
                    Assert.Equal(PropertyAccessMode.Field, complexProperty.GetPropertyAccessMode());
                    Assert.Equal("ber", complexProperty["goo"]);

                    var complexType = complexProperty.ComplexType;
                    Assert.Equal(
                        new[]
                        {
                            RelationalAnnotationNames.FunctionName,
                            RelationalAnnotationNames.Schema,
                            RelationalAnnotationNames.SqlQuery,
                            RelationalAnnotationNames.TableName,
                            RelationalAnnotationNames.ViewName,
                            RelationalAnnotationNames.ViewSchema,
                            "go"
                        },
                        complexType.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(PrincipalBase).FullName + ".Owned#OwnedType", complexType.Name);
                    Assert.Equal(typeof(OwnedType), complexType.ClrType);
                    Assert.True(complexType.HasSharedClrType);
                    Assert.False(complexType.IsPropertyBag);
                    Assert.IsType<ConstructorBinding>(complexType.ConstructorBinding);
                    Assert.Null(complexType.FindIndexerPropertyInfo());
                    Assert.Equal(
                        ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                        complexType.GetChangeTrackingStrategy());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => complexType.GetPropertyAccessMode()).Message);
                    Assert.Equal("brr", complexType["go"]);

                    var detailsProperty = complexType.FindProperty(nameof(OwnedType.Details));
                    Assert.Equal(
                        new[]
                        {
                            CoreAnnotationNames.MaxLength,
                            CoreAnnotationNames.Precision,
                            RelationalAnnotationNames.ColumnName,
                            RelationalAnnotationNames.ColumnType,
                            CoreAnnotationNames.Scale,
                            SqlServerAnnotationNames.ValueGenerationStrategy,
                            CoreAnnotationNames.Unicode,
                            "foo"
                        },
                        detailsProperty.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(string), detailsProperty.ClrType);
                    Assert.Equal(typeof(string), detailsProperty.PropertyInfo.PropertyType);
                    Assert.Equal(typeof(string), detailsProperty.FieldInfo.FieldType);
                    Assert.Equal("_details", detailsProperty.FieldInfo.Name);
                    Assert.True(detailsProperty.IsNullable);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, detailsProperty.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Ignore, detailsProperty.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Ignore, detailsProperty.GetBeforeSaveBehavior());
                    Assert.Equal("Deets", detailsProperty.GetColumnName());
                    Assert.Equal("varchar(64)", detailsProperty.GetColumnType());
                    Assert.False(detailsProperty.IsUnicode());
                    Assert.True(detailsProperty.IsConcurrencyToken);
                    Assert.Equal(64, detailsProperty.GetMaxLength());
                    Assert.Null(detailsProperty.IsFixedLength());
                    Assert.Equal(3, detailsProperty.GetPrecision());
                    Assert.Equal(2, detailsProperty.GetScale());
                    Assert.Equal("", detailsProperty.Sentinel);
                    Assert.Equal(PropertyAccessMode.FieldDuringConstruction, detailsProperty.GetPropertyAccessMode());
                    Assert.Null(detailsProperty.GetValueConverter());
                    Assert.NotNull(detailsProperty.GetValueComparer());
                    Assert.NotNull(detailsProperty.GetKeyValueComparer());
                    Assert.Equal(SqlServerValueGenerationStrategy.None, detailsProperty.GetValueGenerationStrategy());
                    Assert.Null(detailsProperty.GetDefaultValueSql());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetIdentitySeed()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetIdentityIncrement()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.IsSparse()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetCollation()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetComment()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => detailsProperty.GetColumnOrder()).Message);

                    var nestedComplexType = complexType.FindComplexProperty(nameof(OwnedType.Principal)).ComplexType;

                    Assert.Equal(14, nestedComplexType.GetProperties().Count());

                    var principalTable = StoreObjectIdentifier.Create(complexType, StoreObjectType.Table).Value;

                    Assert.Equal("Deets", detailsProperty.GetColumnName(principalTable));

                    var dbFunction = model.FindDbFunction("PrincipalBaseTvf");
                    Assert.Equal("dbo", dbFunction.Schema);
                    Assert.False(dbFunction.IsNullable);
                    Assert.False(dbFunction.IsScalar);
                    Assert.False(dbFunction.IsBuiltIn);
                    Assert.False(dbFunction.IsAggregate);
                    Assert.Null(dbFunction.Translation);
                    Assert.Null(dbFunction.TypeMapping);
                    Assert.Equal(typeof(IQueryable<PrincipalBase>), dbFunction.ReturnType);
                    Assert.Null(dbFunction.MethodInfo);
                    Assert.Empty(dbFunction.GetAnnotations());
                    Assert.Empty(dbFunction.GetRuntimeAnnotations());
                    Assert.Equal("PrincipalBaseTvf", dbFunction.StoreFunction.Name);
                    Assert.False(dbFunction.StoreFunction.IsShared);
                    Assert.NotNull(dbFunction.ToString());
                    Assert.Empty(dbFunction.Parameters);

                    var principalBaseFunctionMapping = principalBase.GetFunctionMappings().Single(m => m.IsDefaultFunctionMapping);
                    Assert.True(principalBaseFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(principalBaseFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(principalBaseFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(dbFunction, principalBaseFunctionMapping.DbFunction);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);

                    Assert.Equal(
                        new[] { principalBase, principalDerived },
                        model.GetEntityTypes());
                },
                null,
                c =>
                {
                    c.Set<PrincipalDerived<DependentBase<byte?>>>().Add(
                        new PrincipalDerived<DependentBase<byte?>>
                        {
                            Id = 1,
                            AlternateId = new Guid(),
                            Dependent = new DependentBase<byte?>(1),
                            Owned = new OwnedType(c)
                            {
                                Principal = new PrincipalBase()
                            }
                        });

                    //c.SaveChanges();
                });

        public class BigContextWithJson : BigContext
        {
            public BigContextWithJson()
                : base(jsonColumns: true)
            {
            }
        }

        public class BigContext : SqlServerContextBase
        {
            private readonly bool _jsonColumns;

            public BigContext(bool jsonColumns = false)
            {
                _jsonColumns = jsonColumns;
            }

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder
                    .UseCollation("Latin1_General_CS_AS")
                    .UseIdentityColumns(3, 2);

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        if (!_jsonColumns)
                        {
                            eb.Property(e => e.Id).UseIdentityColumn(2, 3)
                                .Metadata.SetColumnName("DerivedId", StoreObjectIdentifier.Table("PrincipalDerived"));
                        }

                        eb.Property(e => e.FlagsEnum2)
                            .HasSentinel(AFlagsEnum.C | AFlagsEnum.B);

                        eb.Property(e => e.AlternateId)
                            .UsePropertyAccessMode(PropertyAccessMode.FieldDuringConstruction);

                        eb.Property<Point>("Point")
                            .HasColumnType("geometry")
                            .HasDefaultValue(
                                NtsGeometryServices.Instance.CreateGeometryFactory(srid: 0).CreatePoint(new CoordinateZM(0, 0, 0, 0)))
                            .HasConversion<CastingConverter<Point, Point>, CustomValueComparer<Point>, CustomValueComparer<Point>>();

                        eb.HasIndex(e => new { e.AlternateId, e.Id });

                        eb.HasKey(e => new { e.Id, e.AlternateId })
                            .HasName("PK")
                            .IsClustered();

                        eb.HasAlternateKey(e => e.Id);

                        eb.Property(e => e.AlternateId).Metadata.SetJsonValueReaderWriterType(
                            _jsonColumns
                                ? typeof(MyJsonGuidReaderWriter)
                                : typeof(JsonGuidReaderWriter));

                        eb.OwnsOne(
                            e => e.Owned, ob =>
                            {
                                ob.HasChangeTrackingStrategy(ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);
                                ob.UsePropertyAccessMode(PropertyAccessMode.Field);
                                ob.Property(e => e.Details)
                                    .IsSparse()
                                    .UseCollation("Latin1_General_CI_AI");

                                if (_jsonColumns)
                                {
                                    ob.ToJson();
                                }
                                else
                                {
                                    ob.ToTable(
                                        "PrincipalBase", "mySchema",
                                        t => t.Property("PrincipalBaseId").UseIdentityColumn(2, 3));

                                    ob.SplitToTable("Details", s => s.Property(e => e.Details));

                                    ob.HasData(
                                        new
                                        {
                                            Number = 10,
                                            PrincipalBaseId = 1L,
                                            PrincipalBaseAlternateId = new Guid()
                                        });
                                }
                            });

                        eb.Navigation(e => e.Owned).IsRequired().HasField("_ownedField")
                            .UsePropertyAccessMode(PropertyAccessMode.Field);

                        if (!_jsonColumns)
                        {
                            eb.HasData(new PrincipalBase { Id = 1, AlternateId = new Guid() });

                            eb.ToTable("PrincipalBase", "mySchema");
                        }
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        eb.HasOne(e => e.Dependent).WithOne(e => e.Principal)
                            .HasForeignKey<DependentBase<byte?>>()
                            .OnDelete(DeleteBehavior.ClientNoAction);

                        eb.Navigation(e => e.Dependent).AutoInclude().EnableLazyLoading(false);

                        eb.OwnsMany(
                            typeof(OwnedType).FullName, "ManyOwned", ob =>
                            {
                                if (_jsonColumns)
                                {
                                    ob.ToJson();
                                }
                                else
                                {
                                    ob.ToTable("ManyOwned", t => t.IsMemoryOptimized().ExcludeFromMigrations());
                                }
                            });

                        eb.HasMany(e => e.Principals).WithMany(e => (ICollection<PrincipalDerived<DependentBase<byte?>>>)e.Deriveds)
                            .UsingEntity(
                                jb =>
                                {
                                    jb.ToTable(tb => tb.HasComment("Join table"));
                                    jb.Property<byte[]>("rowid")
                                        .IsRowVersion()
                                        .HasComment("RowVersion")
                                        .HasColumnOrder(1);
                                });

                        eb.Navigation(e => e.Principals).AutoInclude().EnableLazyLoading(false);

                        if (!_jsonColumns)
                        {
                            eb.ToTable("PrincipalDerived");
                        }
                    });

                modelBuilder.Entity<DependentBase<byte?>>(
                    eb =>
                    {
                        eb.Property<byte?>("Id");

                        eb.HasKey("PrincipalId", "PrincipalAlternateId");

                        eb.HasOne<PrincipalBase>().WithOne()
                            .HasForeignKey<DependentBase<byte?>>("PrincipalId")
                            .HasPrincipalKey<PrincipalBase>(e => e.Id);

                        eb.HasDiscriminator<Enum1>("EnumDiscriminator")
                            .HasValue(Enum1.One)
                            .HasValue<DependentDerived<byte?>>(Enum1.Two)
                            .IsComplete(false);
                    });

                modelBuilder.Entity<DependentDerived<byte?>>(
                    eb =>
                    {
                        eb.Property<string>("Data")
                            .HasMaxLength(20)
                            .IsFixedLength()
                            .IsUnicode(false);

                        eb.Property<decimal>("Money")
                            .HasPrecision(9, 3);
                    });

                modelBuilder.Entity<ManyTypes>();
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
            {
                SqlServerTestStore.Create("RuntimeModelTest" + GetType().Name).AddProviderOptions(options);
                new SqlServerDbContextOptionsBuilder(options).UseNetTopologySuite();
            }
        }

        public class ComplexTypesContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        eb.ComplexProperty(
                            e => e.Owned, eb =>
                            {
                                eb.IsRequired()
                                    .HasField("_ownedField")
                                    .UsePropertyAccessMode(PropertyAccessMode.Field)
                                    .HasChangeTrackingStrategy(ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues)
                                    .HasPropertyAnnotation("goo", "ber")
                                    .HasTypeAnnotation("go", "brr");
                                eb.Property(c => c.Details)
                                    .HasColumnName("Deets")
                                    .HasColumnOrder(1)
                                    .HasColumnType("varchar")
                                    .IsUnicode(false)
                                    .IsRequired(false)
                                    .HasField("_details")
                                    .HasSentinel("")
                                    .UsePropertyAccessMode(PropertyAccessMode.FieldDuringConstruction)
                                    .IsSparse()
                                    .UseCollation("Latin1_General_CI_AI")
                                    .HasMaxLength(64)
                                    .HasPrecision(3, 2)
                                    .HasComment("Dt")
                                    .IsRowVersion()
                                    .HasAnnotation("foo", "bar");
                                eb.Ignore(e => e.Context);
                                eb.ComplexProperty(o => o.Principal).IsRequired();
                            });

                        eb.ToTable("PrincipalBase");
                        eb.ToView("PrincipalBaseView");
                        eb.ToSqlQuery("select * from PrincipalBase");
                        eb.ToFunction("PrincipalBaseTvf");

                        eb.InsertUsingStoredProcedure(
                            s => s
                                .HasParameter("PrincipalBaseId")
                                .HasParameter("Enum1")
                                .HasParameter("Enum2")
                                .HasParameter("FlagsEnum1")
                                .HasParameter("FlagsEnum2")
                                .HasParameter("ValueTypeList")
                                .HasParameter("ValueTypeIList")
                                .HasParameter("ValueTypeArray")
                                .HasParameter("ValueTypeEnumerable")
                                .HasParameter("RefTypeList")
                                .HasParameter("RefTypeIList")
                                .HasParameter("RefTypeArray")
                                .HasParameter("RefTypeEnumerable")
                                .HasParameter("Discriminator")
                                .HasParameter(p => p.Id, p => p.IsOutput()));
                        eb.UpdateUsingStoredProcedure(
                            s => s
                                .HasParameter("PrincipalBaseId")
                                .HasParameter("Enum1")
                                .HasParameter("Enum2")
                                .HasParameter("FlagsEnum1")
                                .HasParameter("FlagsEnum2")
                                .HasParameter("ValueTypeList")
                                .HasParameter("ValueTypeIList")
                                .HasParameter("ValueTypeArray")
                                .HasParameter("ValueTypeEnumerable")
                                .HasParameter("RefTypeList")
                                .HasParameter("RefTypeIList")
                                .HasParameter("RefTypeArray")
                                .HasParameter("RefTypeEnumerable")
                                .HasOriginalValueParameter(p => p.Id));
                        eb.DeleteUsingStoredProcedure(
                            s => s
                                .HasRowsAffectedReturnValue()
                                .HasOriginalValueParameter(p => p.Id));
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        //eb.ComplexCollection(typeof(OwnedType).Name, "ManyOwned");
                        eb.Ignore(p => p.Dependent);
                        eb.Ignore(p => p.Principals);
                        eb.ToTable("PrincipalBase");
                        eb.ToFunction((string)null);
                    });
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => SqlServerTestStore.Create("RuntimeModelTest" + GetType().Name).AddProviderOptions(options);
        }

        [ConditionalFact]
        public void TPC_model()
            => Test(
                new TpcContext(),
                new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "TpcContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TpcContext))]
    public partial class TpcContextModel : RuntimeModel
    {
        static TpcContextModel()
        {
            var model = new TpcContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static TpcContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "TpcContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Migrations;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class TpcContextModel
    {
        partial void Initialize()
        {
            var dependentBase = DependentBaseEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalDerived);
            PrincipalBaseEntityType.CreateForeignKey1(principalBase, principalBase);
            PrincipalBaseEntityType.CreateForeignKey2(principalBase, principalDerived);

            DependentBaseEntityType.CreateAnnotations(dependentBase);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            var sequences = new SortedDictionary<(string, string), ISequence>();
            var principalBaseSequence = new RuntimeSequence(
                "PrincipalBaseSequence",
                this,
                typeof(long),
                schema: "TPC",
                modelSchemaIsNull: true);

            sequences[("PrincipalBaseSequence", null)] = principalBaseSequence;

            AddAnnotation("Relational:Sequences", sequences);
            AddAnnotation("Relational:DefaultSchema", "TPC");
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            dependentBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", null, relationalModel);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "tinyint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase);
            var principalIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalId", principalIdColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(dependentBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, dependentBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentBase.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings = new List<TableMapping>();
            dependentBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dependentBasebyteTable = new Table("DependentBase<byte?>", "TPC", relationalModel);
            var idColumn = new Column("Id", "tinyint", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("Id", idColumn);
            var principalIdColumn = new Column("PrincipalId", "bigint", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { idColumn });
            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
            var pK_DependentBasebyteUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "Id" });
            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteUc).Add(pK_DependentBasebyte);
            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
            var iX_DependentBasebyte_PrincipalId = new TableIndex(
            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" });
            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
            relationalModel.Tables.Add(("DependentBase<byte?>", "TPC"), dependentBasebyteTable);
            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true);
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
            tableMappings.Add(dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);

            var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", null, relationalModel);
            var enum1ColumnBase = new ColumnBase<ColumnMappingBase>("Enum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum1", enum1ColumnBase);
            var enum2ColumnBase = new ColumnBase<ColumnMappingBase>("Enum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum2", enum2ColumnBase);
            var flagsEnum1ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase);
            var flagsEnum2ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase);
            var idColumnBase0 = new ColumnBase<ColumnMappingBase>("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Id", idColumnBase0);
            var principalBaseIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("PrincipalBaseId", principalBaseIdColumnBase);
            var principalDerivedDependentBasebyteIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumnBase);
            var refTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase);
            var refTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase);
            var refTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase);
            var refTypeListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeList", refTypeListColumnBase);
            var valueTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase);
            var valueTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase);
            var valueTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase);
            var valueTypeListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase = new TableMappingBase<ColumnMappingBase>(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, false);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase, false);
            defaultTableMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase, principalBase.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteIdColumnBase, principalBase.FindProperty("PrincipalDerivedId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);

            var tableMappings0 = new List<TableMapping>();
            principalBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings0);
            var principalBaseTable = new Table("PrincipalBase", "TPC", relationalModel);
            var idColumn0 = new Column("Id", "bigint", principalBaseTable);
            principalBaseTable.Columns.Add("Id", idColumn0);
            var enum1Column = new Column("Enum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("Enum1", enum1Column);
            var enum2Column = new Column("Enum2", "int", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Enum2", enum2Column);
            var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
            var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
            var principalBaseIdColumn = new Column("PrincipalBaseId", "bigint", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
            var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "bigint", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
            var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
            var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
            var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
            var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
            var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
            var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
            var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
            var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
            var pK_PrincipalBase = new UniqueConstraint("PK_PrincipalBase", principalBaseTable, new[] { idColumn0 });
            principalBaseTable.PrimaryKey = pK_PrincipalBase;
            var pK_PrincipalBaseUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            pK_PrincipalBase.MappedKeys.Add(pK_PrincipalBaseUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBaseUc).Add(pK_PrincipalBase);
            principalBaseTable.UniqueConstraints.Add("PK_PrincipalBase", pK_PrincipalBase);
            var iX_PrincipalBase_PrincipalDerivedDependentBasebyteId = new TableIndex(
            "IX_PrincipalBase_PrincipalDerived<DependentBase<byte?>>Id", principalBaseTable, new[] { principalDerivedDependentBasebyteIdColumn }, false);
            var iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "PrincipalDerivedId" });
            iX_PrincipalBase_PrincipalDerivedDependentBasebyteId.MappedIndexes.Add(iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx).Add(iX_PrincipalBase_PrincipalDerivedDependentBasebyteId);
            principalBaseTable.Indexes.Add("IX_PrincipalBase_PrincipalDerived<DependentBase<byte?>>Id", iX_PrincipalBase_PrincipalDerivedDependentBasebyteId);
            var pIX = new TableIndex(
            "PIX", principalBaseTable, new[] { principalBaseIdColumn }, true);
            var pIXIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                "PrincipalIndex");
            pIX.MappedIndexes.Add(pIXIx);
            RelationalModel.GetOrCreateTableIndexes(pIXIx).Add(pIX);
            principalBaseTable.Indexes.Add("PIX", pIX);
            relationalModel.Tables.Add(("PrincipalBase", "TPC"), principalBaseTable);
            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, false);
            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
            tableMappings0.Add(principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(idColumn0, principalBase.FindProperty("Id")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn, principalBase.FindProperty("PrincipalDerivedId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);

            var viewMappings = new List<ViewMapping>();
            principalBase.SetRuntimeAnnotation("Relational:ViewMappings", viewMappings);
            var principalBaseViewView = new View("PrincipalBaseView", "TPC", relationalModel);
            var enum1ViewColumn = new ViewColumn("Enum1", "int", principalBaseViewView);
            principalBaseViewView.Columns.Add("Enum1", enum1ViewColumn);
            var enum2ViewColumn = new ViewColumn("Enum2", "int", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("Enum2", enum2ViewColumn);
            var flagsEnum1ViewColumn = new ViewColumn("FlagsEnum1", "int", principalBaseViewView);
            principalBaseViewView.Columns.Add("FlagsEnum1", flagsEnum1ViewColumn);
            var flagsEnum2ViewColumn = new ViewColumn("FlagsEnum2", "int", principalBaseViewView);
            principalBaseViewView.Columns.Add("FlagsEnum2", flagsEnum2ViewColumn);
            var idViewColumn = new ViewColumn("Id", "bigint", principalBaseViewView);
            principalBaseViewView.Columns.Add("Id", idViewColumn);
            var principalBaseIdViewColumn = new ViewColumn("PrincipalBaseId", "bigint", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("PrincipalBaseId", principalBaseIdViewColumn);
            var principalDerivedIdViewColumn = new ViewColumn("PrincipalDerivedId", "bigint", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("PrincipalDerivedId", principalDerivedIdViewColumn);
            var refTypeArrayViewColumn = new ViewColumn("RefTypeArray", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeArray", refTypeArrayViewColumn);
            var refTypeEnumerableViewColumn = new ViewColumn("RefTypeEnumerable", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeEnumerable", refTypeEnumerableViewColumn);
            var refTypeIListViewColumn = new ViewColumn("RefTypeIList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeIList", refTypeIListViewColumn);
            var refTypeListViewColumn = new ViewColumn("RefTypeList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("RefTypeList", refTypeListViewColumn);
            var valueTypeArrayViewColumn = new ViewColumn("ValueTypeArray", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeArray", valueTypeArrayViewColumn);
            var valueTypeEnumerableViewColumn = new ViewColumn("ValueTypeEnumerable", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableViewColumn);
            var valueTypeIListViewColumn = new ViewColumn("ValueTypeIList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeIList", valueTypeIListViewColumn);
            var valueTypeListViewColumn = new ViewColumn("ValueTypeList", "nvarchar(max)", principalBaseViewView)
            {
                IsNullable = true
            };
            principalBaseViewView.Columns.Add("ValueTypeList", valueTypeListViewColumn);
            relationalModel.Views.Add(("PrincipalBaseView", "TPC"), principalBaseViewView);
            var principalBaseViewViewMapping = new ViewMapping(principalBase, principalBaseViewView, false);
            principalBaseViewView.AddTypeMapping(principalBaseViewViewMapping, false);
            viewMappings.Add(principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(idViewColumn, principalBase.FindProperty("Id")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(enum1ViewColumn, principalBase.FindProperty("Enum1")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(enum2ViewColumn, principalBase.FindProperty("Enum2")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(flagsEnum1ViewColumn, principalBase.FindProperty("FlagsEnum1")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(flagsEnum2ViewColumn, principalBase.FindProperty("FlagsEnum2")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(principalBaseIdViewColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(principalDerivedIdViewColumn, principalBase.FindProperty("PrincipalDerivedId")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeArrayViewColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeEnumerableViewColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeIListViewColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeListViewColumn, principalBase.FindProperty("RefTypeList")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeArrayViewColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeEnumerableViewColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeIListViewColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeListViewColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseViewViewMapping);

            var deleteSprocMappings = new List<StoredProcedureMapping>();
            principalBase.SetRuntimeAnnotation("Relational:DeleteStoredProcedureMappings", deleteSprocMappings);
            var principalBase_DeleteStoreSproc = new StoreStoredProcedure("PrincipalBase_Delete", "TPC", relationalModel);
            principalBase_DeleteStoreSproc.ReturnValue = new StoreStoredProcedureReturnValue("", "int", principalBase_DeleteStoreSproc);
            var id_OriginalParameter = new StoreStoredProcedureParameter("Id_Original", "bigint", 0, principalBase_DeleteStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_DeleteStoreSproc.AddParameter(id_OriginalParameter);
            principalBase_DeleteStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("PrincipalBase_Delete", "TPC"), principalBase_DeleteStoreSproc);
            var principalBase_DeleteDSproc = (IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!;
            var principalBase_DeleteSprocMapping = new StoredProcedureMapping(principalBase, principalBase_DeleteStoreSproc, (IRuntimeStoredProcedure)principalBase.GetDeleteStoredProcedure()!, principalBaseTableMapping, false);
            principalBase_DeleteStoreSproc.AddTypeMapping(principalBase_DeleteSprocMapping, false);
            deleteSprocMappings.Add(principalBase_DeleteSprocMapping);
            principalBaseTableMapping.DeleteStoredProcedureMapping = principalBase_DeleteSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter, principalBase_DeleteDSproc.FindParameter("Id_Original")!, principalBase.FindProperty("Id")!, principalBase_DeleteSprocMapping);

            var insertSprocMappings = new List<StoredProcedureMapping>();
            principalBase.SetRuntimeAnnotation("Relational:InsertStoredProcedureMappings", insertSprocMappings);
            var principalBase_InsertStoreSproc = new StoreStoredProcedure("PrincipalBase_Insert", "TPC", relationalModel);
            var principalBaseIdParameter = new StoreStoredProcedureParameter("PrincipalBaseId", "bigint", 0, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(principalBaseIdParameter);
            var principalDerivedIdParameter = new StoreStoredProcedureParameter("PrincipalDerivedId", "bigint", 1, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(principalDerivedIdParameter);
            var enum1Parameter = new StoreStoredProcedureParameter("Enum1", "int", 2, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(enum1Parameter);
            var enum2Parameter = new StoreStoredProcedureParameter("Enum2", "int", 3, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(enum2Parameter);
            var flagsEnum1Parameter = new StoreStoredProcedureParameter("FlagsEnum1", "int", 4, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(flagsEnum1Parameter);
            var flagsEnum2Parameter = new StoreStoredProcedureParameter("FlagsEnum2", "int", 5, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_InsertStoreSproc.AddParameter(flagsEnum2Parameter);
            var valueTypeListParameter = new StoreStoredProcedureParameter("ValueTypeList", "nvarchar(max)", 6, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeListParameter);
            var valueTypeIListParameter = new StoreStoredProcedureParameter("ValueTypeIList", "nvarchar(max)", 7, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeIListParameter);
            var valueTypeArrayParameter = new StoreStoredProcedureParameter("ValueTypeArray", "nvarchar(max)", 8, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeArrayParameter);
            var valueTypeEnumerableParameter = new StoreStoredProcedureParameter("ValueTypeEnumerable", "nvarchar(max)", 9, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(valueTypeEnumerableParameter);
            var refTypeListParameter = new StoreStoredProcedureParameter("RefTypeList", "nvarchar(max)", 10, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeListParameter);
            var refTypeIListParameter = new StoreStoredProcedureParameter("RefTypeIList", "nvarchar(max)", 11, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeIListParameter);
            var refTypeArrayParameter = new StoreStoredProcedureParameter("RefTypeArray", "nvarchar(max)", 12, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeArrayParameter);
            var refTypeEnumerableParameter = new StoreStoredProcedureParameter("RefTypeEnumerable", "nvarchar(max)", 13, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_InsertStoreSproc.AddParameter(refTypeEnumerableParameter);
            var baseIdParameter = new StoreStoredProcedureParameter("BaseId", "bigint", 14, principalBase_InsertStoreSproc, System.Data.ParameterDirection.Output);
            principalBase_InsertStoreSproc.AddParameter(baseIdParameter);
            principalBase_InsertStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("PrincipalBase_Insert", "TPC"), principalBase_InsertStoreSproc);
            var principalBase_InsertISproc = (IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!;
            var principalBase_InsertSprocMapping = new StoredProcedureMapping(principalBase, principalBase_InsertStoreSproc, (IRuntimeStoredProcedure)principalBase.GetInsertStoredProcedure()!, principalBaseTableMapping, false);
            principalBase_InsertStoreSproc.AddTypeMapping(principalBase_InsertSprocMapping, false);
            insertSprocMappings.Add(principalBase_InsertSprocMapping);
            principalBaseTableMapping.InsertStoredProcedureMapping = principalBase_InsertSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(baseIdParameter, principalBase_InsertISproc.FindParameter("BaseId")!, principalBase.FindProperty("Id")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter, principalBase_InsertISproc.FindParameter("Enum1")!, principalBase.FindProperty("Enum1")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter, principalBase_InsertISproc.FindParameter("Enum2")!, principalBase.FindProperty("Enum2")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter, principalBase_InsertISproc.FindParameter("FlagsEnum1")!, principalBase.FindProperty("FlagsEnum1")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter, principalBase_InsertISproc.FindParameter("FlagsEnum2")!, principalBase.FindProperty("FlagsEnum2")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter, principalBase_InsertISproc.FindParameter("PrincipalBaseId")!, principalBase.FindProperty("PrincipalBaseId")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalDerivedIdParameter, principalBase_InsertISproc.FindParameter("PrincipalDerivedId")!, principalBase.FindProperty("PrincipalDerivedId")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter, principalBase_InsertISproc.FindParameter("RefTypeArray")!, principalBase.FindProperty("RefTypeArray")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter, principalBase_InsertISproc.FindParameter("RefTypeEnumerable")!, principalBase.FindProperty("RefTypeEnumerable")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter, principalBase_InsertISproc.FindParameter("RefTypeIList")!, principalBase.FindProperty("RefTypeIList")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter, principalBase_InsertISproc.FindParameter("RefTypeList")!, principalBase.FindProperty("RefTypeList")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter, principalBase_InsertISproc.FindParameter("ValueTypeArray")!, principalBase.FindProperty("ValueTypeArray")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter, principalBase_InsertISproc.FindParameter("ValueTypeEnumerable")!, principalBase.FindProperty("ValueTypeEnumerable")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter, principalBase_InsertISproc.FindParameter("ValueTypeIList")!, principalBase.FindProperty("ValueTypeIList")!, principalBase_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter, principalBase_InsertISproc.FindParameter("ValueTypeList")!, principalBase.FindProperty("ValueTypeList")!, principalBase_InsertSprocMapping);

            var updateSprocMappings = new List<StoredProcedureMapping>();
            principalBase.SetRuntimeAnnotation("Relational:UpdateStoredProcedureMappings", updateSprocMappings);
            var principalBase_UpdateStoreSproc = new StoreStoredProcedure("PrincipalBase_Update", "TPC", relationalModel);
            var principalBaseIdParameter0 = new StoreStoredProcedureParameter("PrincipalBaseId", "bigint", 0, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(principalBaseIdParameter0);
            var principalDerivedIdParameter0 = new StoreStoredProcedureParameter("PrincipalDerivedId", "bigint", 1, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(principalDerivedIdParameter0);
            var enum1Parameter0 = new StoreStoredProcedureParameter("Enum1", "int", 2, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(enum1Parameter0);
            var enum2Parameter0 = new StoreStoredProcedureParameter("Enum2", "int", 3, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(enum2Parameter0);
            var flagsEnum1Parameter0 = new StoreStoredProcedureParameter("FlagsEnum1", "int", 4, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(flagsEnum1Parameter0);
            var flagsEnum2Parameter0 = new StoreStoredProcedureParameter("FlagsEnum2", "int", 5, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(flagsEnum2Parameter0);
            var valueTypeListParameter0 = new StoreStoredProcedureParameter("ValueTypeList", "nvarchar(max)", 6, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeListParameter0);
            var valueTypeIListParameter0 = new StoreStoredProcedureParameter("ValueTypeIList", "nvarchar(max)", 7, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeIListParameter0);
            var valueTypeArrayParameter0 = new StoreStoredProcedureParameter("ValueTypeArray", "nvarchar(max)", 8, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeArrayParameter0);
            var valueTypeEnumerableParameter0 = new StoreStoredProcedureParameter("ValueTypeEnumerable", "nvarchar(max)", 9, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(valueTypeEnumerableParameter0);
            var refTypeListParameter0 = new StoreStoredProcedureParameter("RefTypeList", "nvarchar(max)", 10, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeListParameter0);
            var refTypeIListParameter0 = new StoreStoredProcedureParameter("RefTypeIList", "nvarchar(max)", 11, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeIListParameter0);
            var refTypeArrayParameter0 = new StoreStoredProcedureParameter("RefTypeArray", "nvarchar(max)", 12, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeArrayParameter0);
            var refTypeEnumerableParameter0 = new StoreStoredProcedureParameter("RefTypeEnumerable", "nvarchar(max)", 13, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            principalBase_UpdateStoreSproc.AddParameter(refTypeEnumerableParameter0);
            var id_OriginalParameter0 = new StoreStoredProcedureParameter("Id_Original", "bigint", 14, principalBase_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            principalBase_UpdateStoreSproc.AddParameter(id_OriginalParameter0);
            principalBase_UpdateStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("PrincipalBase_Update", "TPC"), principalBase_UpdateStoreSproc);
            var principalBase_UpdateUSproc = (IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!;
            var principalBase_UpdateSprocMapping = new StoredProcedureMapping(principalBase, principalBase_UpdateStoreSproc, (IRuntimeStoredProcedure)principalBase.GetUpdateStoredProcedure()!, principalBaseTableMapping, false);
            principalBase_UpdateStoreSproc.AddTypeMapping(principalBase_UpdateSprocMapping, false);
            updateSprocMappings.Add(principalBase_UpdateSprocMapping);
            principalBaseTableMapping.UpdateStoredProcedureMapping = principalBase_UpdateSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter0, principalBase_UpdateUSproc.FindParameter("Id_Original")!, principalBase.FindProperty("Id")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter0, principalBase_UpdateUSproc.FindParameter("Enum1")!, principalBase.FindProperty("Enum1")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter0, principalBase_UpdateUSproc.FindParameter("Enum2")!, principalBase.FindProperty("Enum2")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter0, principalBase_UpdateUSproc.FindParameter("FlagsEnum1")!, principalBase.FindProperty("FlagsEnum1")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter0, principalBase_UpdateUSproc.FindParameter("FlagsEnum2")!, principalBase.FindProperty("FlagsEnum2")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter0, principalBase_UpdateUSproc.FindParameter("PrincipalBaseId")!, principalBase.FindProperty("PrincipalBaseId")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalDerivedIdParameter0, principalBase_UpdateUSproc.FindParameter("PrincipalDerivedId")!, principalBase.FindProperty("PrincipalDerivedId")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeArray")!, principalBase.FindProperty("RefTypeArray")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeEnumerable")!, principalBase.FindProperty("RefTypeEnumerable")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeIList")!, principalBase.FindProperty("RefTypeIList")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter0, principalBase_UpdateUSproc.FindParameter("RefTypeList")!, principalBase.FindProperty("RefTypeList")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeArray")!, principalBase.FindProperty("ValueTypeArray")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeEnumerable")!, principalBase.FindProperty("ValueTypeEnumerable")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeIList")!, principalBase.FindProperty("ValueTypeIList")!, principalBase_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter0, principalBase_UpdateUSproc.FindParameter("ValueTypeList")!, principalBase.FindProperty("ValueTypeList")!, principalBase_UpdateSprocMapping);

            var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>")!;

            var defaultTableMappings1 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings1);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", null, relationalModel);
            var enum1ColumnBase0 = new ColumnBase<ColumnMappingBase>("Enum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Enum1", enum1ColumnBase0);
            var enum2ColumnBase0 = new ColumnBase<ColumnMappingBase>("Enum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Enum2", enum2ColumnBase0);
            var flagsEnum1ColumnBase0 = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase0);
            var flagsEnum2ColumnBase0 = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase0);
            var idColumnBase1 = new ColumnBase<ColumnMappingBase>("Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase1);
            var principalBaseIdColumnBase0 = new ColumnBase<ColumnMappingBase>("PrincipalBaseId", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalBaseId", principalBaseIdColumnBase0);
            var principalDerivedDependentBasebyteIdColumnBase0 = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>Id", "bigint", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumnBase0);
            var refTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase0);
            var refTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase0);
            var refTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase0);
            var refTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("RefTypeList", refTypeListColumnBase0);
            var valueTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase0);
            var valueTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase0);
            var valueTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase0);
            var valueTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "nvarchar(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase0);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, false);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings1.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase0, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase0, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase0, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase0, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase0, principalDerived.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteIdColumnBase0, principalDerived.FindProperty("PrincipalDerivedId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase0, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase0, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase0, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase0, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase0, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase0, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase0, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase0, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings1 = new List<TableMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings1);
            var principalDerivedTable = new Table("PrincipalDerived", "TPC", relationalModel);
            var idColumn1 = new Column("Id", "bigint", principalDerivedTable);
            principalDerivedTable.Columns.Add("Id", idColumn1);
            var enum1Column0 = new Column("Enum1", "int", principalDerivedTable);
            principalDerivedTable.Columns.Add("Enum1", enum1Column0);
            var enum2Column0 = new Column("Enum2", "int", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("Enum2", enum2Column0);
            var flagsEnum1Column0 = new Column("FlagsEnum1", "int", principalDerivedTable);
            principalDerivedTable.Columns.Add("FlagsEnum1", flagsEnum1Column0);
            var flagsEnum2Column0 = new Column("FlagsEnum2", "int", principalDerivedTable);
            principalDerivedTable.Columns.Add("FlagsEnum2", flagsEnum2Column0);
            var principalBaseIdColumn0 = new Column("PrincipalBaseId", "bigint", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn0);
            var principalDerivedDependentBasebyteIdColumn0 = new Column("PrincipalDerived<DependentBase<byte?>>Id", "bigint", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn0);
            var refTypeArrayColumn0 = new Column("RefTypeArray", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
            var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
            var refTypeIListColumn0 = new Column("RefTypeIList", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
            var refTypeListColumn0 = new Column("RefTypeList", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("RefTypeList", refTypeListColumn0);
            var valueTypeArrayColumn0 = new Column("ValueTypeArray", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
            var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
            var valueTypeIListColumn0 = new Column("ValueTypeIList", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
            var valueTypeListColumn0 = new Column("ValueTypeList", "nvarchar(max)", principalDerivedTable)
            {
                IsNullable = true
            };
            principalDerivedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
            var pK_PrincipalDerived = new UniqueConstraint("PK_PrincipalDerived", principalDerivedTable, new[] { idColumn1 });
            principalDerivedTable.PrimaryKey = pK_PrincipalDerived;
            var pK_PrincipalDerivedUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            pK_PrincipalDerived.MappedKeys.Add(pK_PrincipalDerivedUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalDerivedUc).Add(pK_PrincipalDerived);
            principalDerivedTable.UniqueConstraints.Add("PK_PrincipalDerived", pK_PrincipalDerived);
            var iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId = new TableIndex(
            "IX_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalDerivedTable, new[] { principalDerivedDependentBasebyteIdColumn0 }, false);
            var iX_PrincipalDerived_PrincipalDerivedDependentBasebyteIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "PrincipalDerivedId" });
            iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId.MappedIndexes.Add(iX_PrincipalDerived_PrincipalDerivedDependentBasebyteIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalDerived_PrincipalDerivedDependentBasebyteIdIx).Add(iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            principalDerivedTable.Indexes.Add("IX_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            var pIX0 = new TableIndex(
            "PIX", principalDerivedTable, new[] { principalBaseIdColumn0 }, true);
            var pIX0Ix = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                "PrincipalIndex");
            pIX0.MappedIndexes.Add(pIX0Ix);
            RelationalModel.GetOrCreateTableIndexes(pIX0Ix).Add(pIX0);
            principalDerivedTable.Indexes.Add("PIX", pIX0);
            relationalModel.Tables.Add(("PrincipalDerived", "TPC"), principalDerivedTable);
            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, false);
            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
            tableMappings1.Add(principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(idColumn1, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column0, principalDerived.FindProperty("Enum1")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column0, principalDerived.FindProperty("Enum2")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column0, principalDerived.FindProperty("FlagsEnum1")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column0, principalDerived.FindProperty("FlagsEnum2")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn0, principalDerived.FindProperty("PrincipalBaseId")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn0, principalDerived.FindProperty("PrincipalDerivedId")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn0, principalDerived.FindProperty("RefTypeArray")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn0, principalDerived.FindProperty("RefTypeEnumerable")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn0, principalDerived.FindProperty("RefTypeIList")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn0, principalDerived.FindProperty("RefTypeList")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn0, principalDerived.FindProperty("ValueTypeArray")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, principalDerived.FindProperty("ValueTypeEnumerable")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn0, principalDerived.FindProperty("ValueTypeIList")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn0, principalDerived.FindProperty("ValueTypeList")!, principalDerivedTableMapping);

            var viewMappings0 = new List<ViewMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:ViewMappings", viewMappings0);
            var principalDerivedViewView = new View("PrincipalDerivedView", "TPC", relationalModel);
            var enum1ViewColumn0 = new ViewColumn("Enum1", "int", principalDerivedViewView);
            principalDerivedViewView.Columns.Add("Enum1", enum1ViewColumn0);
            var enum2ViewColumn0 = new ViewColumn("Enum2", "int", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("Enum2", enum2ViewColumn0);
            var flagsEnum1ViewColumn0 = new ViewColumn("FlagsEnum1", "int", principalDerivedViewView);
            principalDerivedViewView.Columns.Add("FlagsEnum1", flagsEnum1ViewColumn0);
            var flagsEnum2ViewColumn0 = new ViewColumn("FlagsEnum2", "int", principalDerivedViewView);
            principalDerivedViewView.Columns.Add("FlagsEnum2", flagsEnum2ViewColumn0);
            var idViewColumn0 = new ViewColumn("Id", "bigint", principalDerivedViewView);
            principalDerivedViewView.Columns.Add("Id", idViewColumn0);
            var principalBaseIdViewColumn0 = new ViewColumn("PrincipalBaseId", "bigint", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("PrincipalBaseId", principalBaseIdViewColumn0);
            var principalDerivedIdViewColumn0 = new ViewColumn("PrincipalDerivedId", "bigint", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("PrincipalDerivedId", principalDerivedIdViewColumn0);
            var refTypeArrayViewColumn0 = new ViewColumn("RefTypeArray", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("RefTypeArray", refTypeArrayViewColumn0);
            var refTypeEnumerableViewColumn0 = new ViewColumn("RefTypeEnumerable", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("RefTypeEnumerable", refTypeEnumerableViewColumn0);
            var refTypeIListViewColumn0 = new ViewColumn("RefTypeIList", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("RefTypeIList", refTypeIListViewColumn0);
            var refTypeListViewColumn0 = new ViewColumn("RefTypeList", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("RefTypeList", refTypeListViewColumn0);
            var valueTypeArrayViewColumn0 = new ViewColumn("ValueTypeArray", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("ValueTypeArray", valueTypeArrayViewColumn0);
            var valueTypeEnumerableViewColumn0 = new ViewColumn("ValueTypeEnumerable", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableViewColumn0);
            var valueTypeIListViewColumn0 = new ViewColumn("ValueTypeIList", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("ValueTypeIList", valueTypeIListViewColumn0);
            var valueTypeListViewColumn0 = new ViewColumn("ValueTypeList", "nvarchar(max)", principalDerivedViewView)
            {
                IsNullable = true
            };
            principalDerivedViewView.Columns.Add("ValueTypeList", valueTypeListViewColumn0);
            relationalModel.Views.Add(("PrincipalDerivedView", "TPC"), principalDerivedViewView);
            var principalDerivedViewViewMapping = new ViewMapping(principalDerived, principalDerivedViewView, false);
            principalDerivedViewView.AddTypeMapping(principalDerivedViewViewMapping, false);
            viewMappings0.Add(principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(idViewColumn0, principalDerived.FindProperty("Id")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(enum1ViewColumn0, principalDerived.FindProperty("Enum1")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(enum2ViewColumn0, principalDerived.FindProperty("Enum2")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(flagsEnum1ViewColumn0, principalDerived.FindProperty("FlagsEnum1")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(flagsEnum2ViewColumn0, principalDerived.FindProperty("FlagsEnum2")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(principalBaseIdViewColumn0, principalDerived.FindProperty("PrincipalBaseId")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(principalDerivedIdViewColumn0, principalDerived.FindProperty("PrincipalDerivedId")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeArrayViewColumn0, principalDerived.FindProperty("RefTypeArray")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeEnumerableViewColumn0, principalDerived.FindProperty("RefTypeEnumerable")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeIListViewColumn0, principalDerived.FindProperty("RefTypeIList")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(refTypeListViewColumn0, principalDerived.FindProperty("RefTypeList")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeArrayViewColumn0, principalDerived.FindProperty("ValueTypeArray")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeEnumerableViewColumn0, principalDerived.FindProperty("ValueTypeEnumerable")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeIListViewColumn0, principalDerived.FindProperty("ValueTypeIList")!, principalDerivedViewViewMapping);
            RelationalModel.CreateViewColumnMapping(valueTypeListViewColumn0, principalDerived.FindProperty("ValueTypeList")!, principalDerivedViewViewMapping);

            var deleteSprocMappings0 = new List<StoredProcedureMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:DeleteStoredProcedureMappings", deleteSprocMappings0);
            var derived_DeleteStoreSproc = new StoreStoredProcedure("Derived_Delete", "TPC", relationalModel);
            var id_OriginalParameter1 = new StoreStoredProcedureParameter("Id_Original", "bigint", 0, derived_DeleteStoreSproc, System.Data.ParameterDirection.Input);
            derived_DeleteStoreSproc.AddParameter(id_OriginalParameter1);
            derived_DeleteStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalDerived.GetDeleteStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("Derived_Delete", "TPC"), derived_DeleteStoreSproc);
            var derived_DeleteDSproc = (IRuntimeStoredProcedure)principalDerived.GetDeleteStoredProcedure()!;
            var derived_DeleteSprocMapping = new StoredProcedureMapping(principalDerived, derived_DeleteStoreSproc, (IRuntimeStoredProcedure)principalDerived.GetDeleteStoredProcedure()!, principalDerivedTableMapping, false);
            derived_DeleteStoreSproc.AddTypeMapping(derived_DeleteSprocMapping, false);
            deleteSprocMappings0.Add(derived_DeleteSprocMapping);
            principalDerivedTableMapping.DeleteStoredProcedureMapping = derived_DeleteSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter1, derived_DeleteDSproc.FindParameter("Id_Original")!, principalDerived.FindProperty("Id")!, derived_DeleteSprocMapping);

            var insertSprocMappings0 = new List<StoredProcedureMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:InsertStoredProcedureMappings", insertSprocMappings0);
            var derived_InsertStoreSproc = new StoreStoredProcedure("Derived_Insert", "TPC", relationalModel);
            var principalBaseIdParameter1 = new StoreStoredProcedureParameter("PrincipalBaseId", "bigint", 0, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(principalBaseIdParameter1);
            var principalDerivedIdParameter1 = new StoreStoredProcedureParameter("PrincipalDerivedId", "bigint", 1, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(principalDerivedIdParameter1);
            var enum1Parameter1 = new StoreStoredProcedureParameter("Enum1", "int", 2, derived_InsertStoreSproc, System.Data.ParameterDirection.Input);
            derived_InsertStoreSproc.AddParameter(enum1Parameter1);
            var enum2Parameter1 = new StoreStoredProcedureParameter("Enum2", "int", 3, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(enum2Parameter1);
            var flagsEnum1Parameter1 = new StoreStoredProcedureParameter("FlagsEnum1", "int", 4, derived_InsertStoreSproc, System.Data.ParameterDirection.Input);
            derived_InsertStoreSproc.AddParameter(flagsEnum1Parameter1);
            var flagsEnum2Parameter1 = new StoreStoredProcedureParameter("FlagsEnum2", "int", 5, derived_InsertStoreSproc, System.Data.ParameterDirection.Input);
            derived_InsertStoreSproc.AddParameter(flagsEnum2Parameter1);
            var valueTypeListParameter1 = new StoreStoredProcedureParameter("ValueTypeList", "nvarchar(max)", 6, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(valueTypeListParameter1);
            var valueTypeIListParameter1 = new StoreStoredProcedureParameter("ValueTypeIList", "nvarchar(max)", 7, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(valueTypeIListParameter1);
            var valueTypeArrayParameter1 = new StoreStoredProcedureParameter("ValueTypeArray", "nvarchar(max)", 8, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(valueTypeArrayParameter1);
            var valueTypeEnumerableParameter1 = new StoreStoredProcedureParameter("ValueTypeEnumerable", "nvarchar(max)", 9, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(valueTypeEnumerableParameter1);
            var refTypeListParameter1 = new StoreStoredProcedureParameter("RefTypeList", "nvarchar(max)", 10, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(refTypeListParameter1);
            var refTypeIListParameter1 = new StoreStoredProcedureParameter("RefTypeIList", "nvarchar(max)", 11, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(refTypeIListParameter1);
            var refTypeArrayParameter1 = new StoreStoredProcedureParameter("RefTypeArray", "nvarchar(max)", 12, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(refTypeArrayParameter1);
            var refTypeEnumerableParameter1 = new StoreStoredProcedureParameter("RefTypeEnumerable", "nvarchar(max)", 13, derived_InsertStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_InsertStoreSproc.AddParameter(refTypeEnumerableParameter1);
            var derivedIdFunctionColumn = new StoreStoredProcedureResultColumn("DerivedId", "bigint", 0, derived_InsertStoreSproc);
            derived_InsertStoreSproc.AddResultColumn(derivedIdFunctionColumn);
            derived_InsertStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalDerived.GetInsertStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("Derived_Insert", "TPC"), derived_InsertStoreSproc);
            var derived_InsertISproc = (IRuntimeStoredProcedure)principalDerived.GetInsertStoredProcedure()!;
            var derived_InsertSprocMapping = new StoredProcedureMapping(principalDerived, derived_InsertStoreSproc, (IRuntimeStoredProcedure)principalDerived.GetInsertStoredProcedure()!, principalDerivedTableMapping, false);
            derived_InsertStoreSproc.AddTypeMapping(derived_InsertSprocMapping, false);
            insertSprocMappings0.Add(derived_InsertSprocMapping);
            principalDerivedTableMapping.InsertStoredProcedureMapping = derived_InsertSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter1, derived_InsertISproc.FindParameter("Enum1")!, principalDerived.FindProperty("Enum1")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter1, derived_InsertISproc.FindParameter("Enum2")!, principalDerived.FindProperty("Enum2")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter1, derived_InsertISproc.FindParameter("FlagsEnum1")!, principalDerived.FindProperty("FlagsEnum1")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter1, derived_InsertISproc.FindParameter("FlagsEnum2")!, principalDerived.FindProperty("FlagsEnum2")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter1, derived_InsertISproc.FindParameter("PrincipalBaseId")!, principalDerived.FindProperty("PrincipalBaseId")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalDerivedIdParameter1, derived_InsertISproc.FindParameter("PrincipalDerivedId")!, principalDerived.FindProperty("PrincipalDerivedId")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter1, derived_InsertISproc.FindParameter("RefTypeArray")!, principalDerived.FindProperty("RefTypeArray")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter1, derived_InsertISproc.FindParameter("RefTypeEnumerable")!, principalDerived.FindProperty("RefTypeEnumerable")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter1, derived_InsertISproc.FindParameter("RefTypeIList")!, principalDerived.FindProperty("RefTypeIList")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter1, derived_InsertISproc.FindParameter("RefTypeList")!, principalDerived.FindProperty("RefTypeList")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter1, derived_InsertISproc.FindParameter("ValueTypeArray")!, principalDerived.FindProperty("ValueTypeArray")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter1, derived_InsertISproc.FindParameter("ValueTypeEnumerable")!, principalDerived.FindProperty("ValueTypeEnumerable")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter1, derived_InsertISproc.FindParameter("ValueTypeIList")!, principalDerived.FindProperty("ValueTypeIList")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter1, derived_InsertISproc.FindParameter("ValueTypeList")!, principalDerived.FindProperty("ValueTypeList")!, derived_InsertSprocMapping);
            RelationalModel.CreateStoredProcedureResultColumnMapping(derivedIdFunctionColumn, derived_InsertISproc.FindResultColumn("DerivedId")!, principalDerived.FindProperty("Id")!, derived_InsertSprocMapping);

            var updateSprocMappings0 = new List<StoredProcedureMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:UpdateStoredProcedureMappings", updateSprocMappings0);
            var derived_UpdateStoreSproc = new StoreStoredProcedure("Derived_Update", "Derived", relationalModel);
            var principalBaseIdParameter2 = new StoreStoredProcedureParameter("PrincipalBaseId", "bigint", 0, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(principalBaseIdParameter2);
            var principalDerivedIdParameter2 = new StoreStoredProcedureParameter("PrincipalDerivedId", "bigint", 1, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(principalDerivedIdParameter2);
            var enum1Parameter2 = new StoreStoredProcedureParameter("Enum1", "int", 2, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            derived_UpdateStoreSproc.AddParameter(enum1Parameter2);
            var enum2Parameter2 = new StoreStoredProcedureParameter("Enum2", "int", 3, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(enum2Parameter2);
            var flagsEnum1Parameter2 = new StoreStoredProcedureParameter("FlagsEnum1", "int", 4, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            derived_UpdateStoreSproc.AddParameter(flagsEnum1Parameter2);
            var flagsEnum2Parameter2 = new StoreStoredProcedureParameter("FlagsEnum2", "int", 5, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            derived_UpdateStoreSproc.AddParameter(flagsEnum2Parameter2);
            var valueTypeListParameter2 = new StoreStoredProcedureParameter("ValueTypeList", "nvarchar(max)", 6, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(valueTypeListParameter2);
            var valueTypeIListParameter2 = new StoreStoredProcedureParameter("ValueTypeIList", "nvarchar(max)", 7, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(valueTypeIListParameter2);
            var valueTypeArrayParameter2 = new StoreStoredProcedureParameter("ValueTypeArray", "nvarchar(max)", 8, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(valueTypeArrayParameter2);
            var valueTypeEnumerableParameter2 = new StoreStoredProcedureParameter("ValueTypeEnumerable", "nvarchar(max)", 9, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(valueTypeEnumerableParameter2);
            var refTypeListParameter2 = new StoreStoredProcedureParameter("RefTypeList", "nvarchar(max)", 10, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(refTypeListParameter2);
            var refTypeIListParameter2 = new StoreStoredProcedureParameter("RefTypeIList", "nvarchar(max)", 11, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(refTypeIListParameter2);
            var refTypeArrayParameter2 = new StoreStoredProcedureParameter("RefTypeArray", "nvarchar(max)", 12, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(refTypeArrayParameter2);
            var refTypeEnumerableParameter2 = new StoreStoredProcedureParameter("RefTypeEnumerable", "nvarchar(max)", 13, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input)
            {
                IsNullable = true
            };
            derived_UpdateStoreSproc.AddParameter(refTypeEnumerableParameter2);
            var id_OriginalParameter2 = new StoreStoredProcedureParameter("Id_Original", "bigint", 14, derived_UpdateStoreSproc, System.Data.ParameterDirection.Input);
            derived_UpdateStoreSproc.AddParameter(id_OriginalParameter2);
            derived_UpdateStoreSproc.AddStoredProcedure((IRuntimeStoredProcedure)principalDerived.GetUpdateStoredProcedure()!);
            relationalModel.StoredProcedures.Add(("Derived_Update", "Derived"), derived_UpdateStoreSproc);
            var derived_UpdateUSproc = (IRuntimeStoredProcedure)principalDerived.GetUpdateStoredProcedure()!;
            var derived_UpdateSprocMapping = new StoredProcedureMapping(principalDerived, derived_UpdateStoreSproc, (IRuntimeStoredProcedure)principalDerived.GetUpdateStoredProcedure()!, principalDerivedTableMapping, false);
            derived_UpdateStoreSproc.AddTypeMapping(derived_UpdateSprocMapping, false);
            updateSprocMappings0.Add(derived_UpdateSprocMapping);
            principalDerivedTableMapping.UpdateStoredProcedureMapping = derived_UpdateSprocMapping;
            RelationalModel.CreateStoredProcedureParameterMapping(id_OriginalParameter2, derived_UpdateUSproc.FindParameter("Id_Original")!, principalDerived.FindProperty("Id")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum1Parameter2, derived_UpdateUSproc.FindParameter("Enum1")!, principalDerived.FindProperty("Enum1")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(enum2Parameter2, derived_UpdateUSproc.FindParameter("Enum2")!, principalDerived.FindProperty("Enum2")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum1Parameter2, derived_UpdateUSproc.FindParameter("FlagsEnum1")!, principalDerived.FindProperty("FlagsEnum1")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(flagsEnum2Parameter2, derived_UpdateUSproc.FindParameter("FlagsEnum2")!, principalDerived.FindProperty("FlagsEnum2")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalBaseIdParameter2, derived_UpdateUSproc.FindParameter("PrincipalBaseId")!, principalDerived.FindProperty("PrincipalBaseId")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(principalDerivedIdParameter2, derived_UpdateUSproc.FindParameter("PrincipalDerivedId")!, principalDerived.FindProperty("PrincipalDerivedId")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeArrayParameter2, derived_UpdateUSproc.FindParameter("RefTypeArray")!, principalDerived.FindProperty("RefTypeArray")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeEnumerableParameter2, derived_UpdateUSproc.FindParameter("RefTypeEnumerable")!, principalDerived.FindProperty("RefTypeEnumerable")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeIListParameter2, derived_UpdateUSproc.FindParameter("RefTypeIList")!, principalDerived.FindProperty("RefTypeIList")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(refTypeListParameter2, derived_UpdateUSproc.FindParameter("RefTypeList")!, principalDerived.FindProperty("RefTypeList")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeArrayParameter2, derived_UpdateUSproc.FindParameter("ValueTypeArray")!, principalDerived.FindProperty("ValueTypeArray")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeEnumerableParameter2, derived_UpdateUSproc.FindParameter("ValueTypeEnumerable")!, principalDerived.FindProperty("ValueTypeEnumerable")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeIListParameter2, derived_UpdateUSproc.FindParameter("ValueTypeIList")!, principalDerived.FindProperty("ValueTypeIList")!, derived_UpdateSprocMapping);
            RelationalModel.CreateStoredProcedureParameterMapping(valueTypeListParameter2, derived_UpdateUSproc.FindParameter("ValueTypeList")!, principalDerived.FindProperty("ValueTypeList")!, derived_UpdateSprocMapping);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId", dependentBasebyteTable, principalDerivedTable,
                new[] { principalIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK_PrincipalDerived")!, ReferentialAction.NoAction);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id" });
            fK_DependentBasebyte_PrincipalDerived_PrincipalId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalDerived_PrincipalIdFk).Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId);
            var fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId = new ForeignKeyConstraint(
                "FK_PrincipalBase_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalBaseTable, principalDerivedTable,
                new[] { principalDerivedDependentBasebyteIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK_PrincipalDerived")!, ReferentialAction.NoAction);
            var fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "PrincipalDerivedId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id" });
            fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId.MappedForeignKeys.Add(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk).Add(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            principalBaseTable.ForeignKeyConstraints.Add(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            var fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId = new ForeignKeyConstraint(
                "FK_PrincipalDerived_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalDerivedTable, principalDerivedTable,
                new[] { principalDerivedDependentBasebyteIdColumn0 },
                principalDerivedTable.FindUniqueConstraint("PK_PrincipalDerived")!, ReferentialAction.NoAction);
            var fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "PrincipalDerivedId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id" });
            fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId.MappedForeignKeys.Add(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk).Add(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            principalDerivedTable.ForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalId = runtimeEntityType.AddProperty(
                "PrincipalId",
                typeof(long?),
                nullable: true);
            principalId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            principalId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientCascade,
                unique: true,
                requiredDependent: true);

            var principal = declaringEntityType.AddNavigation("Principal",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation("Dependent",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Dependent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Dependent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", "TPC");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorValue: "PrincipalBase");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var idDerived_Insert = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.InsertStoredProcedure("Derived_Insert", "TPC"),
                true,
                "DerivedId");
            overrides.Add(StoreObjectIdentifier.InsertStoredProcedure("Derived_Insert", "TPC"), idDerived_Insert);
            var idPrincipalBaseView = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.View("PrincipalBaseView", "TPC"),
                false,
                null);
            idPrincipalBaseView.AddAnnotation("foo", "bar2");
            overrides.Add(StoreObjectIdentifier.View("PrincipalBaseView", "TPC"), idPrincipalBaseView);
            id.AddAnnotation("Relational:RelationalOverrides", overrides);

            id.AddAnnotation("Relational:DefaultValueSql", "NEXT VALUE FOR [TPC].[PrincipalBaseSequence]");
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.Sequence);

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AnEnum)0);
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum1.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum2.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long?),
                nullable: true);
            principalBaseId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            principalBaseId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var principalDerivedId = runtimeEntityType.AddProperty(
                "PrincipalDerivedId",
                typeof(long?),
                nullable: true);
            principalDerivedId.TypeMapping = SqlServerLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            principalDerivedId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    keyComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(max)",
                        dbType: System.Data.DbType.String),
                    storeTypePostfix: StoreTypePostfix.None));
            refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqlServerStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "nvarchar(45)",
                        size: 45,
                        dbType: System.Data.DbType.String),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));
            refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    JsonDateTimeReaderWriter.Instance),
                elementMapping: SqlServerDateTimeTypeMapping.Default.Clone(
                    comparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    keyComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v),
                    providerValueComparer: new ValueComparer<DateTime>(
                        (DateTime v1, DateTime v2) => v1.Equals(v2),
                        (DateTime v) => v.GetHashCode(),
                        (DateTime v) => v)));
            valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: SqlServerByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v)));
            valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(max)",
                    dbType: System.Data.DbType.String),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                storeTypePostfix: StoreTypePostfix.None,
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: SqlServerShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v)));
            valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalDerivedId });

            var principalIndex = runtimeEntityType.AddIndex(
                new[] { principalBaseId },
                name: "PrincipalIndex",
                unique: true);
            principalIndex.AddAnnotation("Relational:Name", "PIX");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType);

            var deriveds = principalEntityType.AddNavigation("Deriveds",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalDerivedId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType);

            var principals = principalEntityType.AddNavigation("Principals",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Principals", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Principals>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var insertSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Insert",
                "TPC",
                false);

            var principalBaseId = insertSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var principalDerivedId = insertSproc.AddParameter(
                "PrincipalDerivedId", System.Data.ParameterDirection.Input, false, "PrincipalDerivedId", false);
            var enum1 = insertSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum2 = insertSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum1 = insertSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum2 = insertSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList = insertSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList = insertSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray = insertSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable = insertSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList = insertSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList = insertSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray = insertSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable = insertSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var id = insertSproc.AddParameter(
                "BaseId", System.Data.ParameterDirection.Output, false, "Id", false);
            id.AddAnnotation("foo", "bar");
            insertSproc.AddAnnotation("foo", "bar1");
            runtimeEntityType.AddAnnotation("Relational:InsertStoredProcedure", insertSproc);

            var deleteSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Delete",
                "TPC",
                true);

            var id0 = deleteSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:DeleteStoredProcedure", deleteSproc);

            var updateSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "PrincipalBase_Update",
                "TPC",
                false);

            var principalBaseId0 = updateSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var principalDerivedId0 = updateSproc.AddParameter(
                "PrincipalDerivedId", System.Data.ParameterDirection.Input, false, "PrincipalDerivedId", false);
            var enum10 = updateSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum20 = updateSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum10 = updateSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum20 = updateSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList0 = updateSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList0 = updateSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray0 = updateSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable0 = updateSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList0 = updateSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList0 = updateSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray0 = updateSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable0 = updateSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var id1 = updateSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:UpdateStoredProcedure", updateSproc);

            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPC");
            runtimeEntityType.AddAnnotation("Relational:Schema", "TPC");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewDefinitionSql", null);
            runtimeEntityType.AddAnnotation("Relational:ViewName", "PrincipalBaseView");
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", "TPC");

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorValue: "PrincipalDerived<DependentBase<byte?>>");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var insertSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "Derived_Insert",
                "TPC",
                false);

            var principalBaseId = insertSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var principalDerivedId = insertSproc.AddParameter(
                "PrincipalDerivedId", System.Data.ParameterDirection.Input, false, "PrincipalDerivedId", false);
            var enum1 = insertSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum2 = insertSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum1 = insertSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum2 = insertSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList = insertSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList = insertSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray = insertSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable = insertSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList = insertSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList = insertSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray = insertSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable = insertSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var derivedId = insertSproc.AddResultColumn(
                "DerivedId", false, "Id");
            derivedId.AddAnnotation("foo", "bar3");
            runtimeEntityType.AddAnnotation("Relational:InsertStoredProcedure", insertSproc);

            var deleteSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "Derived_Delete",
                "TPC",
                false);

            var id = deleteSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:DeleteStoredProcedure", deleteSproc);

            var updateSproc = new RuntimeStoredProcedure(
                runtimeEntityType,
                "Derived_Update",
                "Derived",
                false);

            var principalBaseId0 = updateSproc.AddParameter(
                "PrincipalBaseId", System.Data.ParameterDirection.Input, false, "PrincipalBaseId", false);
            var principalDerivedId0 = updateSproc.AddParameter(
                "PrincipalDerivedId", System.Data.ParameterDirection.Input, false, "PrincipalDerivedId", false);
            var enum10 = updateSproc.AddParameter(
                "Enum1", System.Data.ParameterDirection.Input, false, "Enum1", false);
            var enum20 = updateSproc.AddParameter(
                "Enum2", System.Data.ParameterDirection.Input, false, "Enum2", false);
            var flagsEnum10 = updateSproc.AddParameter(
                "FlagsEnum1", System.Data.ParameterDirection.Input, false, "FlagsEnum1", false);
            var flagsEnum20 = updateSproc.AddParameter(
                "FlagsEnum2", System.Data.ParameterDirection.Input, false, "FlagsEnum2", false);
            var valueTypeList0 = updateSproc.AddParameter(
                "ValueTypeList", System.Data.ParameterDirection.Input, false, "ValueTypeList", false);
            var valueTypeIList0 = updateSproc.AddParameter(
                "ValueTypeIList", System.Data.ParameterDirection.Input, false, "ValueTypeIList", false);
            var valueTypeArray0 = updateSproc.AddParameter(
                "ValueTypeArray", System.Data.ParameterDirection.Input, false, "ValueTypeArray", false);
            var valueTypeEnumerable0 = updateSproc.AddParameter(
                "ValueTypeEnumerable", System.Data.ParameterDirection.Input, false, "ValueTypeEnumerable", false);
            var refTypeList0 = updateSproc.AddParameter(
                "RefTypeList", System.Data.ParameterDirection.Input, false, "RefTypeList", false);
            var refTypeIList0 = updateSproc.AddParameter(
                "RefTypeIList", System.Data.ParameterDirection.Input, false, "RefTypeIList", false);
            var refTypeArray0 = updateSproc.AddParameter(
                "RefTypeArray", System.Data.ParameterDirection.Input, false, "RefTypeArray", false);
            var refTypeEnumerable0 = updateSproc.AddParameter(
                "RefTypeEnumerable", System.Data.ParameterDirection.Input, false, "RefTypeEnumerable", false);
            var id0 = updateSproc.AddParameter(
                "Id_Original", System.Data.ParameterDirection.Input, false, "Id", true);
            runtimeEntityType.AddAnnotation("Relational:UpdateStoredProcedure", updateSproc);

            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", "TPC");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalDerived");
            runtimeEntityType.AddAnnotation("Relational:ViewDefinitionSql", null);
            runtimeEntityType.AddAnnotation("Relational:ViewName", "PrincipalDerivedView");
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", "TPC");

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Equal("TPC", model.GetDefaultSchema());
                    Assert.Null(model[SqlServerAnnotationNames.MaxDatabaseSize]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetDatabaseMaxSize()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.PerformanceLevelSql]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPerformanceLevelSql()).Message);
                    Assert.Null(model[SqlServerAnnotationNames.ServiceTierSql]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetServiceTierSql()).Message);

                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    var id = principalBase.FindProperty("Id");

                    Assert.Equal("Id", id.GetColumnName());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Equal("TPC", principalBase.GetSchema());
                    Assert.Equal("Id", id.GetColumnName(StoreObjectIdentifier.Create(principalBase, StoreObjectType.Table).Value));
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.Table).Value));

                    Assert.Equal("PrincipalBaseView", principalBase.GetViewName());
                    Assert.Equal("TPC", principalBase.GetViewSchema());
                    Assert.Equal("Id", id.GetColumnName(StoreObjectIdentifier.Create(principalBase, StoreObjectType.View).Value));
                    Assert.Equal(
                        "bar2",
                        id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.View).Value)["foo"]);

                    var principalBaseId = principalBase.FindProperty("PrincipalBaseId");

                    var alternateIndex = principalBase.GetIndexes().Last();
                    Assert.Same(principalBaseId, alternateIndex.Properties.Single());
                    Assert.True(alternateIndex.IsUnique);
                    Assert.Equal("PrincipalIndex", alternateIndex.Name);
                    Assert.Equal("PIX", alternateIndex.GetDatabaseName());
                    Assert.Null(alternateIndex[RelationalAnnotationNames.Filter]);
                    Assert.Null(alternateIndex.GetFilter());
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.Clustered]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.IsClustered()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.CreatedOnline]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.IsCreatedOnline()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.FillFactor]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetFillFactor()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.Include]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetIncludeProperties()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.SortInTempDb]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetSortInTempDb()).Message);
                    Assert.Null(alternateIndex[SqlServerAnnotationNames.DataCompression]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => alternateIndex.GetDataCompression()).Message);

                    Assert.Equal(new[] { alternateIndex }, principalBaseId.GetContainingIndexes());

                    var insertSproc = principalBase.GetInsertStoredProcedure()!;
                    Assert.Equal("PrincipalBase_Insert", insertSproc.Name);
                    Assert.Equal("TPC", insertSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Enum1", "Enum2", "FlagsEnum1", "FlagsEnum2", "ValueTypeList", "ValueTypeIList", "ValueTypeArray", "ValueTypeEnumerable", "RefTypeList", "RefTypeIList", "RefTypeArray", "RefTypeEnumerable", "Id" },
                        insertSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(insertSproc.ResultColumns);
                    Assert.False(insertSproc.IsRowsAffectedReturned);
                    Assert.Equal("bar1", insertSproc["foo"]);
                    Assert.Same(principalBase, insertSproc.EntityType);
                    Assert.Equal("BaseId", insertSproc.Parameters.Last().Name);
                    Assert.Equal("bar", insertSproc.Parameters.Last()["foo"]);
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.InsertStoredProcedure).Value));

                    var updateSproc = principalBase.GetUpdateStoredProcedure()!;
                    Assert.Equal("PrincipalBase_Update", updateSproc.Name);
                    Assert.Equal("TPC", updateSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Enum1", "Enum2", "FlagsEnum1", "FlagsEnum2", "ValueTypeList", "ValueTypeIList", "ValueTypeArray", "ValueTypeEnumerable", "RefTypeList", "RefTypeIList", "RefTypeArray", "RefTypeEnumerable", "Id" },
                        updateSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(updateSproc.ResultColumns);
                    Assert.False(updateSproc.IsRowsAffectedReturned);
                    Assert.Empty(updateSproc.GetAnnotations());
                    Assert.Same(principalBase, updateSproc.EntityType);
                    Assert.Equal("Id_Original", updateSproc.Parameters.Last().Name);
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.UpdateStoredProcedure).Value));

                    var deleteSproc = principalBase.GetDeleteStoredProcedure()!;
                    Assert.Equal("PrincipalBase_Delete", deleteSproc.Name);
                    Assert.Equal("TPC", deleteSproc.Schema);
                    Assert.Equal(new[] { "Id_Original" }, deleteSproc.Parameters.Select(p => p.Name));
                    Assert.Empty(deleteSproc.ResultColumns);
                    Assert.True(deleteSproc.IsRowsAffectedReturned);
                    Assert.Same(principalBase, deleteSproc.EntityType);
                    Assert.Equal("Id_Original", deleteSproc.Parameters.Last().Name);
                    Assert.Null(id.FindOverrides(StoreObjectIdentifier.Create(principalBase, StoreObjectType.DeleteStoredProcedure).Value));

                    Assert.Equal("PrincipalBase", principalBase.GetDiscriminatorValue());
                    Assert.Null(principalBase.FindDiscriminatorProperty());
                    Assert.Equal("TPC", principalBase.GetMappingStrategy());

                    var selfRefNavigation = principalBase.GetDeclaredNavigations().Last();
                    Assert.Equal("Deriveds", selfRefNavigation.Name);
                    Assert.True(selfRefNavigation.IsCollection);
                    Assert.False(selfRefNavigation.IsOnDependent);
                    Assert.Equal(principalBase, selfRefNavigation.TargetEntityType);
                    Assert.Null(selfRefNavigation.Inverse);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);

                    Assert.Equal("PrincipalDerived", principalDerived.GetTableName());
                    Assert.Equal("TPC", principalDerived.GetSchema());
                    Assert.Equal("PrincipalDerivedView", principalDerived.GetViewName());
                    Assert.Equal("TPC", principalBase.GetViewSchema());

                    insertSproc = principalDerived.GetInsertStoredProcedure()!;
                    Assert.Equal("Derived_Insert", insertSproc.Name);
                    Assert.Equal("TPC", insertSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Enum1", "Enum2", "FlagsEnum1", "FlagsEnum2", "ValueTypeList", "ValueTypeIList", "ValueTypeArray", "ValueTypeEnumerable", "RefTypeList", "RefTypeIList", "RefTypeArray", "RefTypeEnumerable" },
                        insertSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Equal(new[] { "Id" }, insertSproc.ResultColumns.Select(p => p.PropertyName));
                    Assert.Null(insertSproc["foo"]);
                    Assert.Same(principalDerived, insertSproc.EntityType);
                    Assert.Equal("DerivedId", insertSproc.ResultColumns.Last().Name);
                    Assert.Equal(
                        "DerivedId",
                        id.GetColumnName(StoreObjectIdentifier.Create(principalDerived, StoreObjectType.InsertStoredProcedure).Value));
                    Assert.Equal("bar3", insertSproc.ResultColumns.Last()["foo"]);
                    Assert.Null(
                        id.FindOverrides(
                            StoreObjectIdentifier.Create(principalDerived, StoreObjectType.InsertStoredProcedure).Value)["foo"]);

                    updateSproc = principalDerived.GetUpdateStoredProcedure()!;
                    Assert.Equal("Derived_Update", updateSproc.Name);
                    Assert.Equal("Derived", updateSproc.Schema);
                    Assert.Equal(
                        new[] { "PrincipalBaseId", "PrincipalDerivedId", "Enum1", "Enum2", "FlagsEnum1", "FlagsEnum2", "ValueTypeList", "ValueTypeIList", "ValueTypeArray", "ValueTypeEnumerable", "RefTypeList", "RefTypeIList", "RefTypeArray", "RefTypeEnumerable", "Id" },
                        updateSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(updateSproc.ResultColumns);
                    Assert.Empty(updateSproc.GetAnnotations());
                    Assert.Same(principalDerived, updateSproc.EntityType);
                    Assert.Equal("Id_Original", updateSproc.Parameters.Last().Name);
                    Assert.Null(
                        id.FindOverrides(StoreObjectIdentifier.Create(principalDerived, StoreObjectType.UpdateStoredProcedure).Value));

                    deleteSproc = principalDerived.GetDeleteStoredProcedure()!;
                    Assert.Equal("Derived_Delete", deleteSproc.Name);
                    Assert.Equal("TPC", deleteSproc.Schema);
                    Assert.Equal(new[] { "Id" }, deleteSproc.Parameters.Select(p => p.PropertyName));
                    Assert.Empty(deleteSproc.ResultColumns);
                    Assert.Same(principalDerived, deleteSproc.EntityType);
                    Assert.Equal("Id_Original", deleteSproc.Parameters.Last().Name);
                    Assert.Null(
                        id.FindOverrides(StoreObjectIdentifier.Create(principalDerived, StoreObjectType.DeleteStoredProcedure).Value));

                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());
                    Assert.Null(principalDerived.FindDiscriminatorProperty());
                    Assert.Equal("TPC", principalDerived.GetMappingStrategy());

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var derivedNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("Principals", derivedNavigation.Name);
                    Assert.True(derivedNavigation.IsCollection);
                    Assert.False(derivedNavigation.IsOnDependent);
                    Assert.Equal(principalBase, derivedNavigation.TargetEntityType);
                    Assert.Null(derivedNavigation.Inverse);

                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.False(dependentNavigation.IsEagerLoaded);
                    Assert.True(dependentNavigation.LazyLoadingEnabled);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.False(dependentForeignKey.IsRequired);
                    Assert.True(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(principalDerived, dependentForeignKey.PrincipalEntityType);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientCascade, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId" }, dependentForeignKey.Properties.Select(p => p.Name));

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.True(dependentBase.GetIsDiscriminatorMappingComplete());
                    Assert.Null(dependentBase.FindDiscriminatorProperty());

                    Assert.Same(dependentForeignKey, dependentBase.GetForeignKeys().Single());

                    Assert.Equal(
                        new[] { dependentBase, principalBase, principalDerived },
                        model.GetEntityTypes());

                    var principalBaseSequence = model.FindSequence("PrincipalBaseSequence");
                    Assert.Equal("TPC", principalBaseSequence.Schema);
                },
                typeof(SqlServerNetTopologySuiteDesignTimeServices));

        public class TpcContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDefaultSchema("TPC")
                    .HasDatabaseMaxSize("20TB")
                    .HasPerformanceLevel("High")
                    .HasServiceTier("AB");

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        eb.Ignore(e => e.Owned);

                        eb.UseTpcMappingStrategy();

                        eb.ToTable("PrincipalBase");
                        eb.ToView("PrincipalBaseView", tb => tb.Property(e => e.Id).HasAnnotation("foo", "bar2"));

                        eb.InsertUsingStoredProcedure(
                            s => s
                                .HasParameter("PrincipalBaseId")
                                .HasParameter("PrincipalDerivedId")
                                .HasParameter("Enum1")
                                .HasParameter("Enum2")
                                .HasParameter("FlagsEnum1")
                                .HasParameter("FlagsEnum2")
                                .HasParameter("ValueTypeList")
                                .HasParameter("ValueTypeIList")
                                .HasParameter("ValueTypeArray")
                                .HasParameter("ValueTypeEnumerable")
                                .HasParameter("RefTypeList")
                                .HasParameter("RefTypeIList")
                                .HasParameter("RefTypeArray")
                                .HasParameter("RefTypeEnumerable")
                                .HasParameter(p => p.Id, pb => pb.HasName("BaseId").IsOutput().HasAnnotation("foo", "bar"))
                                .HasAnnotation("foo", "bar1"));
                        eb.UpdateUsingStoredProcedure(
                            s => s
                                .HasParameter("PrincipalBaseId")
                                .HasParameter("PrincipalDerivedId")
                                .HasParameter("Enum1")
                                .HasParameter("Enum2")
                                .HasParameter("FlagsEnum1")
                                .HasParameter("FlagsEnum2")
                                .HasParameter("ValueTypeList")
                                .HasParameter("ValueTypeIList")
                                .HasParameter("ValueTypeArray")
                                .HasParameter("ValueTypeEnumerable")
                                .HasParameter("RefTypeList")
                                .HasParameter("RefTypeIList")
                                .HasParameter("RefTypeArray")
                                .HasParameter("RefTypeEnumerable")
                                .HasOriginalValueParameter(p => p.Id));
                        eb.DeleteUsingStoredProcedure(
                            s => s
                                .HasRowsAffectedReturnValue()
                                .HasOriginalValueParameter(p => p.Id));

                        eb.HasIndex(new[] { "PrincipalBaseId" }, "PrincipalIndex")
                            .IsUnique()
                            .HasDatabaseName("PIX")
                            .IsClustered()
                            .HasFilter("AlternateId <> NULL")
                            .IsCreatedOnline()
                            .HasFillFactor(40)
                            .IncludeProperties(e => e.Id)
                            .SortInTempDb()
                            .UseDataCompression(DataCompressionType.Page);
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        eb.HasOne(e => e.Dependent).WithOne(e => e.Principal)
                            .HasForeignKey<DependentBase<byte?>>()
                            .OnDelete(DeleteBehavior.ClientCascade);

                        eb.Navigation(e => e.Dependent).IsRequired();

                        eb.ToTable("PrincipalDerived");
                        eb.ToView("PrincipalDerivedView");

                        eb.InsertUsingStoredProcedure(
                            "Derived_Insert", s => s
                                .HasParameter("PrincipalBaseId")
                                .HasParameter("PrincipalDerivedId")
                                .HasParameter("Enum1")
                                .HasParameter("Enum2")
                                .HasParameter("FlagsEnum1")
                                .HasParameter("FlagsEnum2")
                                .HasParameter("ValueTypeList")
                                .HasParameter("ValueTypeIList")
                                .HasParameter("ValueTypeArray")
                                .HasParameter("ValueTypeEnumerable")
                                .HasParameter("RefTypeList")
                                .HasParameter("RefTypeIList")
                                .HasParameter("RefTypeArray")
                                .HasParameter("RefTypeEnumerable")
                                .HasResultColumn(p => p.Id, pb => pb.HasName("DerivedId").HasAnnotation("foo", "bar3")));
                        eb.UpdateUsingStoredProcedure(
                            "Derived_Update", "Derived", s => s
                                .HasParameter("PrincipalBaseId")
                                .HasParameter("PrincipalDerivedId")
                                .HasParameter("Enum1")
                                .HasParameter("Enum2")
                                .HasParameter("FlagsEnum1")
                                .HasParameter("FlagsEnum2")
                                .HasParameter("ValueTypeList")
                                .HasParameter("ValueTypeIList")
                                .HasParameter("ValueTypeArray")
                                .HasParameter("ValueTypeEnumerable")
                                .HasParameter("RefTypeList")
                                .HasParameter("RefTypeIList")
                                .HasParameter("RefTypeArray")
                                .HasParameter("RefTypeEnumerable")
                                .HasOriginalValueParameter(p => p.Id));
                        eb.DeleteUsingStoredProcedure(
                            "Derived_Delete", s => s
                                .HasOriginalValueParameter(p => p.Id));
                    });

                modelBuilder.Entity<DependentBase<byte?>>(
                    eb =>
                    {
                        eb.Property<byte?>("Id");
                    });
            }
        }

        public class CustomValueComparer<T> : ValueComparer<T>
        {
            public CustomValueComparer()
                : base(false)
            {
            }
        }

        public abstract class AbstractBase
        {
            public int Id { get; set; }
        }

        public enum AnEnum
        {
            A = 1,
            B,
        }

        public enum AFlagsEnum
        {
            A = 1,
            B = 2,
            C = 4,
        }

        public sealed class MyJsonGuidReaderWriter : JsonValueReaderWriter<Guid>
        {
            public override Guid FromJsonTyped(ref Utf8JsonReaderManager manager, object existingObject = null)
                => manager.CurrentReader.GetGuid();

            public override void ToJsonTyped(Utf8JsonWriter writer, Guid value)
                => writer.WriteStringValue(value);
        }

        public class ManyTypes
        {
            // Issue ##31770
            // public ManyTypesId Id { get; set; }
            public int Id { get; set; }

            public bool Bool { get; set; }
            public byte UInt8 { get; set; }
            public ushort UInt16 { get; set; }
            public uint UInt32 { get; set; }
            public ulong UInt64 { get; set; }
            public sbyte Int8 { get; set; }
            public short Int16 { get; set; }
            public int Int32 { get; set; }
            public long Int64 { get; set; }
            public char Char { get; set; }
            public decimal Decimal { get; set; }
            public double Double { get; set; }
            public float Float { get; set; }
            public Guid Guid { get; set; }
            public DateTime DateTime { get; set; }
            public DateOnly DateOnly { get; set; }
            public TimeOnly TimeOnly { get; set; }
            public TimeSpan TimeSpan { get; set; }
            public string String { get; set; }
            public byte[] Bytes { get; set; }
            public Uri Uri { get; set; }
            public IPAddress IPAddress { get; set; }
            public PhysicalAddress PhysicalAddress { get; set; }

            public bool? NullableBool { get; set; }
            public byte? NullableUInt8 { get; set; }
            public ushort? NullableUInt16 { get; set; }
            public uint? NullableUInt32 { get; set; }
            public ulong? NullableUInt64 { get; set; }
            public sbyte? NullableInt8 { get; set; }
            public short? NullableInt16 { get; set; }
            public int? NullableInt32 { get; set; }
            public long? NullableInt64 { get; set; }
            public char? NullableChar { get; set; }
            public decimal? NullableDecimal { get; set; }
            public double? NullableDouble { get; set; }
            public float? NullableFloat { get; set; }
            public Guid? NullableGuid { get; set; }
            public DateTime? NullableDateTime { get; set; }
            public DateOnly? NullableDateOnly { get; set; }
            public TimeOnly? NullableTimeOnly { get; set; }
            public TimeSpan? NullableTimeSpan { get; set; }
            public string NullableString { get; set; }
            public byte[] NullableBytes { get; set; }
            public Uri NullableUri { get; set; }
            public IPAddress NullableIPAddress { get; set; }
            public PhysicalAddress NullablePhysicalAddress { get; set; }

            public bool[] BoolArray { get; set; }
            public byte[] UInt8Array { get; set; }
            public ushort[] UInt16Array { get; set; }
            public uint[] UInt32Array { get; set; }
            public ulong[] UInt64Array { get; set; }
            public sbyte[] Int8Array { get; set; }
            public short[] Int16Array { get; set; }
            public int[] Int32Array { get; set; }
            public long[] Int64Array { get; set; }
            public char[] CharArray { get; set; }
            public decimal[] DecimalArray { get; set; }
            public double[] DoubleArray { get; set; }
            public float[] FloatArray { get; set; }
            public Guid[] GuidArray { get; set; }
            public DateTime[] DateTimeArray { get; set; }
            public DateOnly[] DateOnlyArray { get; set; }
            public TimeOnly[] TimeOnlyArray { get; set; }
            public TimeSpan[] TimeSpanArray { get; set; }
            public string[] StringArray { get; set; }
            public byte[][] BytesArray { get; set; }
            public Uri[] UriArray { get; set; }
            public IPAddress[] IPAddressArray { get; set; }
            public PhysicalAddress[] PhysicalAddressArray { get; set; }

            public bool?[] NullableBoolArray { get; set; }
            public byte?[] NullableUInt8Array { get; set; }
            public ushort?[] NullableUInt16Array { get; set; }
            public uint?[] NullableUInt32Array { get; set; }
            public ulong?[] NullableUInt64Array { get; set; }
            public sbyte?[] NullableInt8Array { get; set; }
            public short?[] NullableInt16Array { get; set; }
            public int?[] NullableInt32Array { get; set; }
            public long?[] NullableInt64Array { get; set; }
            public char?[] NullableCharArray { get; set; }
            public decimal?[] NullableDecimalArray { get; set; }
            public double?[] NullableDoubleArray { get; set; }
            public float?[] NullableFloatArray { get; set; }
            public Guid?[] NullableGuidArray { get; set; }
            public DateTime?[] NullableDateTimeArray { get; set; }
            public DateOnly?[] NullableDateOnlyArray { get; set; }
            public TimeOnly?[] NullableTimeOnlyArray { get; set; }
            public TimeSpan?[] NullableTimeSpanArray { get; set; }
            public string[] NullableStringArray { get; set; }
            public byte[][] NullableBytesArray { get; set; }
            public Uri[] NullableUriArray { get; set; }
            public IPAddress[] NullableIPAddressArray { get; set; }
            public PhysicalAddress[] NullablePhysicalAddressArray { get; set; }
        }

        public readonly record struct ManyTypesId(int Id);

        public class ManyTypesIdConverter : ValueConverter<ManyTypesId, int>
        {
            public ManyTypesIdConverter()
                : base(v => v.Id, v => new ManyTypesId(v))
            {
            }
        }

        public class PrincipalBase : AbstractBase
        {
            public new long? Id { get; set; }
            public Guid AlternateId;

            public AnEnum Enum1 { get; set; }
            public AnEnum? Enum2 { get; set; }
            public AFlagsEnum FlagsEnum1 { get; set; }
            public AFlagsEnum FlagsEnum2 { get; set; }

            public List<short> ValueTypeList { get; set; }
            public IList<byte> ValueTypeIList { get; set; }
            public DateTime[] ValueTypeArray { get; set; }
            public IEnumerable<byte> ValueTypeEnumerable { get; set; }

            public List<IPAddress> RefTypeList { get; set; }
            public IList<string> RefTypeIList { get; set; }
            public IPAddress[] RefTypeArray { get; set; }
            public IEnumerable<string> RefTypeEnumerable { get; set; }

            private OwnedType _ownedField;
            public OwnedType Owned { get => _ownedField; set => _ownedField = value; }
            public ICollection<PrincipalBase> Deriveds { get; set; }
        }

        public class PrincipalDerived<TDependent> : PrincipalBase
        {
            public TDependent Dependent { get; set; }
            protected ICollection<OwnedType> ManyOwned;
            public ICollection<PrincipalBase> Principals { get; set; }
        }

        public class DependentBase<TKey> : AbstractBase
        {
            public DependentBase(TKey id)
            {
                Id = id;
            }

            private new TKey Id { get; }

            public PrincipalDerived<DependentBase<TKey>> Principal { get; set; }
        }

        public class DependentDerived<TKey> : DependentBase<TKey>
        {
            public DependentDerived(TKey id)
                : base(id)
            {
            }

            private string Data { get; set; }
        }

        public class OwnedType : INotifyPropertyChanged, INotifyPropertyChanging
        {
            private DbContext _context;

            public OwnedType()
            {
            }

            public OwnedType(DbContext context)
            {
                Context = context;
            }

            public DbContext Context
            {
                get => _context;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Context"));
                    _context = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs("Context"));
                }
            }

            public int Number { get; set; }

            [NotMapped]
            public PrincipalBase Principal { get; set; }

            private string _details;
            private List<short> _valueTypeList;
            private DateTime[] _valueTypeArray;
            private IEnumerable<byte> _valueTypeEnumerable;
            private List<IPAddress> _refTypeList;
            private IList<string> _refTypeIList;
            private IPAddress[] _refTypeArray;
            private IEnumerable<string> _refTypeEnumerable;

            public string Details
            {
                get => _details;
                set => _details = value;
            }

            public event PropertyChangedEventHandler PropertyChanged;
            public event PropertyChangingEventHandler PropertyChanging;

            public List<short> ValueTypeList
            {
                get => _valueTypeList;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueTypeList)));
                    _valueTypeList = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(ValueTypeList)));
                }
            }

            public IList<byte> ValueTypeIList { get; set; }

            public DateTime[] ValueTypeArray
            {
                get => _valueTypeArray;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueTypeArray)));
                    _valueTypeArray = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(ValueTypeArray)));
                }
            }

            public IEnumerable<byte> ValueTypeEnumerable
            {
                get => _valueTypeEnumerable;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueTypeEnumerable)));
                    _valueTypeEnumerable = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(ValueTypeEnumerable)));
                }
            }

            public List<IPAddress> RefTypeList
            {
                get => _refTypeList;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeList)));
                    _refTypeList = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeList)));
                }
            }

            public IList<string> RefTypeIList
            {
                get => _refTypeIList;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeIList)));
                    _refTypeIList = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeIList)));
                }
            }

            public IPAddress[] RefTypeArray
            {
                get => _refTypeArray;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeArray)));
                    _refTypeArray = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeArray)));
                }
            }

            public IEnumerable<string> RefTypeEnumerable
            {
                get => _refTypeEnumerable;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeEnumerable)));
                    _refTypeEnumerable = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeEnumerable)));
                }
            }
        }

        [ConditionalFact]
        public void DbFunctions()
            => Test(
                new DbFunctionContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "DbFunctionContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext))]
    public partial class DbFunctionContextModel : RuntimeModel
    {
        static DbFunctionContextModel()
        {
            var model = new DbFunctionContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static DbFunctionContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "DbFunctionContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class DbFunctionContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);
            var @object = ObjectEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);
            ObjectEntityType.CreateAnnotations(@object);

            var type = this.AddTypeMappingConfiguration(
                typeof(string),
                maxLength: 256);
            type.AddAnnotation("Relational:IsFixedLength", true);

            var functions = new SortedDictionary<string, IDbFunction>();
            var getBlobs = new RuntimeDbFunction(
                "GetBlobs()",
                this,
                typeof(IQueryable<object>),
                "GetBlobs",
                schema: "dbo");

            functions["GetBlobs()"] = getBlobs;

            var getCount = new RuntimeDbFunction(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetCount(System.Guid?,string)",
                this,
                typeof(int),
                "CustomerOrderCount",
                schema: "dbf",
                storeType: "int",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    "GetCount",
                    BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(Guid?), typeof(string) },
                    null),
                scalar: true);

            var id = getCount.AddParameter(
                "id",
                typeof(Guid?),
                true,
                "uniqueidentifier");
            id.TypeMapping = GuidTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "uniqueidentifier"));
            id.AddAnnotation("MyAnnotation", new[] { 1L });

            var condition = getCount.AddParameter(
                "condition",
                typeof(string),
                false,
                "nchar(256)");
            condition.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nchar(256)",
                    size: 256,
                    dbType: System.Data.DbType.StringFixedLength));

            getCount.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            functions["Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetCount(System.Guid?,string)"] = getCount;

            var getData = new RuntimeDbFunction(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()",
                this,
                typeof(IQueryable<CSharpRuntimeModelCodeGeneratorTest.Data>),
                "GetAllData",
                schema: "dbo",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    "GetData",
                    BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] {  },
                    null));

            functions["Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()"] = getData;

            var getData0 = new RuntimeDbFunction(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData(int)",
                this,
                typeof(IQueryable<CSharpRuntimeModelCodeGeneratorTest.Data>),
                "GetData",
                schema: "dbo",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    "GetData",
                    BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(int) },
                    null));

            var id0 = getData0.AddParameter(
                "id",
                typeof(int),
                false,
                "int");
            id0.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));

            functions["Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData(int)"] = getData0;

            var isDateStatic = new RuntimeDbFunction(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.IsDateStatic(string)",
                this,
                typeof(bool),
                "IsDate",
                storeType: "bit",
                methodInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DbFunctionContext).GetMethod(
                    "IsDateStatic",
                    BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly,
                    null,
                    new Type[] { typeof(string) },
                    null),
                scalar: true,
                nullable: true,
                builtIn: true);

            var date = isDateStatic.AddParameter(
                "date",
                typeof(string),
                false,
                "nchar(256)");
            date.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nchar(256)",
                    size: 256,
                    dbType: System.Data.DbType.StringFixedLength));

            isDateStatic.TypeMapping = SqlServerBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v));
            isDateStatic.AddAnnotation("MyGuid", new Guid("00000000-0000-0000-0000-000000000000"));
            functions["Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.IsDateStatic(string)"] = isDateStatic;

            AddAnnotation("Relational:DbFunctions", functions);
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var functionMappings = new List<FunctionMapping>();
            data.SetRuntimeAnnotation("Relational:FunctionMappings", functionMappings);
            var getAllData = (IRuntimeDbFunction)this.FindDbFunction("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()")!;
            var getAllDataFunction = new StoreFunction(getAllData, relationalModel);
            var blobFunctionColumn = new FunctionColumn("Blob", "varbinary(max)", getAllDataFunction)
            {
                IsNullable = true
            };
            getAllDataFunction.Columns.Add("Blob", blobFunctionColumn);
            relationalModel.Functions.Add(
                ("GetAllData", "dbo", new string[0]),
                getAllDataFunction);
            var getAllDataFunctionMapping = new FunctionMapping(data, getAllDataFunction, getAllData, true);
            getAllDataFunction.AddTypeMapping(getAllDataFunctionMapping, false);
            functionMappings.Add(getAllDataFunctionMapping);
            getAllDataFunctionMapping.IsDefaultFunctionMapping = true;
            RelationalModel.CreateFunctionColumnMapping(blobFunctionColumn, data.FindProperty("Blob")!, getAllDataFunctionMapping);
            var getData = (IRuntimeDbFunction)this.FindDbFunction("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData(int)")!;
            var getDataFunction = new StoreFunction(getData, relationalModel);
            var idFunctionParameter = getDataFunction.FindParameter("id")!;
            var blobFunctionColumn0 = new FunctionColumn("Blob", "varbinary(max)", getDataFunction)
            {
                IsNullable = true
            };
            getDataFunction.Columns.Add("Blob", blobFunctionColumn0);
            relationalModel.Functions.Add(
                ("GetData", "dbo", new[] { "int" }),
                getDataFunction);
            var getDataFunctionMapping = new FunctionMapping(data, getDataFunction, getData, true);
            getDataFunction.AddTypeMapping(getDataFunctionMapping, false);
            functionMappings.Add(getDataFunctionMapping);
            RelationalModel.CreateFunctionColumnMapping(blobFunctionColumn0, data.FindProperty("Blob")!, getDataFunctionMapping);

            var @object = FindEntityType("object")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            @object.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var objectTableBase = new TableBase("object", null, relationalModel);
            relationalModel.DefaultTables.Add("object", objectTableBase);
            var objectMappingBase = new TableMappingBase<ColumnMappingBase>(@object, objectTableBase, true);
            objectTableBase.AddTypeMapping(objectMappingBase, false);
            defaultTableMappings0.Add(objectMappingBase);

            var functionMappings0 = new List<FunctionMapping>();
            @object.SetRuntimeAnnotation("Relational:FunctionMappings", functionMappings0);
            var getBlobs = (IRuntimeDbFunction)this.FindDbFunction("GetBlobs()")!;
            var getBlobsFunction = new StoreFunction(getBlobs, relationalModel);
            relationalModel.Functions.Add(
                ("GetBlobs", "dbo", new string[0]),
                getBlobsFunction);
            var getBlobsFunctionMapping = new FunctionMapping(@object, getBlobsFunction, getBlobs, true);
            getBlobsFunction.AddTypeMapping(getBlobsFunctionMapping, false);
            functionMappings0.Add(getBlobsFunctionMapping);
            getBlobsFunctionMapping.IsDefaultFunctionMapping = true;
            var customerOrderCount = (IRuntimeDbFunction)this.FindDbFunction("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetCount(System.Guid?,string)")!;
            var customerOrderCountFunction = new StoreFunction(customerOrderCount, relationalModel);
            var idFunctionParameter0 = customerOrderCountFunction.FindParameter("id")!;
            var conditionFunctionParameter = customerOrderCountFunction.FindParameter("condition")!;
            relationalModel.Functions.Add(
                ("CustomerOrderCount", "dbf", new[] { "uniqueidentifier", "nchar(256)" }),
                customerOrderCountFunction);
            var isDate = (IRuntimeDbFunction)this.FindDbFunction("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.IsDateStatic(string)")!;
            var isDateFunction = new StoreFunction(isDate, relationalModel);
            var dateFunctionParameter = isDateFunction.FindParameter("date")!;
            relationalModel.Functions.Add(
                ("IsDate", null, new[] { "nchar(256)" }),
                isDateFunction);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            blob.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DbFunctionContext.GetData()");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "ObjectEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class ObjectEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "object",
                typeof(object),
                baseEntityType);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", "GetBlobs()");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Equal(5, model.GetDbFunctions().Count());

                    var getCount = model.FindDbFunction(
                        typeof(DbFunctionContext)
                            .GetMethod("GetCount", BindingFlags.NonPublic | BindingFlags.Instance));
                    Assert.Equal("CustomerOrderCount", getCount.Name);
                    Assert.Same(model, getCount.Model);
                    Assert.Same(model, ((IReadOnlyDbFunction)getCount).Model);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".GetCount(System.Guid?,string)", getCount.ModelName);
                    Assert.Equal("dbf", getCount.Schema);
                    Assert.False(getCount.IsNullable);
                    Assert.True(getCount.IsScalar);
                    Assert.False(getCount.IsBuiltIn);
                    Assert.False(getCount.IsAggregate);
                    Assert.Null(getCount.Translation);
                    Assert.Equal("int", getCount.TypeMapping?.StoreType);
                    Assert.Equal(typeof(int), getCount.ReturnType);
                    Assert.Equal("GetCount", getCount.MethodInfo.Name);
                    Assert.Empty(getCount.GetAnnotations());
                    Assert.Empty(getCount.GetRuntimeAnnotations());
                    Assert.Equal("CustomerOrderCount", getCount.StoreFunction.Name);
                    Assert.False(getCount.StoreFunction.IsShared);
                    Assert.NotNull(getCount.ToString());
                    Assert.Equal(getCount.Parameters, ((IReadOnlyDbFunction)getCount).Parameters);
                    Assert.Equal(2, getCount.Parameters.Count);

                    var getCountParameter1 = getCount.Parameters[0];
                    Assert.Same(getCount, getCountParameter1.Function);
                    Assert.Same(getCount, ((IReadOnlyDbFunctionParameter)getCountParameter1).Function);
                    Assert.Equal("id", getCountParameter1.Name);
                    Assert.Equal("uniqueidentifier", getCountParameter1.StoreType);
                    Assert.Equal("uniqueidentifier", ((IReadOnlyDbFunctionParameter)getCountParameter1).StoreType);
                    Assert.True(getCountParameter1.PropagatesNullability);
                    Assert.Equal(typeof(Guid?), getCountParameter1.ClrType);
                    Assert.Equal("uniqueidentifier", getCountParameter1.TypeMapping.StoreType);
                    Assert.Single((IEnumerable)getCountParameter1.GetAnnotations());
                    Assert.Equal(new[] { 1L }, getCountParameter1["MyAnnotation"]);
                    Assert.Equal("id", getCountParameter1.StoreFunctionParameter.Name);
                    Assert.Equal("uniqueidentifier", getCountParameter1.StoreFunctionParameter.StoreType);
                    Assert.NotNull(getCountParameter1.ToString());

                    var getCountParameter2 = getCount.Parameters[1];
                    Assert.Same(getCount, getCountParameter2.Function);
                    Assert.Equal("condition", getCountParameter2.Name);
                    Assert.Equal("nchar(256)", getCountParameter2.StoreType);
                    Assert.False(getCountParameter2.PropagatesNullability);
                    Assert.Equal(typeof(string), getCountParameter2.ClrType);
                    Assert.Equal("nchar(256)", getCountParameter2.TypeMapping.StoreType);
                    Assert.Equal("condition", getCountParameter2.StoreFunctionParameter.Name);
                    Assert.Equal("nchar(256)", getCountParameter2.StoreFunctionParameter.StoreType);
                    Assert.NotNull(getCountParameter2.ToString());

                    var isDate = model.FindDbFunction(typeof(DbFunctionContext).GetMethod("IsDateStatic"));
                    Assert.Equal("IsDate", isDate.Name);
                    Assert.Null(isDate.Schema);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".IsDateStatic(string)", isDate.ModelName);
                    Assert.True(isDate.IsNullable);
                    Assert.True(isDate.IsScalar);
                    Assert.True(isDate.IsBuiltIn);
                    Assert.False(isDate.IsAggregate);
                    Assert.Null(isDate.Translation);
                    Assert.Equal(typeof(bool), isDate.ReturnType);
                    Assert.Equal("IsDateStatic", isDate.MethodInfo.Name);
                    Assert.Single((IEnumerable)isDate.GetAnnotations());
                    Assert.Equal(new Guid(), isDate["MyGuid"]);
                    Assert.Empty(isDate.GetRuntimeAnnotations());
                    Assert.Equal("bit", isDate.StoreFunction.ReturnType);
                    Assert.Empty(isDate.StoreFunction.EntityTypeMappings);
                    Assert.Single((IEnumerable)isDate.Parameters);

                    var isDateParameter = isDate.Parameters[0];
                    Assert.Same(isDate, isDateParameter.Function);
                    Assert.Equal("date", isDateParameter.Name);
                    Assert.Equal("nchar(256)", isDateParameter.StoreType);
                    Assert.False(isDateParameter.PropagatesNullability);
                    Assert.Equal(typeof(string), isDateParameter.ClrType);
                    Assert.Equal("nchar(256)", isDateParameter.TypeMapping.StoreType);
                    Assert.Equal("date", isDateParameter.StoreFunctionParameter.Name);
                    Assert.Equal("nchar(256)", isDateParameter.StoreFunctionParameter.StoreType);

                    var getData = model.FindDbFunction(
                        typeof(DbFunctionContext)
                            .GetMethod("GetData", new[] { typeof(int) }));
                    Assert.Equal("GetData", getData.Name);
                    Assert.Equal("dbo", getData.Schema);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".GetData(int)", getData.ModelName);
                    Assert.False(getData.IsNullable);
                    Assert.False(getData.IsScalar);
                    Assert.False(getData.IsBuiltIn);
                    Assert.False(getData.IsAggregate);
                    Assert.Null(getData.Translation);
                    Assert.Equal(typeof(IQueryable<Data>), getData.ReturnType);
                    Assert.Equal("GetData", getData.MethodInfo.Name);
                    Assert.Empty(getData.GetAnnotations());
                    Assert.Empty(getData.GetRuntimeAnnotations());
                    Assert.Null(getData.TypeMapping?.StoreType);
                    Assert.Null(getData.StoreFunction.ReturnType);
                    Assert.Equal(typeof(Data), getData.StoreFunction.EntityTypeMappings.Single().TypeBase.ClrType);
                    Assert.Single((IEnumerable)getData.Parameters);

                    var getDataParameter = getData.Parameters[0];
                    Assert.Same(getData, getDataParameter.Function);
                    Assert.Equal("id", getDataParameter.Name);
                    Assert.Equal("int", getDataParameter.StoreType);
                    Assert.False(getDataParameter.PropagatesNullability);
                    Assert.Equal(typeof(int), getDataParameter.ClrType);
                    Assert.Equal("int", getDataParameter.TypeMapping.StoreType);
                    Assert.Equal("id", getDataParameter.StoreFunctionParameter.Name);
                    Assert.Equal("int", getDataParameter.StoreFunctionParameter.StoreType);

                    var getDataParameterless = model.FindDbFunction(
                        typeof(DbFunctionContext)
                            .GetMethod("GetData", new Type[0]));
                    Assert.Equal("GetAllData", getDataParameterless.Name);
                    Assert.Equal("dbo", getDataParameterless.Schema);
                    Assert.Equal(typeof(DbFunctionContext).FullName + ".GetData()", getDataParameterless.ModelName);
                    Assert.False(getDataParameterless.IsNullable);
                    Assert.False(getDataParameterless.IsScalar);
                    Assert.False(getDataParameterless.IsBuiltIn);
                    Assert.False(getDataParameterless.IsAggregate);
                    Assert.Null(getDataParameterless.Translation);
                    Assert.Equal(typeof(IQueryable<Data>), getDataParameterless.ReturnType);
                    Assert.Equal("GetData", getDataParameterless.MethodInfo.Name);
                    Assert.Empty(getDataParameterless.GetAnnotations());
                    Assert.Empty(getDataParameterless.GetRuntimeAnnotations());
                    Assert.False(getDataParameterless.StoreFunction.IsBuiltIn);
                    Assert.Equal(typeof(Data), getDataParameterless.StoreFunction.EntityTypeMappings.Single().TypeBase.ClrType);
                    Assert.Equal(0, getDataParameterless.Parameters.Count);

                    Assert.Equal(2, model.GetEntityTypes().Count());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Null(dataEntity.FindPrimaryKey());
                    var dataEntityFunctionMapping = dataEntity.GetFunctionMappings().Single(m => m.IsDefaultFunctionMapping);
                    Assert.True(dataEntityFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(dataEntityFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(dataEntityFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(getDataParameterless, dataEntityFunctionMapping.DbFunction);

                    var getDataStoreFunction = dataEntityFunctionMapping.StoreFunction;
                    Assert.Same(getDataParameterless, getDataStoreFunction.DbFunctions.Single());
                    Assert.False(getDataStoreFunction.IsOptional(dataEntity));

                    var dataEntityOtherFunctionMapping = dataEntity.GetFunctionMappings().Single(m => !m.IsDefaultFunctionMapping);
                    Assert.True(dataEntityOtherFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(dataEntityOtherFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(dataEntityOtherFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(getData, dataEntityOtherFunctionMapping.DbFunction);

                    var getDataOtherStoreFunction = dataEntityOtherFunctionMapping.StoreFunction;
                    Assert.Same(getData, getDataOtherStoreFunction.DbFunctions.Single());
                    Assert.False(getDataOtherStoreFunction.IsOptional(dataEntity));

                    var getBlobs = model.FindDbFunction("GetBlobs()");
                    Assert.Equal("dbo", getBlobs.Schema);
                    Assert.False(getBlobs.IsNullable);
                    Assert.False(getBlobs.IsScalar);
                    Assert.False(getBlobs.IsBuiltIn);
                    Assert.False(getBlobs.IsAggregate);
                    Assert.Null(getBlobs.Translation);
                    Assert.Null(getBlobs.TypeMapping);
                    Assert.Equal(typeof(IQueryable<object>), getBlobs.ReturnType);
                    Assert.Null(getBlobs.MethodInfo);
                    Assert.Empty(getBlobs.GetAnnotations());
                    Assert.Empty(getBlobs.GetRuntimeAnnotations());
                    Assert.Equal("GetBlobs", getBlobs.StoreFunction.Name);
                    Assert.False(getBlobs.StoreFunction.IsShared);
                    Assert.NotNull(getBlobs.ToString());
                    Assert.Empty(getBlobs.Parameters);

                    var objectEntity = model.FindEntityType(typeof(object));
                    Assert.Null(objectEntity.FindPrimaryKey());
                    var objectEntityFunctionMapping = objectEntity.GetFunctionMappings().Single(m => m.IsDefaultFunctionMapping);
                    Assert.True(objectEntityFunctionMapping.IncludesDerivedTypes);
                    Assert.Null(objectEntityFunctionMapping.IsSharedTablePrincipal);
                    Assert.Null(objectEntityFunctionMapping.IsSplitEntityTypePrincipal);
                    Assert.Same(getBlobs, objectEntityFunctionMapping.DbFunction);
                });

        public class DbFunctionContext : SqlServerContextBase
        {
            public static bool IsDateStatic(string date)
                => throw new NotImplementedException();

            private int GetCount(Guid? id, string condition)
                => throw new NotImplementedException();

            public IQueryable<Data> GetData(int id)
                => FromExpression(() => GetData(id));

            public IQueryable<Data> GetData()
                => FromExpression(() => GetData());

            protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
                => configurationBuilder.DefaultTypeMapping<string>().HasMaxLength(256).IsFixedLength();

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasDbFunction(
                        typeof(DbFunctionContext).GetMethod(nameof(GetCount), BindingFlags.NonPublic | BindingFlags.Instance))
                    .HasName("CustomerOrderCount").HasSchema("dbf").IsNullable(false)
                    .HasParameter("id").PropagatesNullability().Metadata.SetAnnotation("MyAnnotation", new[] { 1L });

                modelBuilder.HasDbFunction(typeof(DbFunctionContext).GetMethod(nameof(IsDateStatic))).HasName("IsDate").IsBuiltIn()
                    .Metadata.SetAnnotation("MyGuid", new Guid());

                modelBuilder.HasDbFunction(typeof(DbFunctionContext).GetMethod(nameof(GetData), new[] { typeof(int) }));
                modelBuilder.HasDbFunction(typeof(DbFunctionContext).GetMethod(nameof(GetData), new Type[0]));

                modelBuilder.Entity<Data>().ToFunction(typeof(DbFunctionContext).FullName + ".GetData()", f => f.HasName("GetAllData"))
                    .HasNoKey();

                modelBuilder.Entity<object>().ToFunction("GetBlobs()", f => f.HasName("GetBlobs")).HasNoKey();
            }
        }

        [ConditionalFact]
        public void Sequences()
            => Test(
                new SequencesContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "SequencesContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.SequencesContext))]
    public partial class SequencesContextModel : RuntimeModel
    {
        static SequencesContextModel()
        {
            var model = new SequencesContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static SequencesContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "SequencesContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class SequencesContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            var sequences = new SortedDictionary<(string, string), ISequence>();
            var hL = new RuntimeSequence(
                "HL",
                this,
                typeof(long),
                schema: "S",
                incrementBy: 10);

            sequences[("HL", "S")] = hL;

            var @long = new RuntimeSequence(
                "Long",
                this,
                typeof(long),
                startValue: -4L,
                incrementBy: 2,
                cyclic: true,
                minValue: -2L,
                maxValue: 2L);

            sequences[("Long", null)] = @long;

            AddAnnotation("Relational:Sequences", sequences);
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Id", idColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, data.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var tableMappings = new List<TableMapping>();
            data.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dataTable = new Table("Data", null, relationalModel);
            var idColumn = new Column("Id", "int", dataTable);
            dataTable.Columns.Add("Id", idColumn);
            var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Blob", blobColumn);
            var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
            dataTable.PrimaryKey = pK_Data;
            var pK_DataUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                new[] { "Id" });
            pK_Data.MappedKeys.Add(pK_DataUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DataUc).Add(pK_Data);
            dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
            relationalModel.Tables.Add(("Data", null), dataTable);
            var dataTableMapping = new TableMapping(data, dataTable, true);
            dataTable.AddTypeMapping(dataTableMapping, false);
            tableMappings.Add(dataTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:HiLoSequenceName", "HL");
            id.AddAnnotation("SqlServer:HiLoSequenceSchema", "S");
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.SequenceHiLo);

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            blob.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Data");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Equal(2, model.GetSequences().Count());

                    var longSequence = model.FindSequence("Long");
                    Assert.Same(model, longSequence.Model);
                    Assert.Equal(typeof(long), longSequence.Type);
                    Assert.True(longSequence.IsCyclic);
                    Assert.Equal(-4, longSequence.StartValue);
                    Assert.Equal(-2, longSequence.MinValue);
                    Assert.Equal(2, longSequence.MaxValue);
                    Assert.Equal(2, longSequence.IncrementBy);
                    Assert.NotNull(longSequence.ToString());

                    var hiLo = model.FindSequence("HL", "S");
                    Assert.Same(model, ((IReadOnlySequence)hiLo).Model);
                    Assert.Equal("HL", hiLo.Name);
                    Assert.Equal("S", hiLo.Schema);
                    Assert.False(hiLo.IsCyclic);
                    Assert.Equal(1, hiLo.StartValue);
                    Assert.Null(hiLo.MinValue);
                    Assert.Null(hiLo.MaxValue);
                    Assert.Equal(10, hiLo.IncrementBy);
                    Assert.NotNull(hiLo.ToString());

                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Same(hiLo, dataEntity.FindPrimaryKey().Properties.Single().FindHiLoSequence());
                });

        public class SequencesContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.HasSequence<long>("Long")
                    .HasMin(-2)
                    .HasMax(2)
                    .IsCyclic()
                    .IncrementsBy(2)
                    .StartsAt(-4);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id").UseHiLo("HL", "S");
                        eb.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Key_sequences()
            => Test(
                new KeySequencesContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "KeySequencesContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.KeySequencesContext))]
    public partial class KeySequencesContextModel : RuntimeModel
    {
        static KeySequencesContextModel()
        {
            var model = new KeySequencesContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static KeySequencesContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "KeySequencesContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class KeySequencesContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            var sequences = new SortedDictionary<(string, string), ISequence>();
            var keySeq = new RuntimeSequence(
                "KeySeq",
                this,
                typeof(long),
                schema: "KeySeqSchema");

            sequences[("KeySeq", "KeySeqSchema")] = keySeq;

            AddAnnotation("Relational:Sequences", sequences);
            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Id", idColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, data.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var tableMappings = new List<TableMapping>();
            data.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dataTable = new Table("Data", null, relationalModel);
            var idColumn = new Column("Id", "int", dataTable);
            dataTable.Columns.Add("Id", idColumn);
            var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Blob", blobColumn);
            var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
            dataTable.PrimaryKey = pK_Data;
            var pK_DataUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                new[] { "Id" });
            pK_Data.MappedKeys.Add(pK_DataUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DataUc).Add(pK_Data);
            dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
            relationalModel.Tables.Add(("Data", null), dataTable);
            var dataTableMapping = new TableMapping(data, dataTable, true);
            dataTable.AddTypeMapping(dataTableMapping, false);
            tableMappings.Add(dataTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("Relational:DefaultValueSql", "NEXT VALUE FOR [KeySeqSchema].[KeySeq]");
            id.AddAnnotation("SqlServer:SequenceName", "KeySeq");
            id.AddAnnotation("SqlServer:SequenceSchema", "KeySeqSchema");
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.Sequence);

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            blob.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Data");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Single(model.GetSequences());

                    var keySequence = model.FindSequence("KeySeq", "KeySeqSchema")!;
                    Assert.Same(model, ((IReadOnlySequence)keySequence).Model);
                    Assert.Equal("KeySeq", keySequence.Name);
                    Assert.Equal("KeySeqSchema", keySequence.Schema);
                    Assert.False(keySequence.IsCyclic);
                    Assert.Equal(1, keySequence.StartValue);
                    Assert.Null(keySequence.MinValue);
                    Assert.Null(keySequence.MaxValue);
                    Assert.Equal(1, keySequence.IncrementBy);
                    Assert.NotNull(keySequence.ToString());

                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Same(keySequence, dataEntity!.FindPrimaryKey().Properties.Single().FindSequence());
                });

        public class KeySequencesContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id").UseSequence("KeySeq", "KeySeqSchema");
                        eb.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void CheckConstraints()
            => Test(
                new ConstraintsContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ConstraintsContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ConstraintsContext))]
    public partial class ConstraintsContextModel : RuntimeModel
    {
        static ConstraintsContextModel()
        {
            var model = new ConstraintsContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static ConstraintsContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ConstraintsContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ConstraintsContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Id", idColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, data.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var tableMappings = new List<TableMapping>();
            data.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dataTable = new Table("Data", null, relationalModel);
            var idColumn = new Column("Id", "int", dataTable);
            dataTable.Columns.Add("Id", idColumn);
            var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Blob", blobColumn);
            var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
            dataTable.PrimaryKey = pK_Data;
            var pK_DataUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                new[] { "Id" });
            pK_Data.MappedKeys.Add(pK_DataUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DataUc).Add(pK_Data);
            dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
            relationalModel.Tables.Add(("Data", null), dataTable);
            var dataTableMapping = new TableMapping(data, dataTable, true);
            dataTable.AddTypeMapping(dataTableMapping, false);
            tableMappings.Add(dataTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            blob.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Data");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var dataEntity = model.GetEntityTypes().Single();

                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => dataEntity.GetCheckConstraints()).Message);
                });

        public class ConstraintsContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.ToTable(tb => tb.HasCheckConstraint("idConstraint", "Id <> 0"));
                        eb.ToTable(tb => tb.HasCheckConstraint("anotherConstraint", "Id <> -1"));
                    });
            }
        }

        [ConditionalFact]
        public void Triggers()
            => Test(
                new TriggersContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "TriggersContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TriggersContext))]
    public partial class TriggersContextModel : RuntimeModel
    {
        static TriggersContextModel()
        {
            var model = new TriggersContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static TriggersContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "TriggersContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class TriggersContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            AddAnnotation("Relational:MaxIdentifierLength", 128);
            AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "varbinary(max)", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "int", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Id", idColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, data.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var tableMappings = new List<TableMapping>();
            data.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dataTable = new Table("Data", null, relationalModel);
            var idColumn = new Column("Id", "int", dataTable);
            dataTable.Columns.Add("Id", idColumn);
            var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Blob", blobColumn);
            var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
            dataTable.PrimaryKey = pK_Data;
            var pK_DataUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                new[] { "Id" });
            pK_Data.MappedKeys.Add(pK_DataUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DataUc).Add(pK_Data);
            dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
            dataTable.Triggers.Add("Trigger1", data.FindDeclaredTrigger("Trigger1"));
            dataTable.Triggers.Add("Trigger2", data.FindDeclaredTrigger("Trigger2"));
            relationalModel.Tables.Add(("Data", null), dataTable);
            var dataTableMapping = new TableMapping(data, dataTable, true);
            dataTable.AddTypeMapping(dataTableMapping, false);
            tableMappings.Add(dataTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqlServerByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varbinary(max)"),
                storeTypePostfix: StoreTypePostfix.None);
            blob.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var trigger1 = runtimeEntityType.AddTrigger(
                "Trigger1");

            var trigger2 = runtimeEntityType.AddTrigger(
                "Trigger2");

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Data");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);
            runtimeEntityType.AddAnnotation("SqlServer:UseSqlOutputClause", false);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var dataEntity = model.GetEntityTypes().Single();

                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => dataEntity.GetCheckConstraints()).Message);
                });

        public class TriggersContext : SqlServerContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.ToTable(
                            tb =>
                            {
                                tb.HasTrigger("Trigger1");
                                tb.HasTrigger("Trigger2");
                            });
                    });
            }
        }

        [ConditionalFact]
        public void Sqlite()
            => Test(
                new SqliteContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = "Microsoft.EntityFrameworkCore.Metadata" },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "SqliteContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.SqliteContext))]
    public partial class SqliteContextModel : RuntimeModel
    {
        static SqliteContextModel()
        {
            var model = new SqliteContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static SqliteContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "SqliteContextModelBuilder.cs",
                        """
// <auto-generated />
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Migrations;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    public partial class SqliteContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);
            var dependentBase = DependentBaseEntityType.Create(this);
            var manyTypes = ManyTypesEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var ownedType = OwnedTypeEntityType.Create(this);
            var ownedType0 = OwnedType0EntityType.Create(this);
            var principalBasePrincipalDerivedDependentBasebyte = PrincipalBasePrincipalDerivedDependentBasebyteEntityType.Create(this);
            var dependentDerived = DependentDerivedEntityType.Create(this, dependentBase);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalBase);
            DependentBaseEntityType.CreateForeignKey2(dependentBase, principalDerived);
            OwnedTypeEntityType.CreateForeignKey1(ownedType, principalBase);
            OwnedTypeEntityType.CreateForeignKey2(ownedType, ownedType);
            OwnedType0EntityType.CreateForeignKey1(ownedType0, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey1(principalBasePrincipalDerivedDependentBasebyte, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey2(principalBasePrincipalDerivedDependentBasebyte, principalBase);
            PrincipalDerivedEntityType.CreateForeignKey1(principalDerived, principalBase);

            PrincipalBaseEntityType.CreateSkipNavigation1(principalBase, principalDerived, principalBasePrincipalDerivedDependentBasebyte);
            PrincipalDerivedEntityType.CreateSkipNavigation1(principalDerived, principalBase, principalBasePrincipalDerivedDependentBasebyte);

            DataEntityType.CreateAnnotations(data);
            DependentBaseEntityType.CreateAnnotations(dependentBase);
            ManyTypesEntityType.CreateAnnotations(manyTypes);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            OwnedTypeEntityType.CreateAnnotations(ownedType);
            OwnedType0EntityType.CreateAnnotations(ownedType0);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateAnnotations(principalBasePrincipalDerivedDependentBasebyte);
            DependentDerivedEntityType.CreateAnnotations(dependentDerived);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Id", idColumnBase);
            var pointColumnBase = new ColumnBase<ColumnMappingBase>("Point", "POINT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Point", pointColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, data.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase, data.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var tableMappings = new List<TableMapping>();
            data.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dataTable = new Table("Data", null, relationalModel);
            var idColumn = new Column("Id", "INTEGER", dataTable);
            dataTable.Columns.Add("Id", idColumn);
            var blobColumn = new Column("Blob", "BLOB", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Blob", blobColumn);
            var pointColumn = new Column("Point", "POINT", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Point", pointColumn);
            var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
            dataTable.PrimaryKey = pK_Data;
            var pK_DataUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                new[] { "Id" });
            pK_Data.MappedKeys.Add(pK_DataUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DataUc).Add(pK_Data);
            dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
            relationalModel.Tables.Add(("Data", null), dataTable);
            var dataTableMapping = new TableMapping(data, dataTable, true);
            dataTable.AddTypeMapping(dataTableMapping, false);
            tableMappings.Add(dataTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(pointColumn, data.FindProperty("Point")!, dataTableMapping);

            var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            dependentBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", null, relationalModel);
            var dataColumnBase = new ColumnBase<ColumnMappingBase>("Data", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Data", dataColumnBase);
            var enumDiscriminatorColumnBase = new ColumnBase<ColumnMappingBase>("EnumDiscriminator", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("EnumDiscriminator", enumDiscriminatorColumnBase);
            var idColumnBase0 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase0);
            var moneyColumnBase = new ColumnBase<ColumnMappingBase>("Money", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Money", moneyColumnBase);
            var principalAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalAlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalAlternateId", principalAlternateIdColumnBase);
            var principalIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalId", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalId", principalIdColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(dependentBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentBase.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentBase.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentBase.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, dependentBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings0 = new List<TableMapping>();
            dependentBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings0);
            var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
            var principalIdColumn = new Column("PrincipalId", "INTEGER", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
            var principalAlternateIdColumn = new Column("PrincipalAlternateId", "TEXT", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
            var dataColumn = new Column("Data", "TEXT", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Data", dataColumn);
            var enumDiscriminatorColumn = new Column("EnumDiscriminator", "INTEGER", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
            var idColumn0 = new Column("Id", "INTEGER", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Id", idColumn0);
            var moneyColumn = new Column("Money", "TEXT", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Money", moneyColumn);
            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
            var pK_DependentBasebyteUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" });
            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteUc).Add(pK_DependentBasebyte);
            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
            var iX_DependentBasebyte_PrincipalId = new TableIndex(
            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" });
            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
            relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
            tableMappings0.Add(dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentBase.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentBase.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(idColumn0, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);

            var dependentDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>")!;

            var defaultTableMappings1 = new List<TableMappingBase<ColumnMappingBase>>();
            dependentDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings1);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0 = new TableMappingBase<ColumnMappingBase>(dependentDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0, false);
            defaultTableMappings1.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentDerived.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentDerived.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dataColumnBase, dependentDerived.FindProperty("Data")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentDerived.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, dependentDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)moneyColumnBase, dependentDerived.FindProperty("Money")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);

            var tableMappings1 = new List<TableMapping>();
            dependentDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings1);
            var dependentBasebyteTableMapping0 = new TableMapping(dependentDerived, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping0, false);
            tableMappings1.Add(dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentDerived.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentDerived.FindProperty("PrincipalId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn0, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);

            var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes")!;

            var defaultTableMappings2 = new List<TableMappingBase<ColumnMappingBase>>();
            manyTypes.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings2);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", null, relationalModel);
            var boolColumnBase = new ColumnBase<ColumnMappingBase>("Bool", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bool", boolColumnBase);
            var boolArrayColumnBase = new ColumnBase<ColumnMappingBase>("BoolArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolArray", boolArrayColumnBase);
            var bytesColumnBase = new ColumnBase<ColumnMappingBase>("Bytes", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bytes", bytesColumnBase);
            var bytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("BytesArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BytesArray", bytesArrayColumnBase);
            var charColumnBase = new ColumnBase<ColumnMappingBase>("Char", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Char", charColumnBase);
            var charArrayColumnBase = new ColumnBase<ColumnMappingBase>("CharArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("CharArray", charArrayColumnBase);
            var dateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("DateOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnly", dateOnlyColumnBase);
            var dateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnlyArray", dateOnlyArrayColumnBase);
            var dateTimeColumnBase = new ColumnBase<ColumnMappingBase>("DateTime", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTime", dateTimeColumnBase);
            var dateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeArray", dateTimeArrayColumnBase);
            var decimalColumnBase = new ColumnBase<ColumnMappingBase>("Decimal", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Decimal", decimalColumnBase);
            var decimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("DecimalArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DecimalArray", decimalArrayColumnBase);
            var doubleColumnBase = new ColumnBase<ColumnMappingBase>("Double", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Double", doubleColumnBase);
            var doubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("DoubleArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DoubleArray", doubleArrayColumnBase);
            var floatColumnBase = new ColumnBase<ColumnMappingBase>("Float", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Float", floatColumnBase);
            var floatArrayColumnBase = new ColumnBase<ColumnMappingBase>("FloatArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("FloatArray", floatArrayColumnBase);
            var guidColumnBase = new ColumnBase<ColumnMappingBase>("Guid", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Guid", guidColumnBase);
            var guidArrayColumnBase = new ColumnBase<ColumnMappingBase>("GuidArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("GuidArray", guidArrayColumnBase);
            var iPAddressColumnBase = new ColumnBase<ColumnMappingBase>("IPAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddress", iPAddressColumnBase);
            var iPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("IPAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddressArray", iPAddressArrayColumnBase);
            var idColumnBase1 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Id", idColumnBase1);
            var int16ColumnBase = new ColumnBase<ColumnMappingBase>("Int16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16", int16ColumnBase);
            var int16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16Array", int16ArrayColumnBase);
            var int32ColumnBase = new ColumnBase<ColumnMappingBase>("Int32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32", int32ColumnBase);
            var int32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32Array", int32ArrayColumnBase);
            var int64ColumnBase = new ColumnBase<ColumnMappingBase>("Int64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64", int64ColumnBase);
            var int64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64Array", int64ArrayColumnBase);
            var int8ColumnBase = new ColumnBase<ColumnMappingBase>("Int8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8", int8ColumnBase);
            var int8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8Array", int8ArrayColumnBase);
            var nullableBoolColumnBase = new ColumnBase<ColumnMappingBase>("NullableBool", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBool", nullableBoolColumnBase);
            var nullableBoolArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBoolArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBoolArray", nullableBoolArrayColumnBase);
            var nullableBytesColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytes", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytes", nullableBytesColumnBase);
            var nullableBytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytesArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytesArray", nullableBytesArrayColumnBase);
            var nullableCharColumnBase = new ColumnBase<ColumnMappingBase>("NullableChar", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableChar", nullableCharColumnBase);
            var nullableCharArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableCharArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableCharArray", nullableCharArrayColumnBase);
            var nullableDateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnly", nullableDateOnlyColumnBase);
            var nullableDateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumnBase);
            var nullableDateTimeColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTime", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTime", nullableDateTimeColumnBase);
            var nullableDateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTimeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumnBase);
            var nullableDecimalColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimal", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimal", nullableDecimalColumnBase);
            var nullableDecimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimalArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumnBase);
            var nullableDoubleColumnBase = new ColumnBase<ColumnMappingBase>("NullableDouble", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDouble", nullableDoubleColumnBase);
            var nullableDoubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDoubleArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumnBase);
            var nullableFloatColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloat", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloat", nullableFloatColumnBase);
            var nullableFloatArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloatArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloatArray", nullableFloatArrayColumnBase);
            var nullableGuidColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuid", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuid", nullableGuidColumnBase);
            var nullableGuidArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuidArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuidArray", nullableGuidArrayColumnBase);
            var nullableIPAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddress", nullableIPAddressColumnBase);
            var nullableIPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumnBase);
            var nullableInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16", nullableInt16ColumnBase);
            var nullableInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16Array", nullableInt16ArrayColumnBase);
            var nullableInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32", nullableInt32ColumnBase);
            var nullableInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32Array", nullableInt32ArrayColumnBase);
            var nullableInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64", nullableInt64ColumnBase);
            var nullableInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64Array", nullableInt64ArrayColumnBase);
            var nullableInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8", nullableInt8ColumnBase);
            var nullableInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8Array", nullableInt8ArrayColumnBase);
            var nullablePhysicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumnBase);
            var nullablePhysicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumnBase);
            var nullableStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableString", nullableStringColumnBase);
            var nullableStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableStringArray", nullableStringArrayColumnBase);
            var nullableTimeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumnBase);
            var nullableTimeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumnBase);
            var nullableTimeSpanColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpan", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpan", nullableTimeSpanColumnBase);
            var nullableTimeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpanArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumnBase);
            var nullableUInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16", nullableUInt16ColumnBase);
            var nullableUInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumnBase);
            var nullableUInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32", nullableUInt32ColumnBase);
            var nullableUInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumnBase);
            var nullableUInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64", nullableUInt64ColumnBase);
            var nullableUInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumnBase);
            var nullableUInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8", nullableUInt8ColumnBase);
            var nullableUInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumnBase);
            var nullableUriColumnBase = new ColumnBase<ColumnMappingBase>("NullableUri", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUri", nullableUriColumnBase);
            var nullableUriArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUriArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUriArray", nullableUriArrayColumnBase);
            var physicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddress", physicalAddressColumnBase);
            var physicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumnBase);
            var stringColumnBase = new ColumnBase<ColumnMappingBase>("String", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("String", stringColumnBase);
            var stringArrayColumnBase = new ColumnBase<ColumnMappingBase>("StringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringArray", stringArrayColumnBase);
            var timeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnly", timeOnlyColumnBase);
            var timeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnlyArray", timeOnlyArrayColumnBase);
            var timeSpanColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpan", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpan", timeSpanColumnBase);
            var timeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpanArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpanArray", timeSpanArrayColumnBase);
            var uInt16ColumnBase = new ColumnBase<ColumnMappingBase>("UInt16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16", uInt16ColumnBase);
            var uInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16Array", uInt16ArrayColumnBase);
            var uInt32ColumnBase = new ColumnBase<ColumnMappingBase>("UInt32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32", uInt32ColumnBase);
            var uInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32Array", uInt32ArrayColumnBase);
            var uInt64ColumnBase = new ColumnBase<ColumnMappingBase>("UInt64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64", uInt64ColumnBase);
            var uInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64Array", uInt64ArrayColumnBase);
            var uInt8ColumnBase = new ColumnBase<ColumnMappingBase>("UInt8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8", uInt8ColumnBase);
            var uInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt8Array", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8Array", uInt8ArrayColumnBase);
            var uriColumnBase = new ColumnBase<ColumnMappingBase>("Uri", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Uri", uriColumnBase);
            var uriArrayColumnBase = new ColumnBase<ColumnMappingBase>("UriArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UriArray", uriArrayColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase = new TableMappingBase<ColumnMappingBase>(manyTypes, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase, false);
            defaultTableMappings2.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, manyTypes.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolColumnBase, manyTypes.FindProperty("Bool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolArrayColumnBase, manyTypes.FindProperty("BoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesColumnBase, manyTypes.FindProperty("Bytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesArrayColumnBase, manyTypes.FindProperty("BytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charColumnBase, manyTypes.FindProperty("Char")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charArrayColumnBase, manyTypes.FindProperty("CharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyColumnBase, manyTypes.FindProperty("DateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyArrayColumnBase, manyTypes.FindProperty("DateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeColumnBase, manyTypes.FindProperty("DateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeArrayColumnBase, manyTypes.FindProperty("DateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalColumnBase, manyTypes.FindProperty("Decimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalArrayColumnBase, manyTypes.FindProperty("DecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleColumnBase, manyTypes.FindProperty("Double")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleArrayColumnBase, manyTypes.FindProperty("DoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatColumnBase, manyTypes.FindProperty("Float")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatArrayColumnBase, manyTypes.FindProperty("FloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidColumnBase, manyTypes.FindProperty("Guid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidArrayColumnBase, manyTypes.FindProperty("GuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressColumnBase, manyTypes.FindProperty("IPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressArrayColumnBase, manyTypes.FindProperty("IPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ColumnBase, manyTypes.FindProperty("Int16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ArrayColumnBase, manyTypes.FindProperty("Int16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ColumnBase, manyTypes.FindProperty("Int32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ArrayColumnBase, manyTypes.FindProperty("Int32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ColumnBase, manyTypes.FindProperty("Int64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ArrayColumnBase, manyTypes.FindProperty("Int64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ColumnBase, manyTypes.FindProperty("Int8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ArrayColumnBase, manyTypes.FindProperty("Int8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolColumnBase, manyTypes.FindProperty("NullableBool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolArrayColumnBase, manyTypes.FindProperty("NullableBoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesColumnBase, manyTypes.FindProperty("NullableBytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesArrayColumnBase, manyTypes.FindProperty("NullableBytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharColumnBase, manyTypes.FindProperty("NullableChar")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharArrayColumnBase, manyTypes.FindProperty("NullableCharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyColumnBase, manyTypes.FindProperty("NullableDateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyArrayColumnBase, manyTypes.FindProperty("NullableDateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeColumnBase, manyTypes.FindProperty("NullableDateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeArrayColumnBase, manyTypes.FindProperty("NullableDateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalColumnBase, manyTypes.FindProperty("NullableDecimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalArrayColumnBase, manyTypes.FindProperty("NullableDecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleColumnBase, manyTypes.FindProperty("NullableDouble")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleArrayColumnBase, manyTypes.FindProperty("NullableDoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatColumnBase, manyTypes.FindProperty("NullableFloat")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatArrayColumnBase, manyTypes.FindProperty("NullableFloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidColumnBase, manyTypes.FindProperty("NullableGuid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidArrayColumnBase, manyTypes.FindProperty("NullableGuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressColumnBase, manyTypes.FindProperty("NullableIPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressArrayColumnBase, manyTypes.FindProperty("NullableIPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ColumnBase, manyTypes.FindProperty("NullableInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ArrayColumnBase, manyTypes.FindProperty("NullableInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ColumnBase, manyTypes.FindProperty("NullableInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ArrayColumnBase, manyTypes.FindProperty("NullableInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ColumnBase, manyTypes.FindProperty("NullableInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ArrayColumnBase, manyTypes.FindProperty("NullableInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ColumnBase, manyTypes.FindProperty("NullableInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ArrayColumnBase, manyTypes.FindProperty("NullableInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressColumnBase, manyTypes.FindProperty("NullablePhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressArrayColumnBase, manyTypes.FindProperty("NullablePhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringColumnBase, manyTypes.FindProperty("NullableString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringArrayColumnBase, manyTypes.FindProperty("NullableStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyColumnBase, manyTypes.FindProperty("NullableTimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyArrayColumnBase, manyTypes.FindProperty("NullableTimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanColumnBase, manyTypes.FindProperty("NullableTimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanArrayColumnBase, manyTypes.FindProperty("NullableTimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ColumnBase, manyTypes.FindProperty("NullableUInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ArrayColumnBase, manyTypes.FindProperty("NullableUInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ColumnBase, manyTypes.FindProperty("NullableUInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ArrayColumnBase, manyTypes.FindProperty("NullableUInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ColumnBase, manyTypes.FindProperty("NullableUInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ArrayColumnBase, manyTypes.FindProperty("NullableUInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ColumnBase, manyTypes.FindProperty("NullableUInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ArrayColumnBase, manyTypes.FindProperty("NullableUInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriColumnBase, manyTypes.FindProperty("NullableUri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriArrayColumnBase, manyTypes.FindProperty("NullableUriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressColumnBase, manyTypes.FindProperty("PhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressArrayColumnBase, manyTypes.FindProperty("PhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringColumnBase, manyTypes.FindProperty("String")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringArrayColumnBase, manyTypes.FindProperty("StringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyColumnBase, manyTypes.FindProperty("TimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyArrayColumnBase, manyTypes.FindProperty("TimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanColumnBase, manyTypes.FindProperty("TimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanArrayColumnBase, manyTypes.FindProperty("TimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ColumnBase, manyTypes.FindProperty("UInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ArrayColumnBase, manyTypes.FindProperty("UInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ColumnBase, manyTypes.FindProperty("UInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ArrayColumnBase, manyTypes.FindProperty("UInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ColumnBase, manyTypes.FindProperty("UInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ArrayColumnBase, manyTypes.FindProperty("UInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ColumnBase, manyTypes.FindProperty("UInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ArrayColumnBase, manyTypes.FindProperty("UInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriColumnBase, manyTypes.FindProperty("Uri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriArrayColumnBase, manyTypes.FindProperty("UriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);

            var tableMappings2 = new List<TableMapping>();
            manyTypes.SetRuntimeAnnotation("Relational:TableMappings", tableMappings2);
            var manyTypesTable = new Table("ManyTypes", null, relationalModel);
            var idColumn1 = new Column("Id", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Id", idColumn1);
            var boolColumn = new Column("Bool", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Bool", boolColumn);
            var boolArrayColumn = new Column("BoolArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
            var bytesColumn = new Column("Bytes", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Bytes", bytesColumn);
            var bytesArrayColumn = new Column("BytesArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
            var charColumn = new Column("Char", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Char", charColumn);
            var charArrayColumn = new Column("CharArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("CharArray", charArrayColumn);
            var dateOnlyColumn = new Column("DateOnly", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
            var dateOnlyArrayColumn = new Column("DateOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
            var dateTimeColumn = new Column("DateTime", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
            var dateTimeArrayColumn = new Column("DateTimeArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
            var decimalColumn = new Column("Decimal", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Decimal", decimalColumn);
            var decimalArrayColumn = new Column("DecimalArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
            var doubleColumn = new Column("Double", "REAL", manyTypesTable);
            manyTypesTable.Columns.Add("Double", doubleColumn);
            var doubleArrayColumn = new Column("DoubleArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
            var floatColumn = new Column("Float", "REAL", manyTypesTable);
            manyTypesTable.Columns.Add("Float", floatColumn);
            var floatArrayColumn = new Column("FloatArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
            var guidColumn = new Column("Guid", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Guid", guidColumn);
            var guidArrayColumn = new Column("GuidArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
            var iPAddressColumn = new Column("IPAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
            var iPAddressArrayColumn = new Column("IPAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
            var int16Column = new Column("Int16", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int16", int16Column);
            var int16ArrayColumn = new Column("Int16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
            var int32Column = new Column("Int32", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int32", int32Column);
            var int32ArrayColumn = new Column("Int32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
            var int64Column = new Column("Int64", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int64", int64Column);
            var int64ArrayColumn = new Column("Int64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
            var int8Column = new Column("Int8", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int8", int8Column);
            var int8ArrayColumn = new Column("Int8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
            var nullableBoolColumn = new Column("NullableBool", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
            var nullableBoolArrayColumn = new Column("NullableBoolArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
            var nullableBytesColumn = new Column("NullableBytes", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
            var nullableBytesArrayColumn = new Column("NullableBytesArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
            var nullableCharColumn = new Column("NullableChar", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
            var nullableCharArrayColumn = new Column("NullableCharArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
            var nullableDateOnlyColumn = new Column("NullableDateOnly", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
            var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
            var nullableDateTimeColumn = new Column("NullableDateTime", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
            var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
            var nullableDecimalColumn = new Column("NullableDecimal", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
            var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
            var nullableDoubleColumn = new Column("NullableDouble", "REAL", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
            var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
            var nullableFloatColumn = new Column("NullableFloat", "REAL", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
            var nullableFloatArrayColumn = new Column("NullableFloatArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
            var nullableGuidColumn = new Column("NullableGuid", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
            var nullableGuidArrayColumn = new Column("NullableGuidArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
            var nullableIPAddressColumn = new Column("NullableIPAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
            var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
            var nullableInt16Column = new Column("NullableInt16", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
            var nullableInt16ArrayColumn = new Column("NullableInt16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
            var nullableInt32Column = new Column("NullableInt32", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
            var nullableInt32ArrayColumn = new Column("NullableInt32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
            var nullableInt64Column = new Column("NullableInt64", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
            var nullableInt64ArrayColumn = new Column("NullableInt64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
            var nullableInt8Column = new Column("NullableInt8", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
            var nullableInt8ArrayColumn = new Column("NullableInt8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
            var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
            var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
            var nullableStringColumn = new Column("NullableString", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
            var nullableStringArrayColumn = new Column("NullableStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
            var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
            var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
            var nullableTimeSpanColumn = new Column("NullableTimeSpan", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
            var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
            var nullableUInt16Column = new Column("NullableUInt16", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
            var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
            var nullableUInt32Column = new Column("NullableUInt32", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
            var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
            var nullableUInt64Column = new Column("NullableUInt64", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
            var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
            var nullableUInt8Column = new Column("NullableUInt8", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
            var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
            var nullableUriColumn = new Column("NullableUri", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
            var nullableUriArrayColumn = new Column("NullableUriArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
            var physicalAddressColumn = new Column("PhysicalAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
            var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
            var stringColumn = new Column("String", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("String", stringColumn);
            var stringArrayColumn = new Column("StringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
            var timeOnlyColumn = new Column("TimeOnly", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
            var timeOnlyArrayColumn = new Column("TimeOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
            var timeSpanColumn = new Column("TimeSpan", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
            var timeSpanArrayColumn = new Column("TimeSpanArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
            var uInt16Column = new Column("UInt16", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt16", uInt16Column);
            var uInt16ArrayColumn = new Column("UInt16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
            var uInt32Column = new Column("UInt32", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt32", uInt32Column);
            var uInt32ArrayColumn = new Column("UInt32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
            var uInt64Column = new Column("UInt64", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt64", uInt64Column);
            var uInt64ArrayColumn = new Column("UInt64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
            var uInt8Column = new Column("UInt8", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt8", uInt8Column);
            var uInt8ArrayColumn = new Column("UInt8Array", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
            var uriColumn = new Column("Uri", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Uri", uriColumn);
            var uriArrayColumn = new Column("UriArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn1 });
            manyTypesTable.PrimaryKey = pK_ManyTypes;
            var pK_ManyTypesUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                new[] { "Id" });
            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesUc).Add(pK_ManyTypes);
            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
            relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
            var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, true);
            manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
            tableMappings2.Add(manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(idColumn1, manyTypes.FindProperty("Id")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolColumn, manyTypes.FindProperty("Bool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolArrayColumn, manyTypes.FindProperty("BoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesColumn, manyTypes.FindProperty("Bytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesArrayColumn, manyTypes.FindProperty("BytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charColumn, manyTypes.FindProperty("Char")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charArrayColumn, manyTypes.FindProperty("CharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyColumn, manyTypes.FindProperty("DateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyArrayColumn, manyTypes.FindProperty("DateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeColumn, manyTypes.FindProperty("DateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeArrayColumn, manyTypes.FindProperty("DateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalColumn, manyTypes.FindProperty("Decimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalArrayColumn, manyTypes.FindProperty("DecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleColumn, manyTypes.FindProperty("Double")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleArrayColumn, manyTypes.FindProperty("DoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatColumn, manyTypes.FindProperty("Float")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatArrayColumn, manyTypes.FindProperty("FloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidColumn, manyTypes.FindProperty("Guid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidArrayColumn, manyTypes.FindProperty("GuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressColumn, manyTypes.FindProperty("IPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressArrayColumn, manyTypes.FindProperty("IPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16Column, manyTypes.FindProperty("Int16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16ArrayColumn, manyTypes.FindProperty("Int16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32Column, manyTypes.FindProperty("Int32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32ArrayColumn, manyTypes.FindProperty("Int32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64Column, manyTypes.FindProperty("Int64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64ArrayColumn, manyTypes.FindProperty("Int64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8Column, manyTypes.FindProperty("Int8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8ArrayColumn, manyTypes.FindProperty("Int8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolColumn, manyTypes.FindProperty("NullableBool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolArrayColumn, manyTypes.FindProperty("NullableBoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesColumn, manyTypes.FindProperty("NullableBytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesArrayColumn, manyTypes.FindProperty("NullableBytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharColumn, manyTypes.FindProperty("NullableChar")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharArrayColumn, manyTypes.FindProperty("NullableCharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyColumn, manyTypes.FindProperty("NullableDateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyArrayColumn, manyTypes.FindProperty("NullableDateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeColumn, manyTypes.FindProperty("NullableDateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeArrayColumn, manyTypes.FindProperty("NullableDateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalColumn, manyTypes.FindProperty("NullableDecimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalArrayColumn, manyTypes.FindProperty("NullableDecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleColumn, manyTypes.FindProperty("NullableDouble")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleArrayColumn, manyTypes.FindProperty("NullableDoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatColumn, manyTypes.FindProperty("NullableFloat")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatArrayColumn, manyTypes.FindProperty("NullableFloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidColumn, manyTypes.FindProperty("NullableGuid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidArrayColumn, manyTypes.FindProperty("NullableGuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressColumn, manyTypes.FindProperty("NullableIPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressArrayColumn, manyTypes.FindProperty("NullableIPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16Column, manyTypes.FindProperty("NullableInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16ArrayColumn, manyTypes.FindProperty("NullableInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32Column, manyTypes.FindProperty("NullableInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32ArrayColumn, manyTypes.FindProperty("NullableInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64Column, manyTypes.FindProperty("NullableInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64ArrayColumn, manyTypes.FindProperty("NullableInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8Column, manyTypes.FindProperty("NullableInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8ArrayColumn, manyTypes.FindProperty("NullableInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressColumn, manyTypes.FindProperty("NullablePhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressArrayColumn, manyTypes.FindProperty("NullablePhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringColumn, manyTypes.FindProperty("NullableString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringArrayColumn, manyTypes.FindProperty("NullableStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyColumn, manyTypes.FindProperty("NullableTimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyArrayColumn, manyTypes.FindProperty("NullableTimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanColumn, manyTypes.FindProperty("NullableTimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanArrayColumn, manyTypes.FindProperty("NullableTimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16Column, manyTypes.FindProperty("NullableUInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16ArrayColumn, manyTypes.FindProperty("NullableUInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32Column, manyTypes.FindProperty("NullableUInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32ArrayColumn, manyTypes.FindProperty("NullableUInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64Column, manyTypes.FindProperty("NullableUInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64ArrayColumn, manyTypes.FindProperty("NullableUInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8Column, manyTypes.FindProperty("NullableUInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8ArrayColumn, manyTypes.FindProperty("NullableUInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriColumn, manyTypes.FindProperty("NullableUri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriArrayColumn, manyTypes.FindProperty("NullableUriArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressColumn, manyTypes.FindProperty("PhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressArrayColumn, manyTypes.FindProperty("PhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringColumn, manyTypes.FindProperty("String")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringArrayColumn, manyTypes.FindProperty("StringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyColumn, manyTypes.FindProperty("TimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyArrayColumn, manyTypes.FindProperty("TimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanColumn, manyTypes.FindProperty("TimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanArrayColumn, manyTypes.FindProperty("TimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16Column, manyTypes.FindProperty("UInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16ArrayColumn, manyTypes.FindProperty("UInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32Column, manyTypes.FindProperty("UInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32ArrayColumn, manyTypes.FindProperty("UInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64Column, manyTypes.FindProperty("UInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64ArrayColumn, manyTypes.FindProperty("UInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8Column, manyTypes.FindProperty("UInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8ArrayColumn, manyTypes.FindProperty("UInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);

            var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase")!;

            var defaultTableMappings3 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings3);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", null, relationalModel);
            var alternateIdColumnBase = new ColumnBase<ColumnMappingBase>("AlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("AlternateId", alternateIdColumnBase);
            var enum1ColumnBase = new ColumnBase<ColumnMappingBase>("Enum1", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum1", enum1ColumnBase);
            var enum2ColumnBase = new ColumnBase<ColumnMappingBase>("Enum2", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum2", enum2ColumnBase);
            var flagsEnum1ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase);
            var flagsEnum2ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase);
            var idColumnBase2 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Id", idColumnBase2);
            var pointColumnBase0 = new ColumnBase<ColumnMappingBase>("Point", "geometry", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Point", pointColumnBase0);
            var refTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase);
            var refTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase);
            var refTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase);
            var refTypeListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeList", refTypeListColumnBase);
            var valueTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase);
            var valueTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase);
            var valueTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase);
            var valueTypeListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase = new TableMappingBase<ColumnMappingBase>(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase, false);
            defaultTableMappings3.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalBase.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase2, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase0, principalBase.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);

            var tableMappings3 = new List<TableMapping>();
            principalBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings3);
            var principalBaseTable = new Table("PrincipalBase", "mySchema", relationalModel);
            var idColumn2 = new Column("Id", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("Id", idColumn2);
            var alternateIdColumn = new Column("AlternateId", "TEXT", principalBaseTable);
            principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
            var enum1Column = new Column("Enum1", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("Enum1", enum1Column);
            var enum2Column = new Column("Enum2", "INTEGER", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Enum2", enum2Column);
            var flagsEnum1Column = new Column("FlagsEnum1", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
            var flagsEnum2Column = new Column("FlagsEnum2", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
            var owned_NumberColumn = new Column("Owned_Number", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
            var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
            var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
            var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
            var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
            var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
            var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
            var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
            var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
            var pointColumn0 = new Column("Point", "geometry", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Point", pointColumn0);
            var refTypeArrayColumn = new Column("RefTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
            var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
            var refTypeIListColumn = new Column("RefTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
            var refTypeListColumn = new Column("RefTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
            var valueTypeArrayColumn = new Column("ValueTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
            var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
            var valueTypeIListColumn = new Column("ValueTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
            var valueTypeListColumn = new Column("ValueTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn2 });
            var aK_PrincipalBase_IdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdUc).Add(aK_PrincipalBase_Id);
            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn2, alternateIdColumn });
            principalBaseTable.PrimaryKey = pK;
            var pKUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK.MappedKeys.Add(pKUc);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc).Add(pK);
            var pKUc0 = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            pK.MappedKeys.Add(pKUc0);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc0).Add(pK);
            principalBaseTable.UniqueConstraints.Add("PK", pK);
            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn2 }, false);
            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
            relationalModel.Tables.Add(("PrincipalBase", "mySchema"), principalBaseTable);
            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
            tableMappings3.Add(principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalBase.FindProperty("AlternateId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(idColumn2, principalBase.FindProperty("Id")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(pointColumn0, principalBase.FindProperty("Point")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);

            var ownedType = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType")!;

            var defaultTableMappings4 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings4);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", null, relationalModel);
            var detailsColumnBase = new ColumnBase<ColumnMappingBase>("Details", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Details", detailsColumnBase);
            var numberColumnBase = new ColumnBase<ColumnMappingBase>("Number", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Number", numberColumnBase);
            var principalBaseAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseAlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumnBase);
            var principalBaseIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseId", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("PrincipalBaseId", principalBaseIdColumnBase);
            var refTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase0);
            var refTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase0);
            var refTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase0);
            var refTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeList", refTypeListColumnBase0);
            var valueTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase0);
            var valueTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase0);
            var valueTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase0);
            var valueTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase0);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase, false);
            defaultTableMappings4.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseAlternateIdColumnBase, ownedType.FindProperty("PrincipalBaseAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase, ownedType.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)detailsColumnBase, ownedType.FindProperty("Details")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)numberColumnBase, ownedType.FindProperty("Number")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase0, ownedType.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase0, ownedType.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase0, ownedType.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase0, ownedType.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase0, ownedType.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase0, ownedType.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase0, ownedType.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase0, ownedType.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);

            var tableMappings4 = new List<TableMapping>();
            ownedType.SetRuntimeAnnotation("Relational:TableMappings", tableMappings4);
            var principalBaseTableMapping0 = new TableMapping(ownedType, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
                IsSplitEntityTypePrincipal = true
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping0, false);
            tableMappings4.Add(principalBaseTableMapping0);
            principalBaseTable.AddRowInternalForeignKey(ownedType, RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" }));
            RelationalModel.CreateColumnMapping(alternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn2, ownedType.FindProperty("PrincipalBaseId")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_NumberColumn, ownedType.FindProperty("Number")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeArrayColumn, ownedType.FindProperty("RefTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeEnumerableColumn, ownedType.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeIListColumn, ownedType.FindProperty("RefTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeListColumn, ownedType.FindProperty("RefTypeList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeArrayColumn, ownedType.FindProperty("ValueTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeEnumerableColumn, ownedType.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeIListColumn, ownedType.FindProperty("ValueTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeListColumn, ownedType.FindProperty("ValueTypeList")!, principalBaseTableMapping0);
            var detailsTable = new Table("Details", null, relationalModel);
            var principalBaseIdColumn = new Column("PrincipalBaseId", "INTEGER", detailsTable);
            detailsTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
            var principalBaseAlternateIdColumn = new Column("PrincipalBaseAlternateId", "TEXT", detailsTable);
            detailsTable.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumn);
            var detailsColumn = new Column("Details", "TEXT", detailsTable)
            {
                IsNullable = true
            };
            detailsTable.Columns.Add("Details", detailsColumn);
            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
            detailsTable.PrimaryKey = pK_Details;
            var pK_DetailsUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            pK_Details.MappedKeys.Add(pK_DetailsUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsUc).Add(pK_Details);
            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
            relationalModel.Tables.Add(("Details", null), detailsTable);
            var detailsTableMapping = new TableMapping(ownedType, detailsTable, true)
            {
                IsSplitEntityTypePrincipal = false
            };
            detailsTable.AddTypeMapping(detailsTableMapping, false);
            tableMappings4.Add(detailsTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseAlternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, detailsTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn, ownedType.FindProperty("PrincipalBaseId")!, detailsTableMapping);
            RelationalModel.CreateColumnMapping(detailsColumn, ownedType.FindProperty("Details")!, detailsTableMapping);

            var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>")!;

            var defaultTableMappings5 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings5);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0 = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, false);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0, false);
            defaultTableMappings5.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase2, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase0, principalDerived.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);

            var defaultTableMappings6 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings6);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", null, relationalModel);
            var alternateIdColumnBase0 = new ColumnBase<ColumnMappingBase>("AlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("AlternateId", alternateIdColumnBase0);
            var idColumnBase3 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase3);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings6.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase0, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase3, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings5 = new List<TableMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings5);
            var principalBaseTableMapping1 = new TableMapping(principalDerived, principalBaseTable, false)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping1, false);
            tableMappings5.Add(principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalDerived.FindProperty("AlternateId")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(idColumn2, principalDerived.FindProperty("Id")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum1Column, principalDerived.FindProperty("Enum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum2Column, principalDerived.FindProperty("Enum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalDerived.FindProperty("FlagsEnum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalDerived.FindProperty("FlagsEnum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(pointColumn0, principalDerived.FindProperty("Point")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalDerived.FindProperty("RefTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalDerived.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalDerived.FindProperty("RefTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalDerived.FindProperty("RefTypeList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalDerived.FindProperty("ValueTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping1);
            var principalDerivedTable = new Table("PrincipalDerived", null, relationalModel);
            var derivedIdColumn = new Column("DerivedId", "INTEGER", principalDerivedTable);
            principalDerivedTable.Columns.Add("DerivedId", derivedIdColumn);
            var alternateIdColumn0 = new Column("AlternateId", "TEXT", principalDerivedTable);
            principalDerivedTable.Columns.Add("AlternateId", alternateIdColumn0);
            var aK_PrincipalDerived_DerivedId = new UniqueConstraint("AK_PrincipalDerived_DerivedId", principalDerivedTable, new[] { derivedIdColumn });
            var aK_PrincipalDerived_DerivedIdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalDerived_DerivedId.MappedKeys.Add(aK_PrincipalDerived_DerivedIdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalDerived_DerivedIdUc).Add(aK_PrincipalDerived_DerivedId);
            principalDerivedTable.UniqueConstraints.Add("AK_PrincipalDerived_DerivedId", aK_PrincipalDerived_DerivedId);
            var pK0 = new UniqueConstraint("PK", principalDerivedTable, new[] { derivedIdColumn, alternateIdColumn0 });
            principalDerivedTable.PrimaryKey = pK0;
            var pK0Uc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK0.MappedKeys.Add(pK0Uc);
            RelationalModel.GetOrCreateUniqueConstraints(pK0Uc).Add(pK0);
            principalDerivedTable.UniqueConstraints.Add("PK", pK0);
            var iX_PrincipalDerived_AlternateId_DerivedId = new TableIndex(
            "IX_PrincipalDerived_AlternateId_DerivedId", principalDerivedTable, new[] { alternateIdColumn0, derivedIdColumn }, false);
            var iX_PrincipalDerived_AlternateId_DerivedIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalDerived_AlternateId_DerivedId.MappedIndexes.Add(iX_PrincipalDerived_AlternateId_DerivedIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalDerived_AlternateId_DerivedIdIx).Add(iX_PrincipalDerived_AlternateId_DerivedId);
            principalDerivedTable.Indexes.Add("IX_PrincipalDerived_AlternateId_DerivedId", iX_PrincipalDerived_AlternateId_DerivedId);
            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, true);
            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
            tableMappings5.Add(principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);

            var ownedType0 = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType")!;

            var defaultTableMappings7 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType0.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings7);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", null, relationalModel);
            var detailsColumnBase0 = new ColumnBase<ColumnMappingBase>("Details", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Details", detailsColumnBase0);
            var idColumnBase4 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Id", idColumnBase4);
            var numberColumnBase0 = new ColumnBase<ColumnMappingBase>("Number", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Number", numberColumnBase0);
            var principalDerivedDependentBasebyteAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>AlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumnBase);
            var principalDerivedDependentBasebyteIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumnBase);
            var refTypeArrayColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase1);
            var refTypeEnumerableColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase1);
            var refTypeIListColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase1);
            var refTypeListColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeList", refTypeListColumnBase1);
            var valueTypeArrayColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase1);
            var valueTypeEnumerableColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase1);
            var valueTypeIListColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase1);
            var valueTypeListColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase1);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType0, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase, false);
            defaultTableMappings7.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase4, ownedType0.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteAlternateIdColumnBase, ownedType0.FindProperty("PrincipalDerivedAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteIdColumnBase, ownedType0.FindProperty("PrincipalDerivedId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)detailsColumnBase0, ownedType0.FindProperty("Details")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)numberColumnBase0, ownedType0.FindProperty("Number")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase1, ownedType0.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase1, ownedType0.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase1, ownedType0.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase1, ownedType0.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase1, ownedType0.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase1, ownedType0.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase1, ownedType0.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase1, ownedType0.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);

            var tableMappings6 = new List<TableMapping>();
            ownedType0.SetRuntimeAnnotation("Relational:TableMappings", tableMappings6);
            var manyOwnedTable = new Table("ManyOwned", null, relationalModel);
            var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "INTEGER", manyOwnedTable);
            manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
            var principalDerivedDependentBasebyteAlternateIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>AlternateId", "TEXT", manyOwnedTable);
            manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumn);
            var idColumn3 = new Column("Id", "INTEGER", manyOwnedTable);
            manyOwnedTable.Columns.Add("Id", idColumn3);
            var detailsColumn0 = new Column("Details", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("Details", detailsColumn0);
            var numberColumn = new Column("Number", "INTEGER", manyOwnedTable);
            manyOwnedTable.Columns.Add("Number", numberColumn);
            var refTypeArrayColumn0 = new Column("RefTypeArray", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
            var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
            var refTypeIListColumn0 = new Column("RefTypeIList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
            var refTypeListColumn0 = new Column("RefTypeList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeList", refTypeListColumn0);
            var valueTypeArrayColumn0 = new Column("ValueTypeArray", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
            var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
            var valueTypeIListColumn0 = new Column("ValueTypeIList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
            var valueTypeListColumn0 = new Column("ValueTypeList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn3 });
            manyOwnedTable.PrimaryKey = pK_ManyOwned;
            var pK_ManyOwnedUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedUc).Add(pK_ManyOwned);
            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
            relationalModel.Tables.Add(("ManyOwned", null), manyOwnedTable);
            var manyOwnedTableMapping = new TableMapping(ownedType0, manyOwnedTable, true);
            manyOwnedTable.AddTypeMapping(manyOwnedTableMapping, false);
            tableMappings6.Add(manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(idColumn3, ownedType0.FindProperty("Id")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteAlternateIdColumn, ownedType0.FindProperty("PrincipalDerivedAlternateId")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn, ownedType0.FindProperty("PrincipalDerivedId")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(detailsColumn0, ownedType0.FindProperty("Details")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(numberColumn, ownedType0.FindProperty("Number")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn0, ownedType0.FindProperty("RefTypeArray")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn0, ownedType0.FindProperty("RefTypeEnumerable")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn0, ownedType0.FindProperty("RefTypeIList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn0, ownedType0.FindProperty("RefTypeList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn0, ownedType0.FindProperty("ValueTypeArray")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, ownedType0.FindProperty("ValueTypeEnumerable")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn0, ownedType0.FindProperty("ValueTypeIList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn0, ownedType0.FindProperty("ValueTypeList")!, manyOwnedTableMapping);

            var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;

            var defaultTableMappings8 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings8);
            var principalBasePrincipalDerivedDependentBasebyteTableBase = new TableBase("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumnBase);
            var derivedsIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsId", derivedsIdColumnBase);
            var principalsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumnBase);
            var principalsIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsId", principalsIdColumnBase);
            var rowidColumnBase = new ColumnBase<ColumnMappingBase>("rowid", "BLOB", principalBasePrincipalDerivedDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("rowid", rowidColumnBase);
            relationalModel.DefaultTables.Add("PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTableBase);
            var principalBasePrincipalDerivedDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTableBase, true);
            principalBasePrincipalDerivedDependentBasebyteTableBase.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteMappingBase, false);
            defaultTableMappings8.Add(principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)rowidColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);

            var tableMappings7 = new List<TableMapping>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:TableMappings", tableMappings7);
            var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsIdColumn = new Column("DerivedsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
            var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
            var principalsIdColumn = new Column("PrincipalsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
            var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
            var rowidColumn = new Column("rowid", "BLOB", principalBasePrincipalDerivedDependentBasebyteTable)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
            var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
            principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
            var pK_PrincipalBasePrincipalDerivedDependentBasebyteUc = RelationalModel.GetKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
            pK_PrincipalBasePrincipalDerivedDependentBasebyte.MappedKeys.Add(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc).Add(pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
            "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" });
            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, true);
            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
            tableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                new[] { principalIdColumn },
                principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
            var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            fK_DependentBasebyte_PrincipalBase_PrincipalId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk).Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalDerivedTable,
                new[] { principalIdColumn, principalAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk).Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId = new ForeignKeyConstraint(
                "FK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId", detailsTable, principalBaseTable,
                new[] { principalBaseIdColumn, principalBaseAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId.MappedForeignKeys.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk).Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            detailsTable.ForeignKeyConstraints.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId = new ForeignKeyConstraint(
                "FK_ManyOwned_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id_PrincipalDerived<DependentBase<byte?>>AlternateId", manyOwnedTable, principalDerivedTable,
                new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId.MappedForeignKeys.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk).Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            manyOwnedTable.ForeignKeyConstraints.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                new[] { principalsIdColumn, principalsAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalDerived_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalDerivedTable,
                new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId = new ForeignKeyConstraint(
                "FK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId", principalDerivedTable, principalBaseTable,
                new[] { derivedIdColumn, alternateIdColumn0 },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId.MappedForeignKeys.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk).Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            principalDerivedTable.ForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var point = runtimeEntityType.AddProperty(
                "Point",
                typeof(Point),
                nullable: true);
            point.TypeMapping = null;

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Data");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.One);

            var principalId = runtimeEntityType.AddProperty(
                "PrincipalId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var principalAlternateId = runtimeEntityType.AddProperty(
                "PrincipalAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var enumDiscriminator = runtimeEntityType.AddProperty(
                "EnumDiscriminator",
                typeof(CSharpMigrationsGeneratorTest.Enum1),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create,
                sentinel: CSharpMigrationsGeneratorTest.Enum1.Default);
            enumDiscriminator.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                keyComparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                    (int value) => (CSharpMigrationsGeneratorTest.Enum1)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                        (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                        (int value) => (CSharpMigrationsGeneratorTest.Enum1)value)));

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            id.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var key = runtimeEntityType.AddKey(
                new[] { principalId, principalAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId"), declaringEntityType.FindProperty("PrincipalAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientNoAction,
                unique: true,
                required: true);

            var principal = declaringEntityType.AddNavigation("Principal",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation("Dependent",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Dependent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Dependent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("DiscriminatorMappingComplete", false);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "ManyTypesEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal.Json;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class ManyTypesEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var @bool = runtimeEntityType.AddProperty(
                "Bool",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            @bool.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var boolArray = runtimeEntityType.AddProperty(
                "BoolArray",
                typeof(bool[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            boolArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                keyComparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: BoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var bytes = runtimeEntityType.AddProperty(
                "Bytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytes.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var bytesArray = runtimeEntityType.AddProperty(
                "BytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytesArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance),
                elementMapping: SqliteByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray())));

            var @char = runtimeEntityType.AddProperty(
                "Char",
                typeof(char),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: ' ');
            @char.TypeMapping = CharTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var charArray = runtimeEntityType.AddProperty(
                "CharArray",
                typeof(char[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            charArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                keyComparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionReaderWriter<char[], char[], char>(
                    JsonCharReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<char[], char[], char>(
                    JsonCharReaderWriter.Instance),
                elementMapping: CharTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var dateOnly = runtimeEntityType.AddProperty(
                "DateOnly",
                typeof(DateOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dateOnly.TypeMapping = SqliteDateOnlyTypeMapping.Default;

            var dateOnlyArray = runtimeEntityType.AddProperty(
                "DateOnlyArray",
                typeof(DateOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                keyComparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqliteDateOnlyTypeMapping.Default);

            var dateTime = runtimeEntityType.AddProperty(
                "DateTime",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTime.TypeMapping = SqliteDateTimeTypeMapping.Default;

            var dateTimeArray = runtimeEntityType.AddProperty(
                "DateTimeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateTimeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var @decimal = runtimeEntityType.AddProperty(
                "Decimal",
                typeof(decimal),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0m);
            @decimal.TypeMapping = SqliteDecimalTypeMapping.Default;

            var decimalArray = runtimeEntityType.AddProperty(
                "DecimalArray",
                typeof(decimal[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            decimalArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                keyComparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance),
                elementMapping: SqliteDecimalTypeMapping.Default);

            var @double = runtimeEntityType.AddProperty(
                "Double",
                typeof(double),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0.0);
            @double.TypeMapping = DoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var doubleArray = runtimeEntityType.AddProperty(
                "DoubleArray",
                typeof(double[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            doubleArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                keyComparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: DoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var @float = runtimeEntityType.AddProperty(
                "Float",
                typeof(float),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0f);
            @float.TypeMapping = FloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var floatArray = runtimeEntityType.AddProperty(
                "FloatArray",
                typeof(float[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            floatArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                keyComparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: FloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var guid = runtimeEntityType.AddProperty(
                "Guid",
                typeof(Guid),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            guid.TypeMapping = SqliteGuidTypeMapping.Default;

            var guidArray = runtimeEntityType.AddProperty(
                "GuidArray",
                typeof(Guid[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            guidArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                keyComparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance),
                elementMapping: SqliteGuidTypeMapping.Default);

            var iPAddress = runtimeEntityType.AddProperty(
                "IPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 45),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));

            var iPAddressArray = runtimeEntityType.AddProperty(
                "IPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var int16 = runtimeEntityType.AddProperty(
                "Int16",
                typeof(short),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (short)0);
            int16.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                keyComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int16Array = runtimeEntityType.AddProperty(
                "Int16Array",
                typeof(short[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var int32 = runtimeEntityType.AddProperty(
                "Int32",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            int32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int32Array = runtimeEntityType.AddProperty(
                "Int32Array",
                typeof(int[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                keyComparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var int64 = runtimeEntityType.AddProperty(
                "Int64",
                typeof(long),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0L);
            int64.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int64Array = runtimeEntityType.AddProperty(
                "Int64Array",
                typeof(long[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                keyComparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var int8 = runtimeEntityType.AddProperty(
                "Int8",
                typeof(sbyte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (sbyte)0);
            int8.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                providerValueComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int8Array = runtimeEntityType.AddProperty(
                "Int8Array",
                typeof(sbyte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                keyComparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    JsonSByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    JsonSByteReaderWriter.Instance),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableBool = runtimeEntityType.AddProperty(
                "NullableBool",
                typeof(bool?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBool.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableBoolArray = runtimeEntityType.AddProperty(
                "NullableBoolArray",
                typeof(bool?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBoolArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                keyComparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<bool?>(new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: BoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableBytes = runtimeEntityType.AddProperty(
                "NullableBytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytes.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var nullableBytesArray = runtimeEntityType.AddProperty(
                "NullableBytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytesArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance),
                elementMapping: SqliteByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray())));

            var nullableChar = runtimeEntityType.AddProperty(
                "NullableChar",
                typeof(char?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableChar.TypeMapping = CharTypeMapping.Default.Clone(
                comparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                keyComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                providerValueComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var nullableCharArray = runtimeEntityType.AddProperty(
                "NullableCharArray",
                typeof(char?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableCharArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                keyComparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<char?>(new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    JsonCharReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    JsonCharReaderWriter.Instance),
                elementMapping: CharTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var nullableDateOnly = runtimeEntityType.AddProperty(
                "NullableDateOnly",
                typeof(DateOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnly.TypeMapping = SqliteDateOnlyTypeMapping.Default;

            var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                "NullableDateOnlyArray",
                typeof(DateOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                keyComparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqliteDateOnlyTypeMapping.Default);

            var nullableDateTime = runtimeEntityType.AddProperty(
                "NullableDateTime",
                typeof(DateTime?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTime.TypeMapping = SqliteDateTimeTypeMapping.Default;

            var nullableDateTimeArray = runtimeEntityType.AddProperty(
                "NullableDateTimeArray",
                typeof(DateTime?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTimeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                keyComparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var nullableDecimal = runtimeEntityType.AddProperty(
                "NullableDecimal",
                typeof(decimal?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimal.TypeMapping = SqliteDecimalTypeMapping.Default;

            var nullableDecimalArray = runtimeEntityType.AddProperty(
                "NullableDecimalArray",
                typeof(decimal?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimalArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                keyComparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<decimal?>(new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance),
                elementMapping: SqliteDecimalTypeMapping.Default);

            var nullableDouble = runtimeEntityType.AddProperty(
                "NullableDouble",
                typeof(double?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDouble.TypeMapping = DoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var nullableDoubleArray = runtimeEntityType.AddProperty(
                "NullableDoubleArray",
                typeof(double?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDoubleArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                keyComparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<double?>(new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: DoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var nullableFloat = runtimeEntityType.AddProperty(
                "NullableFloat",
                typeof(float?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloat.TypeMapping = FloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var nullableFloatArray = runtimeEntityType.AddProperty(
                "NullableFloatArray",
                typeof(float?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloatArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                keyComparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<float?>(new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: FloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var nullableGuid = runtimeEntityType.AddProperty(
                "NullableGuid",
                typeof(Guid?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuid.TypeMapping = SqliteGuidTypeMapping.Default;

            var nullableGuidArray = runtimeEntityType.AddProperty(
                "NullableGuidArray",
                typeof(Guid?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuidArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                keyComparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Guid?>(new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance),
                elementMapping: SqliteGuidTypeMapping.Default);

            var nullableIPAddress = runtimeEntityType.AddProperty(
                "NullableIPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 45),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));

            var nullableIPAddressArray = runtimeEntityType.AddProperty(
                "NullableIPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var nullableInt16 = runtimeEntityType.AddProperty(
                "NullableInt16",
                typeof(short?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                keyComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                providerValueComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt16Array = runtimeEntityType.AddProperty(
                "NullableInt16Array",
                typeof(short?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                keyComparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short?>(new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableInt32 = runtimeEntityType.AddProperty(
                "NullableInt32",
                typeof(int?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt32Array = runtimeEntityType.AddProperty(
                "NullableInt32Array",
                typeof(int?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                keyComparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<int?>(new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableInt64 = runtimeEntityType.AddProperty(
                "NullableInt64",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt64Array = runtimeEntityType.AddProperty(
                "NullableInt64Array",
                typeof(long?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                keyComparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<long?>(new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableInt8 = runtimeEntityType.AddProperty(
                "NullableInt8",
                typeof(sbyte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                keyComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                providerValueComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt8Array = runtimeEntityType.AddProperty(
                "NullableInt8Array",
                typeof(sbyte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                keyComparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    JsonSByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    JsonSByteReaderWriter.Instance),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                "NullablePhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 20),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));

            var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                "NullablePhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 20),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));

            var nullableString = runtimeEntityType.AddProperty(
                "NullableString",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableString.TypeMapping = SqliteStringTypeMapping.Default;

            var nullableStringArray = runtimeEntityType.AddProperty(
                "NullableStringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var nullableTimeOnly = runtimeEntityType.AddProperty(
                "NullableTimeOnly",
                typeof(TimeOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnly.TypeMapping = SqliteTimeOnlyTypeMapping.Default;

            var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                "NullableTimeOnlyArray",
                typeof(TimeOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                keyComparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqliteTimeOnlyTypeMapping.Default);

            var nullableTimeSpan = runtimeEntityType.AddProperty(
                "NullableTimeSpan",
                typeof(TimeSpan?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpan.TypeMapping = TimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                keyComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                providerValueComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                "NullableTimeSpanArray",
                typeof(TimeSpan?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpanArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                keyComparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: TimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var nullableUInt16 = runtimeEntityType.AddProperty(
                "NullableUInt16",
                typeof(ushort?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                keyComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                providerValueComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableUInt16Array = runtimeEntityType.AddProperty(
                "NullableUInt16Array",
                typeof(ushort?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                keyComparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ushort?>(new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    JsonUInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    JsonUInt16ReaderWriter.Instance),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableUInt32 = runtimeEntityType.AddProperty(
                "NullableUInt32",
                typeof(uint?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableUInt32Array = runtimeEntityType.AddProperty(
                "NullableUInt32Array",
                typeof(uint?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                keyComparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<uint?>(new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    JsonUInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    JsonUInt32ReaderWriter.Instance),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableUInt64 = runtimeEntityType.AddProperty(
                "NullableUInt64",
                typeof(ulong?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64.TypeMapping = SqliteULongTypeMapping.Default;

            var nullableUInt64Array = runtimeEntityType.AddProperty(
                "NullableUInt64Array",
                typeof(ulong?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                keyComparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ulong?>(new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    JsonUInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    JsonUInt64ReaderWriter.Instance),
                elementMapping: SqliteULongTypeMapping.Default);

            var nullableUInt8 = runtimeEntityType.AddProperty(
                "NullableUInt8",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableUInt8Array = runtimeEntityType.AddProperty(
                "NullableUInt8Array",
                typeof(byte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                keyComparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte?>(new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableUri = runtimeEntityType.AddProperty(
                "NullableUri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUri.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var nullableUriArray = runtimeEntityType.AddProperty(
                "NullableUriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUriArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));

            var physicalAddress = runtimeEntityType.AddProperty(
                "PhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 20),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));

            var physicalAddressArray = runtimeEntityType.AddProperty(
                "PhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 20),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));

            var @string = runtimeEntityType.AddProperty(
                "String",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            @string.TypeMapping = SqliteStringTypeMapping.Default;

            var stringArray = runtimeEntityType.AddProperty(
                "StringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var timeOnly = runtimeEntityType.AddProperty(
                "TimeOnly",
                typeof(TimeOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeOnly(0, 0, 0));
            timeOnly.TypeMapping = SqliteTimeOnlyTypeMapping.Default;

            var timeOnlyArray = runtimeEntityType.AddProperty(
                "TimeOnlyArray",
                typeof(TimeOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                keyComparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqliteTimeOnlyTypeMapping.Default);

            var timeSpan = runtimeEntityType.AddProperty(
                "TimeSpan",
                typeof(TimeSpan),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeSpan(0, 0, 0, 0, 0));
            timeSpan.TypeMapping = TimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var timeSpanArray = runtimeEntityType.AddProperty(
                "TimeSpanArray",
                typeof(TimeSpan[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeSpanArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                keyComparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: TimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var uInt16 = runtimeEntityType.AddProperty(
                "UInt16",
                typeof(ushort),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            uInt16.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var uInt16Array = runtimeEntityType.AddProperty(
                "UInt16Array",
                typeof(ushort[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                keyComparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    JsonUInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    JsonUInt16ReaderWriter.Instance),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var uInt32 = runtimeEntityType.AddProperty(
                "UInt32",
                typeof(uint),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            uInt32.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var uInt32Array = runtimeEntityType.AddProperty(
                "UInt32Array",
                typeof(uint[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                keyComparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    JsonUInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    JsonUInt32ReaderWriter.Instance),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var uInt64 = runtimeEntityType.AddProperty(
                "UInt64",
                typeof(ulong),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0ul);
            uInt64.TypeMapping = SqliteULongTypeMapping.Default;

            var uInt64Array = runtimeEntityType.AddProperty(
                "UInt64Array",
                typeof(ulong[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                keyComparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    JsonUInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    JsonUInt64ReaderWriter.Instance),
                elementMapping: SqliteULongTypeMapping.Default);

            var uInt8 = runtimeEntityType.AddProperty(
                "UInt8",
                typeof(byte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (byte)0);
            uInt8.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var uInt8Array = runtimeEntityType.AddProperty(
                "UInt8Array",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt8Array.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var uri = runtimeEntityType.AddProperty(
                "Uri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uri.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var uriArray = runtimeEntityType.AddProperty(
                "UriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uriArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyTypes");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal.Json;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorValue: "PrincipalBase");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var idPrincipalDerived = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.Table("PrincipalDerived", null),
                true,
                "DerivedId");
            overrides.Add(StoreObjectIdentifier.Table("PrincipalDerived", null), idPrincipalDerived);
            id.AddAnnotation("Relational:RelationalOverrides", overrides);


            var alternateId = runtimeEntityType.AddProperty(
                "AlternateId",
                typeof(Guid),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"),
                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
            alternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AnEnum)0);
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)0);
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)6);
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));

            var point = runtimeEntityType.AddProperty(
                "Point",
                typeof(Point),
                nullable: true,
                valueGenerated: ValueGenerated.OnAdd,
                valueConverter: new CastingConverter<Point, Point>(),
                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>(),
                providerValueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
            point.TypeMapping = null;
            point.AddAnnotation("Relational:ColumnType", "geometry");
            point.AddAnnotation("Relational:DefaultValue", (NetTopologySuite.Geometries.Point)new NetTopologySuite.IO.WKTReader().Read("SRID=0;POINT Z(0 0 0)"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var key = runtimeEntityType.AddKey(
                new[] { id });

            var key0 = runtimeEntityType.AddKey(
                new[] { id, alternateId });
            runtimeEntityType.SetPrimaryKey(key0);
            key0.AddAnnotation("Relational:Name", "PK");

            var index = runtimeEntityType.AddIndex(
                new[] { alternateId, id });

            return runtimeEntityType;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Deriveds",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("PrincipalsId"), joinEntityType.FindProperty("PrincipalsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var inverse = targetEntityType.FindSkipNavigation("Principals");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPT");
            runtimeEntityType.AddAnnotation("Relational:Schema", "mySchema");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedTypeEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal.Json;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class OwnedTypeEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true,
                changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalBaseId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var principalBaseIdPrincipalBase = new RuntimeRelationalPropertyOverrides(
                principalBaseId,
                StoreObjectIdentifier.Table("PrincipalBase", "mySchema"),
                false,
                null);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:IdentityIncrement", 3);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:IdentitySeed", 2L);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            overrides.Add(StoreObjectIdentifier.Table("PrincipalBase", "mySchema"), principalBaseIdPrincipalBase);
            principalBaseId.AddAnnotation("Relational:RelationalOverrides", overrides);


            var principalBaseAlternateId = runtimeEntityType.AddProperty(
                "PrincipalBaseAlternateId",
                typeof(Guid),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalBaseAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            details.TypeMapping = SqliteStringTypeMapping.Default;

            var overrides0 = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var detailsDetails = new RuntimeRelationalPropertyOverrides(
                details,
                StoreObjectIdentifier.Table("Details", null),
                false,
                null);
            overrides0.Add(StoreObjectIdentifier.Table("Details", null), detailsDetails);
            details.AddAnnotation("Relational:RelationalOverrides", overrides0);


            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalBaseId, principalBaseAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true,
                ownership: true);

            var owned = principalEntityType.AddNavigation("Owned",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("PrincipalBaseId"), principalEntityType.FindProperty("PrincipalBaseAlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var fragments = new StoreObjectDictionary<RuntimeEntityTypeMappingFragment>();
            var detailsFragment = new RuntimeEntityTypeMappingFragment(
                runtimeEntityType,
                StoreObjectIdentifier.Table("Details", null),
                null);
            fragments.Add(StoreObjectIdentifier.Table("Details", null), detailsFragment);
            runtimeEntityType.AddAnnotation("Relational:MappingFragments", fragments);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", "mySchema");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedType0EntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal.Json;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class OwnedType0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true);

            var principalDerivedId = runtimeEntityType.AddProperty(
                "PrincipalDerivedId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalDerivedId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                "PrincipalDerivedAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalDerivedAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            details.TypeMapping = SqliteStringTypeMapping.Default;

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalDerivedId, principalDerivedAlternateId, id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalDerivedId"), declaringEntityType.FindProperty("PrincipalDerivedAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var manyOwned = principalEntityType.AddNavigation("ManyOwned",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.OwnedType>),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("ManyOwned", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyOwned");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);
            runtimeEntityType.AddAnnotation("SqlServer:MemoryOptimized", true);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class PrincipalBasePrincipalDerivedDependentBasebyteEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var derivedsId = runtimeEntityType.AddProperty(
                "DerivedsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var derivedsAlternateId = runtimeEntityType.AddProperty(
                "DerivedsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var principalsId = runtimeEntityType.AddProperty(
                "PrincipalsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var principalsAlternateId = runtimeEntityType.AddProperty(
                "PrincipalsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var rowid = runtimeEntityType.AddProperty(
                "rowid",
                typeof(byte[]),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            rowid.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var key = runtimeEntityType.AddKey(
                new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalsId, principalsAlternateId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("DerivedsId"), declaringEntityType.FindProperty("DerivedsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalsId"), declaringEntityType.FindProperty("PrincipalsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBasePrincipalDerived<DependentBase<byte?>>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DependentDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.Two);

            var data = runtimeEntityType.AddProperty(
                "Data",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetProperty("Data", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetField("<Data>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 20,
                unicode: false);
            data.TypeMapping = SqliteStringTypeMapping.Default;
            data.AddAnnotation("Relational:IsFixedLength", true);

            var money = runtimeEntityType.AddProperty(
                "Money",
                typeof(decimal),
                precision: 9,
                scale: 3,
                sentinel: 0m);
            money.TypeMapping = SqliteDecimalTypeMapping.Default;

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorValue: "PrincipalDerived<DependentBase<byte?>>");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Principals",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("DerivedsId"), joinEntityType.FindProperty("DerivedsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Principals", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Principals>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            var inverse = targetEntityType.FindSkipNavigation("Deriveds");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalDerived");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var dataEntity = model.FindEntityType(typeof(Data));

                    Assert.Equal(typeof(Data).FullName, dataEntity.Name);
                    Assert.False(dataEntity.HasSharedClrType);
                    Assert.False(dataEntity.IsPropertyBag);
                    Assert.False(dataEntity.IsOwned());
                    Assert.IsType<ConstructorBinding>(dataEntity.ConstructorBinding);
                    Assert.Null(dataEntity.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, dataEntity.GetChangeTrackingStrategy());
                    Assert.Equal("Data", dataEntity.GetTableName());
                    Assert.Null(dataEntity.GetSchema());

                    var point = dataEntity.FindProperty("Point");
                    Assert.Equal(typeof(Point), point.ClrType);
                    Assert.True(point.IsNullable);
                    Assert.Equal(ValueGenerated.Never, point.ValueGenerated);
                    Assert.Equal("Point", point.GetColumnName());
                    Assert.Equal("POINT", point.GetColumnType());
                    Assert.Null(point.GetValueConverter());
                    Assert.IsType<GeometryValueComparer<Point>>(point.GetValueComparer());
                    Assert.IsType<GeometryValueComparer<Point>>(point.GetKeyValueComparer());
                    Assert.Null(point.GetSrid());

                    var manyTypesType = model.FindEntityType(typeof(ManyTypes));

                    Assert.Equal(typeof(ManyTypes).FullName, manyTypesType.Name);
                    Assert.False(manyTypesType.HasSharedClrType);
                    Assert.False(manyTypesType.IsPropertyBag);
                    Assert.False(manyTypesType.IsOwned());
                    Assert.IsType<ConstructorBinding>(manyTypesType.ConstructorBinding);
                    Assert.Null(manyTypesType.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, manyTypesType.GetChangeTrackingStrategy());
                    Assert.Equal("ManyTypes", manyTypesType.GetTableName());
                    Assert.Null(manyTypesType.GetSchema());

                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetCollation()).Message);
                    Assert.Empty(model.GetAnnotations());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPropertyAccessMode()).Message);

                    Assert.Null(model.FindEntityType(typeof(AbstractBase)));
                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    Assert.Equal(typeof(PrincipalBase).FullName, principalBase.Name);
                    Assert.False(principalBase.HasSharedClrType);
                    Assert.False(principalBase.IsPropertyBag);
                    Assert.False(principalBase.IsOwned());
                    Assert.Null(principalBase.BaseType);
                    Assert.IsType<ConstructorBinding>(principalBase.ConstructorBinding);
                    Assert.Null(principalBase.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalBase.GetChangeTrackingStrategy());
                    Assert.Null(principalBase.GetQueryFilter());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Equal("mySchema", principalBase.GetSchema());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalBase.GetSeedData()).Message);

                    var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id));
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.RelationalOverrides },
                        principalId.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(long?), principalId.ClrType);
                    Assert.Equal(typeof(long?), principalId.PropertyInfo.PropertyType);
                    Assert.Equal(typeof(long?), principalId.FieldInfo.FieldType);
                    Assert.False(principalId.IsNullable);
                    Assert.Equal(ValueGenerated.Never, principalId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, principalId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, principalId.GetBeforeSaveBehavior());
                    Assert.Null(principalId[CoreAnnotationNames.BeforeSaveBehavior]);
                    Assert.Null(principalId[CoreAnnotationNames.AfterSaveBehavior]);
                    Assert.Equal("Id", principalId.GetColumnName());
                    Assert.Equal("Id", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalBase", "mySchema")));
                    Assert.Equal("DerivedId", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalDerived")));
                    Assert.Equal("INTEGER", principalId.GetColumnType());
                    Assert.Null(principalId.GetValueConverter());
                    Assert.NotNull(principalId.GetValueComparer());
                    Assert.NotNull(principalId.GetKeyValueComparer());

                    var pointProperty = principalBase.FindProperty("Point");
                    Assert.Equal(typeof(Point), pointProperty.ClrType);
                    Assert.True(pointProperty.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, pointProperty.ValueGenerated);
                    Assert.Equal("Point", pointProperty.GetColumnName());
                    Assert.Equal("geometry", pointProperty.GetColumnType());
                    Assert.Equal(0, ((Point)pointProperty.GetDefaultValue()).SRID);
                    Assert.IsType<CastingConverter<Point, Point>>(pointProperty.GetValueConverter());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetKeyValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetProviderValueComparer());
                    Assert.Null(pointProperty[CoreAnnotationNames.PropertyAccessMode]);

                    Assert.Null(principalBase.FindDiscriminatorProperty());

                    var principalAlternateId = principalBase.FindProperty(nameof(PrincipalBase.AlternateId));
                    var compositeIndex = principalBase.GetIndexes().Single();
                    Assert.Equal(PropertyAccessMode.FieldDuringConstruction, principalAlternateId.GetPropertyAccessMode());
                    Assert.Empty(compositeIndex.GetAnnotations());
                    Assert.Equal(new[] { principalAlternateId, principalId }, compositeIndex.Properties);
                    Assert.False(compositeIndex.IsUnique);
                    Assert.Null(compositeIndex.Name);
                    Assert.Equal("IX_PrincipalBase_AlternateId_Id", compositeIndex.GetDatabaseName());

                    Assert.Equal(new[] { compositeIndex }, principalAlternateId.GetContainingIndexes());

                    Assert.Equal(2, principalBase.GetKeys().Count());

                    var principalAlternateKey = principalBase.GetKeys().First();
                    Assert.Same(principalId, principalAlternateKey.Properties.Single());
                    Assert.False(principalAlternateKey.IsPrimaryKey());
                    Assert.Equal("AK_PrincipalBase_Id", principalAlternateKey.GetName());

                    var principalKey = principalBase.GetKeys().Last();
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.Name },
                        principalKey.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(new[] { principalId, principalAlternateId }, principalKey.Properties);
                    Assert.True(principalKey.IsPrimaryKey());
                    Assert.Equal("PK", principalKey.GetName());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalKey.IsClustered()).Message);

                    Assert.Equal(new[] { principalAlternateKey, principalKey }, principalId.GetContainingKeys());

                    var referenceOwnedNavigation = principalBase.GetNavigations().Single();
                    Assert.Equal(
                        new[] { CoreAnnotationNames.EagerLoaded },
                        referenceOwnedNavigation.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.Name);
                    Assert.False(referenceOwnedNavigation.IsCollection);
                    Assert.True(referenceOwnedNavigation.IsEagerLoaded);
                    Assert.False(referenceOwnedNavigation.IsOnDependent);
                    Assert.Equal(typeof(OwnedType), referenceOwnedNavigation.ClrType);
                    Assert.Equal("_ownedField", referenceOwnedNavigation.FieldInfo.Name);
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.PropertyInfo.Name);
                    Assert.Null(referenceOwnedNavigation.Inverse);
                    Assert.Equal(principalBase, referenceOwnedNavigation.DeclaringEntityType);
                    Assert.Equal(PropertyAccessMode.Field, referenceOwnedNavigation.GetPropertyAccessMode());
                    Assert.Null(referenceOwnedNavigation[CoreAnnotationNames.PropertyAccessMode]);

                    var referenceOwnedType = referenceOwnedNavigation.TargetEntityType;
                    Assert.Equal(typeof(PrincipalBase).FullName + ".Owned#OwnedType", referenceOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), referenceOwnedType.ClrType);
                    Assert.True(referenceOwnedType.HasSharedClrType);
                    Assert.False(referenceOwnedType.IsPropertyBag);
                    Assert.True(referenceOwnedType.IsOwned());
                    Assert.Null(referenceOwnedType.BaseType);
                    Assert.False(referenceOwnedType.IsMemoryOptimized());
                    Assert.IsType<ConstructorBinding>(referenceOwnedType.ConstructorBinding);
                    Assert.Null(referenceOwnedType.FindIndexerPropertyInfo());
                    Assert.Equal(
                        ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                        referenceOwnedType.GetChangeTrackingStrategy());
                    Assert.Null(referenceOwnedType.GetQueryFilter());
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.PropertyAccessMode]);
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.NavigationAccessMode]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetPropertyAccessMode()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetNavigationAccessMode()).Message);

                    var principalTable = StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value;

                    var ownedId = referenceOwnedType.FindProperty("PrincipalBaseId");
                    Assert.True(ownedId.IsPrimaryKey());

                    var detailsProperty = referenceOwnedType.FindProperty(nameof(OwnedType.Details));

                    var ownedFragment = referenceOwnedType.GetMappingFragments().Single();
                    Assert.Equal(nameof(OwnedType.Details), detailsProperty.GetColumnName(ownedFragment.StoreObject));
                    Assert.Null(detailsProperty.GetColumnName(principalTable));

                    var referenceOwnership = referenceOwnedNavigation.ForeignKey;
                    Assert.Empty(referenceOwnership.GetAnnotations());
                    Assert.Same(referenceOwnership, referenceOwnedType.FindOwnership());
                    Assert.True(referenceOwnership.IsOwnership);
                    Assert.True(referenceOwnership.IsRequired);
                    Assert.True(referenceOwnership.IsRequiredDependent);
                    Assert.True(referenceOwnership.IsUnique);
                    Assert.Null(referenceOwnership.DependentToPrincipal);
                    Assert.Same(referenceOwnedNavigation, referenceOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, referenceOwnership.DeleteBehavior);
                    Assert.Equal(2, referenceOwnership.Properties.Count());
                    Assert.Same(principalKey, referenceOwnership.PrincipalKey);

                    var ownedServiceProperty = referenceOwnedType.GetServiceProperties().Single();
                    Assert.Empty(ownedServiceProperty.GetAnnotations());
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.ClrType);
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.PropertyInfo.PropertyType);
                    Assert.Null(ownedServiceProperty.FieldInfo);
                    Assert.Same(referenceOwnedType, ownedServiceProperty.DeclaringEntityType);
                    var ownedServicePropertyBinding = ownedServiceProperty.ParameterBinding;
                    Assert.IsType<ContextParameterBinding>(ownedServicePropertyBinding);
                    Assert.Equal(typeof(DbContext), ownedServicePropertyBinding.ServiceType);
                    Assert.Equal(ownedServiceProperty, ownedServicePropertyBinding.ConsumedProperties.Single());
                    Assert.Equal(PropertyAccessMode.PreferField, ownedServiceProperty.GetPropertyAccessMode());
                    Assert.Null(ownedServiceProperty[CoreAnnotationNames.PropertyAccessMode]);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);
                    Assert.Equal(
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+"
                        + "PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                        principalDerived.Name);
                    Assert.False(principalDerived.IsOwned());
                    Assert.IsType<ConstructorBinding>(principalDerived.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalDerived.GetChangeTrackingStrategy());
                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());

                    var tptForeignKey = principalDerived.GetForeignKeys().Single();
                    Assert.False(tptForeignKey.IsOwnership);
                    Assert.True(tptForeignKey.IsRequired);
                    Assert.False(tptForeignKey.IsRequiredDependent);
                    Assert.True(tptForeignKey.IsUnique);
                    Assert.Null(tptForeignKey.DependentToPrincipal);
                    Assert.Null(tptForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, tptForeignKey.DeleteBehavior);
                    Assert.Equal(principalKey.Properties, tptForeignKey.Properties);
                    Assert.Same(principalKey, tptForeignKey.PrincipalKey);

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.True(dependentNavigation.IsEagerLoaded);
                    Assert.False(dependentNavigation.LazyLoadingEnabled);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var ownedCollectionNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.Name);
                    Assert.Null(ownedCollectionNavigation.PropertyInfo);
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<OwnedType>), ownedCollectionNavigation.ClrType);
                    Assert.True(ownedCollectionNavigation.IsCollection);
                    Assert.True(ownedCollectionNavigation.IsEagerLoaded);
                    Assert.False(ownedCollectionNavigation.IsOnDependent);
                    Assert.Null(ownedCollectionNavigation.Inverse);
                    Assert.Equal(principalDerived, ownedCollectionNavigation.DeclaringEntityType);

                    var collectionOwnedType = ownedCollectionNavigation.TargetEntityType;
                    Assert.Equal(principalDerived.Name + ".ManyOwned#OwnedType", collectionOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), collectionOwnedType.ClrType);
                    Assert.True(collectionOwnedType.HasSharedClrType);
                    Assert.False(collectionOwnedType.IsPropertyBag);
                    Assert.True(collectionOwnedType.IsOwned());
                    Assert.True(collectionOwnedType.IsMemoryOptimized());
                    Assert.Null(collectionOwnedType[RelationalAnnotationNames.IsTableExcludedFromMigrations]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => collectionOwnedType.IsTableExcludedFromMigrations()).Message);
                    Assert.Null(collectionOwnedType.BaseType);
                    Assert.IsType<ConstructorBinding>(collectionOwnedType.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, collectionOwnedType.GetChangeTrackingStrategy());

                    var collectionOwnership = ownedCollectionNavigation.ForeignKey;
                    Assert.Same(collectionOwnership, collectionOwnedType.FindOwnership());
                    Assert.True(collectionOwnership.IsOwnership);
                    Assert.True(collectionOwnership.IsRequired);
                    Assert.False(collectionOwnership.IsRequiredDependent);
                    Assert.False(collectionOwnership.IsUnique);
                    Assert.Null(collectionOwnership.DependentToPrincipal);
                    Assert.Same(ownedCollectionNavigation, collectionOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, collectionOwnership.DeleteBehavior);
                    Assert.Equal(2, collectionOwnership.Properties.Count());

                    var derivedSkipNavigation = principalDerived.GetDeclaredSkipNavigations().Single();
                    Assert.Equal("Principals", derivedSkipNavigation.Name);
                    Assert.Equal("Principals", derivedSkipNavigation.PropertyInfo.Name);
                    Assert.Equal("<Principals>k__BackingField", derivedSkipNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<PrincipalBase>), derivedSkipNavigation.ClrType);
                    Assert.True(derivedSkipNavigation.IsCollection);
                    Assert.True(derivedSkipNavigation.IsEagerLoaded);
                    Assert.False(derivedSkipNavigation.LazyLoadingEnabled);
                    Assert.False(derivedSkipNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, derivedSkipNavigation.DeclaringEntityType);
                    Assert.Equal("Deriveds", derivedSkipNavigation.Inverse.Name);
                    Assert.Same(principalBase.GetSkipNavigations().Single(), derivedSkipNavigation.Inverse);

                    Assert.Same(derivedSkipNavigation, derivedSkipNavigation.ForeignKey.GetReferencingSkipNavigations().Single());
                    Assert.Same(
                        derivedSkipNavigation.Inverse, derivedSkipNavigation.Inverse.ForeignKey.GetReferencingSkipNavigations().Single());

                    Assert.Equal(new[] { derivedSkipNavigation.Inverse, derivedSkipNavigation }, principalDerived.GetSkipNavigations());

                    var joinType = derivedSkipNavigation.JoinEntityType;

                    Assert.Equal("PrincipalBasePrincipalDerived<DependentBase<byte?>>", joinType.Name);
                    Assert.Equal(typeof(Dictionary<string, object>), joinType.ClrType);
                    Assert.True(joinType.HasSharedClrType);
                    Assert.True(joinType.IsPropertyBag);
                    Assert.False(joinType.IsOwned());
                    Assert.Null(joinType.BaseType);
                    Assert.IsType<ConstructorBinding>(joinType.ConstructorBinding);
                    Assert.Equal("Item", joinType.FindIndexerPropertyInfo().Name);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, joinType.GetChangeTrackingStrategy());
                    Assert.Null(joinType[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => joinType.GetComment()).Message);
                    Assert.Null(joinType.GetQueryFilter());

                    var rowid = joinType.GetProperties().Single(p => !p.IsForeignKey());
                    Assert.Equal(typeof(byte[]), rowid.ClrType);
                    Assert.True(rowid.IsIndexerProperty());
                    Assert.Same(joinType.FindIndexerPropertyInfo(), rowid.PropertyInfo);
                    Assert.Null(rowid.FieldInfo);
                    Assert.True(rowid.IsNullable);
                    Assert.False(rowid.IsShadowProperty());
                    Assert.True(rowid.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, rowid.ValueGenerated);
                    Assert.Equal("rowid", rowid.GetColumnName());
                    Assert.Equal("BLOB", rowid.GetColumnType());
                    Assert.Null(rowid[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetComment()).Message);
                    Assert.Null(rowid[RelationalAnnotationNames.ColumnOrder]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetColumnOrder()).Message);
                    Assert.Null(rowid.GetValueConverter());
                    Assert.NotNull(rowid.GetValueComparer());
                    Assert.NotNull(rowid.GetKeyValueComparer());

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.True(dependentForeignKey.IsRequired);
                    Assert.False(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientNoAction, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId", "PrincipalAlternateId" }, dependentForeignKey.Properties.Select(p => p.Name));
                    Assert.Same(principalKey, dependentForeignKey.PrincipalKey);

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.False(dependentBase.GetIsDiscriminatorMappingComplete());
                    var principalDiscriminator = dependentBase.FindDiscriminatorProperty();
                    Assert.IsType<DiscriminatorValueGenerator>(
                        principalDiscriminator.GetValueGeneratorFactory()(principalDiscriminator, dependentBase));
                    Assert.Equal(Enum1.One, dependentBase.GetDiscriminatorValue());

                    var dependentBaseForeignKey = dependentBase.GetForeignKeys().Single(fk => fk != dependentForeignKey);
                    var dependentForeignKeyProperty = dependentBaseForeignKey.Properties.Single();

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, dependentForeignKey }, dependentForeignKeyProperty.GetContainingForeignKeys());

                    var dependentDerived = dependentBase.GetDerivedTypes().Single();
                    Assert.Equal(Enum1.Two, dependentDerived.GetDiscriminatorValue());

                    Assert.Equal(2, dependentDerived.GetDeclaredProperties().Count());

                    var dependentData = dependentDerived.GetDeclaredProperties().First();
                    Assert.Equal(typeof(string), dependentData.ClrType);
                    Assert.Equal("Data", dependentData.Name);
                    Assert.Equal("Data", dependentData.PropertyInfo.Name);
                    Assert.Equal("<Data>k__BackingField", dependentData.FieldInfo.Name);
                    Assert.True(dependentData.IsNullable);
                    Assert.False(dependentData.IsShadowProperty());
                    Assert.False(dependentData.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentData.ValueGenerated);
                    Assert.Equal("Data", dependentData.GetColumnName());
                    Assert.Equal("TEXT", dependentData.GetColumnType());
                    Assert.Equal(20, dependentData.GetMaxLength());
                    Assert.False(dependentData.IsUnicode());
                    Assert.True(dependentData.IsFixedLength());
                    Assert.Null(dependentData.GetPrecision());
                    Assert.Null(dependentData.GetScale());

                    var dependentMoney = dependentDerived.GetDeclaredProperties().Last();
                    Assert.Equal(typeof(decimal), dependentMoney.ClrType);
                    Assert.Equal("Money", dependentMoney.Name);
                    Assert.Null(dependentMoney.PropertyInfo);
                    Assert.Null(dependentMoney.FieldInfo);
                    Assert.False(dependentMoney.IsNullable);
                    Assert.True(dependentMoney.IsShadowProperty());
                    Assert.False(dependentMoney.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentMoney.ValueGenerated);
                    Assert.Equal("Money", dependentMoney.GetColumnName());
                    Assert.Equal("TEXT", dependentMoney.GetColumnType());
                    Assert.Null(dependentMoney.GetMaxLength());
                    Assert.Null(dependentMoney.IsUnicode());
                    Assert.Null(dependentMoney.IsFixedLength());
                    Assert.Equal(9, dependentMoney.GetPrecision());
                    Assert.Equal(3, dependentMoney.GetScale());

                    Assert.Equal(
                        new[]
                        {
                            derivedSkipNavigation.ForeignKey,
                            tptForeignKey,
                            referenceOwnership,
                            collectionOwnership,
                            dependentForeignKey,
                            derivedSkipNavigation.Inverse.ForeignKey
                        },
                        principalKey.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, tptForeignKey, referenceOwnership, derivedSkipNavigation.Inverse.ForeignKey },
                        principalBase.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { derivedSkipNavigation.ForeignKey, collectionOwnership, dependentForeignKey },
                        principalDerived.GetDeclaredReferencingForeignKeys());

                    Assert.Equal(
                        new[]
                        {
                            dataEntity,
                            dependentBase,
                            dependentDerived,
                            manyTypesType,
                            principalBase,
                            referenceOwnedType,
                            principalDerived,
                            collectionOwnedType,
                            joinType
                        },
                        model.GetEntityTypes());
                },
                typeof(SqliteNetTopologySuiteDesignTimeServices));

        public class SqliteContext : DbContext
        {
            private readonly bool _jsonColumns;

            public SqliteContext(bool jsonColumns = false)
            {
                _jsonColumns = jsonColumns;
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseSqlite(o => o.UseNetTopologySuite());

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.Property<Point>("Point")
                            .HasSrid(1101);
                    });

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        if (!_jsonColumns)
                        {
                            eb.Property(e => e.Id).Metadata.SetColumnName("DerivedId", StoreObjectIdentifier.Table("PrincipalDerived"));
                        }

                        eb.Property(e => e.FlagsEnum2)
                            .HasSentinel(AFlagsEnum.C | AFlagsEnum.B);

                        eb.Property(e => e.AlternateId)
                            .UsePropertyAccessMode(PropertyAccessMode.FieldDuringConstruction);

                        eb.Property<Point>("Point")
                            .HasColumnType("geometry")
                            .HasDefaultValue(
                                NtsGeometryServices.Instance.CreateGeometryFactory(srid: 0).CreatePoint(new CoordinateZM(0, 0, 0, 0)))
                            .HasConversion<CastingConverter<Point, Point>, CustomValueComparer<Point>, CustomValueComparer<Point>>();

                        eb.HasIndex(e => new { e.AlternateId, e.Id });

                        eb.HasKey(e => new { e.Id, e.AlternateId })
                            .HasName("PK");

                        eb.HasAlternateKey(e => e.Id);

                        eb.Property(e => e.AlternateId).Metadata.SetJsonValueReaderWriterType(
                            _jsonColumns
                                ? typeof(MyJsonGuidReaderWriter)
                                : typeof(JsonGuidReaderWriter));

                        eb.OwnsOne(
                            e => e.Owned, ob =>
                            {
                                ob.HasChangeTrackingStrategy(ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);
                                ob.UsePropertyAccessMode(PropertyAccessMode.Field);
                                ob.Property(e => e.Details);

                                if (_jsonColumns)
                                {
                                    ob.ToJson();
                                }
                                else
                                {
                                    ob.ToTable(
                                        "PrincipalBase", "mySchema",
                                        t => t.Property("PrincipalBaseId").UseIdentityColumn(2, 3));

                                    ob.SplitToTable("Details", s => s.Property(e => e.Details));

                                    ob.HasData(
                                        new
                                        {
                                            Number = 10,
                                            PrincipalBaseId = 1L,
                                            PrincipalBaseAlternateId = new Guid()
                                        });
                                }
                            });

                        eb.Navigation(e => e.Owned).IsRequired().HasField("_ownedField")
                            .UsePropertyAccessMode(PropertyAccessMode.Field);

                        if (!_jsonColumns)
                        {
                            eb.HasData(new PrincipalBase { Id = 1, AlternateId = new Guid() });

                            eb.ToTable("PrincipalBase", "mySchema");
                        }
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        eb.HasOne(e => e.Dependent).WithOne(e => e.Principal)
                            .HasForeignKey<DependentBase<byte?>>()
                            .OnDelete(DeleteBehavior.ClientNoAction);

                        eb.Navigation(e => e.Dependent).AutoInclude().EnableLazyLoading(false);

                        eb.OwnsMany(
                            typeof(OwnedType).FullName, "ManyOwned", ob =>
                            {
                                if (_jsonColumns)
                                {
                                    ob.ToJson();
                                }
                                else
                                {
                                    ob.ToTable("ManyOwned", t => t.IsMemoryOptimized().ExcludeFromMigrations());
                                }
                            });

                        eb.HasMany(e => e.Principals).WithMany(e => (ICollection<PrincipalDerived<DependentBase<byte?>>>)e.Deriveds)
                            .UsingEntity(
                                jb =>
                                {
                                    jb.ToTable(tb => tb.HasComment("Join table"));
                                    jb.Property<byte[]>("rowid")
                                        .IsRowVersion()
                                        .HasComment("RowVersion")
                                        .HasColumnOrder(1);
                                });

                        eb.Navigation(e => e.Principals).AutoInclude().EnableLazyLoading(false);

                        if (!_jsonColumns)
                        {
                            eb.ToTable("PrincipalDerived");
                        }
                    });

                modelBuilder.Entity<DependentBase<byte?>>(
                    eb =>
                    {
                        eb.Property<byte?>("Id");

                        eb.HasKey("PrincipalId", "PrincipalAlternateId");

                        eb.HasOne<PrincipalBase>().WithOne()
                            .HasForeignKey<DependentBase<byte?>>("PrincipalId")
                            .HasPrincipalKey<PrincipalBase>(e => e.Id);

                        eb.HasDiscriminator<Enum1>("EnumDiscriminator")
                            .HasValue(Enum1.One)
                            .HasValue<DependentDerived<byte?>>(Enum1.Two)
                            .IsComplete(false);
                    });

                modelBuilder.Entity<DependentDerived<byte?>>(
                    eb =>
                    {
                        eb.Property<string>("Data")
                            .HasMaxLength(20)
                            .IsFixedLength()
                            .IsUnicode(false);

                        eb.Property<decimal>("Money")
                            .HasPrecision(9, 3);
                    });

                modelBuilder.Entity<ManyTypes>();
            }
        }

        [ConditionalFact]
        public void Cosmos()
            => Test(
                new CosmosContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "CosmosContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.CosmosContext))]
    public partial class CosmosContextModel : RuntimeModel
    {
        static CosmosContextModel()
        {
            var model = new CosmosContextModel();
            model.Initialize();
            model.Customize();
            _instance = model;
        }

        private static CosmosContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "CosmosContextModelBuilder.cs",
                        """
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class CosmosContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);

            DataEntityType.CreateAnnotations(data);

            AddAnnotation("Cosmos:ContainerName", "Default");
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Cosmos.Storage.Internal;
using Microsoft.EntityFrameworkCore.Cosmos.ValueGeneration.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Newtonsoft.Json.Linq;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = CosmosTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var partitionId = runtimeEntityType.AddProperty(
                "PartitionId",
                typeof(long?),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                providerPropertyType: typeof(string));
            partitionId.TypeMapping = CosmosTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<long, string>(
                    (long v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => long.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<long, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<long, string>(
                        (long v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => long.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = CosmosTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => v1 == null ? v2 == null : v2 != null && v1.Length == v2.Length && v1 == v2 || v1.Zip(v2, (byte v1, byte v2) => v1 == v2).All((bool v) => v),
                    (Byte[] v) => v.Aggregate(new HashCode(), (HashCode h, byte e) => ValueComparer.Add(h, (int)e), (HashCode h) => h.ToHashCode()),
                    (Byte[] v) => v.Select((byte v) => v).ToArray()),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                clrType: typeof(byte[]),
                jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance);
            blob.AddAnnotation("Cosmos:PropertyName", "JsonBlob");

            var __id = runtimeEntityType.AddProperty(
                "__id",
                typeof(string),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new IdValueGeneratorFactory().Create);
            __id.TypeMapping = CosmosTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
            __id.AddAnnotation("Cosmos:PropertyName", "id");

            var __jObject = runtimeEntityType.AddProperty(
                "__jObject",
                typeof(JObject),
                nullable: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            __jObject.TypeMapping = CosmosTypeMapping.Default.Clone(
                comparer: new ValueComparer<JObject>(
                    (JObject v1, JObject v2) => object.Equals(v1, v2),
                    (JObject v) => v.GetHashCode(),
                    (JObject v) => v),
                keyComparer: new ValueComparer<JObject>(
                    (JObject v1, JObject v2) => object.Equals(v1, v2),
                    (JObject v) => v.GetHashCode(),
                    (JObject v) => v),
                providerValueComparer: new ValueComparer<JObject>(
                    (JObject v1, JObject v2) => object.Equals(v1, v2),
                    (JObject v) => v.GetHashCode(),
                    (JObject v) => v),
                clrType: typeof(JObject));
            __jObject.AddAnnotation("Cosmos:PropertyName", "");

            var _etag = runtimeEntityType.AddProperty(
                "_etag",
                typeof(string),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            _etag.TypeMapping = CosmosTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                clrType: typeof(string),
                jsonValueReaderWriter: JsonStringReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id, partitionId });
            runtimeEntityType.SetPrimaryKey(key);

            var key0 = runtimeEntityType.AddKey(
                new[] { __id, partitionId });

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Cosmos:ContainerName", "DataContainer");
            runtimeEntityType.AddAnnotation("Cosmos:ETagName", "_etag");
            runtimeEntityType.AddAnnotation("Cosmos:PartitionKeyName", "PartitionId");

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    Assert.Single((IEnumerable)model.GetEntityTypes());
                    var dataEntity = model.FindEntityType(typeof(Data));
                    Assert.Equal(typeof(Data).FullName, dataEntity.Name);
                    Assert.False(dataEntity.HasSharedClrType);
                    Assert.False(dataEntity.IsPropertyBag);
                    Assert.False(dataEntity.IsOwned());
                    Assert.IsType<ConstructorBinding>(dataEntity.ConstructorBinding);
                    Assert.Null(dataEntity.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, dataEntity.GetChangeTrackingStrategy());
                    Assert.Equal("DataContainer", dataEntity.GetContainer());
                    Assert.Null(dataEntity.FindDiscriminatorProperty());

                    var id = dataEntity.FindProperty("Id");
                    Assert.Equal(typeof(int), id.ClrType);
                    Assert.Null(id.PropertyInfo);
                    Assert.Null(id.FieldInfo);
                    Assert.False(id.IsNullable);
                    Assert.False(id.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, id.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, id.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, id.GetBeforeSaveBehavior());
                    Assert.Equal("Id", CosmosPropertyExtensions.GetJsonPropertyName(id));
                    Assert.Null(id.GetValueGeneratorFactory());
                    Assert.Null(id.GetValueConverter());
                    Assert.NotNull(id.GetValueComparer());
                    Assert.NotNull(id.GetKeyValueComparer());

                    var storeId = dataEntity.FindProperty("__id");
                    Assert.Equal(typeof(string), storeId.ClrType);
                    Assert.Null(storeId.PropertyInfo);
                    Assert.Null(storeId.FieldInfo);
                    Assert.False(storeId.IsNullable);
                    Assert.False(storeId.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, storeId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, storeId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, storeId.GetBeforeSaveBehavior());
                    Assert.Equal("id", CosmosPropertyExtensions.GetJsonPropertyName(storeId));
                    Assert.IsType<IdValueGenerator>(storeId.GetValueGeneratorFactory()(storeId, dataEntity));
                    Assert.Null(storeId.GetValueConverter());
                    Assert.NotNull(storeId.GetValueComparer());
                    Assert.NotNull(storeId.GetKeyValueComparer());

                    var partitionId = dataEntity.FindProperty("PartitionId");
                    Assert.Equal(typeof(long?), partitionId.ClrType);
                    Assert.Null(partitionId.PropertyInfo);
                    Assert.Null(partitionId.FieldInfo);
                    Assert.False(partitionId.IsNullable);
                    Assert.False(partitionId.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, partitionId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, partitionId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, partitionId.GetBeforeSaveBehavior());
                    Assert.Equal("PartitionId", CosmosPropertyExtensions.GetJsonPropertyName(partitionId));
                    Assert.Null(partitionId.GetValueGeneratorFactory());
                    Assert.Null(partitionId.GetValueConverter());
                    Assert.Equal("1", partitionId.FindTypeMapping().Converter.ConvertToProvider(1));
                    Assert.NotNull(partitionId.GetValueComparer());
                    Assert.NotNull(partitionId.GetKeyValueComparer());

                    var eTag = dataEntity.FindProperty("_etag");
                    Assert.Equal(typeof(string), eTag.ClrType);
                    Assert.Null(eTag.PropertyInfo);
                    Assert.Null(eTag.FieldInfo);
                    Assert.True(eTag.IsNullable);
                    Assert.True(eTag.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, eTag.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Ignore, eTag.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Ignore, eTag.GetBeforeSaveBehavior());
                    Assert.Equal("_etag", CosmosPropertyExtensions.GetJsonPropertyName(eTag));
                    Assert.Null(eTag.GetValueGeneratorFactory());
                    Assert.Null(eTag.GetValueConverter());
                    Assert.NotNull(eTag.GetValueComparer());
                    Assert.NotNull(eTag.GetKeyValueComparer());
                    Assert.Equal("_etag", dataEntity.GetETagPropertyName());
                    Assert.Same(eTag, dataEntity.GetETagProperty());

                    var blob = dataEntity.FindProperty(nameof(Data.Blob));
                    Assert.Equal(typeof(byte[]), blob.ClrType);
                    Assert.Equal(nameof(Data.Blob), blob.PropertyInfo.Name);
                    Assert.Equal("<Blob>k__BackingField", blob.FieldInfo.Name);
                    Assert.True(blob.IsNullable);
                    Assert.False(blob.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, blob.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Save, blob.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, blob.GetBeforeSaveBehavior());
                    Assert.Equal("JsonBlob", CosmosPropertyExtensions.GetJsonPropertyName(blob));
                    Assert.Null(blob.GetValueGeneratorFactory());
                    Assert.Null(blob.GetValueConverter());
                    Assert.NotNull(blob.GetValueComparer());
                    Assert.NotNull(blob.GetKeyValueComparer());

                    var jObject = dataEntity.FindProperty("__jObject");
                    Assert.Equal(typeof(JObject), jObject.ClrType);
                    Assert.Null(jObject.PropertyInfo);
                    Assert.Null(jObject.FieldInfo);
                    Assert.True(jObject.IsNullable);
                    Assert.False(jObject.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, jObject.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Ignore, jObject.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Ignore, jObject.GetBeforeSaveBehavior());
                    Assert.Equal("", CosmosPropertyExtensions.GetJsonPropertyName(jObject));
                    Assert.Null(jObject.GetValueGeneratorFactory());
                    Assert.Null(jObject.GetValueConverter());
                    Assert.NotNull(jObject.GetValueComparer());
                    Assert.NotNull(jObject.GetKeyValueComparer());

                    Assert.Equal(2, dataEntity.GetKeys().Count());

                    Assert.Equal(new[] { id, partitionId, blob, storeId, jObject, eTag }, dataEntity.GetProperties());
                });

        public class CosmosContext : DbContext
        {
            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseCosmos("localhost", "_", "_");

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

                modelBuilder.HasDefaultContainer("Default");

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.Property<long?>("PartitionId").HasConversion<string>();
                        eb.HasPartitionKey("PartitionId");
                        eb.HasKey("Id", "PartitionId");
                        eb.ToContainer("DataContainer");
                        eb.UseETagConcurrency();
                        eb.HasNoDiscriminator();
                        eb.Property(d => d.Blob).ToJsonProperty("JsonBlob");
                    });
            }
        }

        public class Data
        {
            public byte[] Blob { get; set; }
        }

        public abstract class ContextBase : DbContext
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
                => modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseInMemoryDatabase(nameof(CSharpRuntimeModelCodeGeneratorTest));
        }

        public abstract class SqlServerContextBase : DbContext
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
                => modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseSqlServer(o => o.UseNetTopologySuite());
        }

        protected void Test(
            DbContext context,
            CompiledModelCodeGenerationOptions options,
            Action<IReadOnlyCollection<ScaffoldedFile>> assertScaffold = null,
            Action<IModel> assertModel = null,
            Type additionalDesignTimeServices = null,
            Action<DbContext> useContext = null,
            string expectedExceptionMessage = null)
        {
            var model = context.GetService<IDesignTimeModel>().Model;

            options.ModelNamespace ??= "TestNamespace";
            options.ContextType = context.GetType();

            var generator = DesignTestHelpers.Instance.CreateDesignServiceProvider(
                    context.GetService<IDatabaseProvider>().Name,
                    additionalDesignTimeServices: additionalDesignTimeServices)
                .GetRequiredService<ICompiledModelCodeGeneratorSelector>()
                .Select(options);

            if (expectedExceptionMessage != null)
            {
                Assert.Equal(
                    expectedExceptionMessage,
                    Assert.Throws<InvalidOperationException>(
                        () => generator.GenerateModel(
                            model,
                            options)).Message);
                return;
            }

            var scaffoldedFiles = generator.GenerateModel(
                model,
                options);

            var build = new BuildSource
            {
                References =
                {
                    BuildReference.ByName("System.Linq"),
                    BuildReference.ByName("System.Net.Primitives"),
                    BuildReference.ByName("System.Net.NetworkInformation"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Abstractions"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Cosmos"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.InMemory"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Proxies"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Relational"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Sqlite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Sqlite.NetTopologySuite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.SqlServer"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.SqlServer.NetTopologySuite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Specification.Tests"),
                    BuildReference.ByName("NetTopologySuite"),
                    BuildReference.ByName("Newtonsoft.Json"),
                    BuildReference.ByName(typeof(CSharpRuntimeModelCodeGeneratorTest).Assembly.GetName().Name)
                },
                Sources = scaffoldedFiles.ToDictionary(f => f.Path, f => f.Code),
                NullableReferenceTypes = options.UseNullableReferenceTypes
            };

            var assembly = build.BuildInMemory();

            var modelTypeName = options.ContextType.Name + "Model";
            var modelType = assembly.GetType(
                string.IsNullOrEmpty(options.ModelNamespace)
                    ? modelTypeName
                    : options.ModelNamespace + "." + modelTypeName);
            var instancePropertyInfo = modelType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
            var compiledModel = (IModel)instancePropertyInfo.GetValue(null);

            var modelRuntimeInitializer = context.GetService<IModelRuntimeInitializer>();
            compiledModel = modelRuntimeInitializer.Initialize(compiledModel, designTime: false);
            assertModel(compiledModel);

            var relationalModel = (IRelationalModel)context.Model.FindRuntimeAnnotationValue(RelationalAnnotationNames.RelationalModel);
            if (relationalModel != null)
            {
                RelationalModelTest.AssertEqual(relationalModel, compiledModel.GetRelationalModel());
            }

            if (assertScaffold != null)
            {
                AssertBaseline(scaffoldedFiles, assertScaffold);
            }

            if (useContext != null)
            {
                using var testStore = SqlServerTestStore.Create("RuntimeModelTest" + context.GetType().Name);
                testStore.Clean(context);

                var optionsBuilder = testStore.AddProviderOptions(new DbContextOptionsBuilder().UseModel(compiledModel));
                new SqlServerDbContextOptionsBuilder(optionsBuilder).UseNetTopologySuite();
                var newContext = new DbContext(optionsBuilder.Options);

                newContext.Database.CreateExecutionStrategy().Execute(
                    newContext,
                    c =>
                    {
                        using var transaction = context.Database.BeginTransaction();
                        useContext(c);
                    });
            }
        }

        private const string FileNewLine = @"
";

        private static readonly object _baselineFileLock = new();

        private static void AssertBaseline(
            IReadOnlyCollection<ScaffoldedFile> scaffoldedFiles,
            Action<IReadOnlyCollection<ScaffoldedFile>> assertScaffold)
        {
            try
            {
                assertScaffold(scaffoldedFiles);
            }
            catch
            {
                var methodCallLine = Environment.StackTrace.Split(
                    new[] { Environment.NewLine },
                    StringSplitOptions.RemoveEmptyEntries)[3][6..];

                var indexMethodEnding = methodCallLine.IndexOf(')') + 1;
                var testName = methodCallLine[..indexMethodEnding];
                var parts = methodCallLine[indexMethodEnding..].Split(" ", StringSplitOptions.RemoveEmptyEntries);
                var fileName = parts[1][..^5];
                var lineNumber = int.Parse(parts[2]);

                var currentDirectory = Directory.GetCurrentDirectory();
                var logFile = currentDirectory[..(currentDirectory.LastIndexOf(
                            $"{Path.DirectorySeparatorChar}artifacts{Path.DirectorySeparatorChar}",
                            StringComparison.Ordinal)
                        + 1)]
                    + "RuntimeModelBaseline.txt";

                var testInfo = testName + " : " + lineNumber + FileNewLine;

                var baselines = string.Join(
                    "," + FileNewLine,
                    scaffoldedFiles.Select(file =>
                    Indent(5) + "c => AssertFileContents(" + FileNewLine +
                    Indent(6) + $"\"{file.Path}\"," + FileNewLine +
                    Indent(6) + "\"\"\"" + FileNewLine +
                    file.Code.TrimEnd() + FileNewLine +
                    "\"\"\", c)"));

                var testString = @$"
{Indent(4)}code => Assert.Collection(
{Indent(5)}code,
{baselines}),
";

                var contents = testInfo + testString;

                lock (_baselineFileLock)
                {
                    File.Delete(logFile);
                    File.AppendAllText(logFile, contents);
                }

                throw;
            }

            static string Indent(int indent)
                => new(' ', indent * 4);
        }

        protected static void AssertFileContents(
            string expectedPath,
            string expectedCode,
            ScaffoldedFile file)
        {
            Assert.Equal(expectedPath, file.Path);
            try
            {
                Assert.Equal(expectedCode, file.Code.TrimEnd(), ignoreLineEndingDifferences: true);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                throw;
            }
        }
    }

    public class Internal
    {
        public long Id { get; set; }
    }

    public class Index
    {
        public Guid Id { get; set; }
    }

    public class IdentityUser : TestModels.AspNetIdentity.IdentityUser
    {
    }

    public class SelfReferentialEntity
    {
        public long Id { get; set; }

        public SelfReferentialProperty Collection { get; set; }
    }

    public class SelfReferentialProperty : List<SelfReferentialProperty>
    {
    }
}

namespace Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal
{
    public class DbContext : ContextBase
    {
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Index>();
            modelBuilder.Entity<IdentityUser>();
            modelBuilder.Entity<Scaffolding.Internal.IdentityUser>(
                eb =>
                {
                    eb.HasDiscriminator().HasValue("DerivedIdentityUser");
                });
            modelBuilder.Entity<Scaffolding.Internal.Internal>();
        }
    }

    public class SelfReferentialDbContext : ContextBase
    {
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<SelfReferentialEntity>(
                eb =>
                {
                    eb.Property(e => e.Collection).HasConversion(typeof(SelfReferentialPropertyValueConverter));
                });
        }
    }

    public class SelfReferentialPropertyValueConverter : ValueConverter<SelfReferentialProperty, string>
    {
        public SelfReferentialPropertyValueConverter()
            : this(null)
        {
        }

        public SelfReferentialPropertyValueConverter(ConverterMappingHints hints)
            : base(v => null, v => null, hints)
        {
        }
    }
}
